Disassembly Listing for HPD_CONTROLER
Generated From:
C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/dist/default/production/HPD_CONTROLER.X.production.elf
07:50:11 28/07/2016

---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/user.c
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 #define _user
6:                 
7:                 /* Device header file */
8:                 #if defined(__XC16__)
9:                 #include <xc.h>
10:                #elif defined(__C30__)
11:                #if defined(__dsPIC33E__)
12:                #include <p33Exxxx.h>
13:                #elif defined(__dsPIC33F__)
14:                #include <p33Fxxxx.h>
15:                #endif
16:                #endif
17:                
18:                #include <stdint.h>          /* For uint16_t definition                       */
19:                #include <stdbool.h>         /* For true/false definition                     */
20:                #include "system.h"
21:                #include "user.h"
22:                
23:                /******************************************************************************/
24:                /* User Functions                                                             */
25:                /******************************************************************************/
26:                unsigned int Spi1RxBuff[8] __attribute__((space(dma)));
27:                unsigned int Spi1TxBuff[8] __attribute__((space(dma))) = {MCP3002_CH0, MCP3002_CH0, MCP3002_CH0, MCP3002_CH0, MCP3002_CH0, MCP3002_CH0, MCP3002_CH0, MCP3002_CH0};
28:                
29:                extern u8 TXbuffer[256]; //tx bufer
30:                
31:                typedef struct PROG_POINTER_TAG {
32:                
33:                    union {
34:                        __prog__ u16* pointer;
35:                
36:                        struct {
37:                            u16 offset;
38:                            u8 tlbpag;
39:                        };
40:                    };
41:                } PROG_POINTER;
42:                
43:                u8 MemorySelfTest(void) {
00204E  FA000E     LNK #0xE
44:                    u8 Result = 0;
002050  EB4000     CLR.B W0
002052  984760     MOV.B W0, [W14+6]
45:                    u16 CS = 0;
002054  EB0000     CLR W0
002056  780F00     MOV W0, [W14]
46:                    u16 wMemory;
47:                    PROG_POINTER MemAddress;
48:                    u32 length = 0;
002058  B80060     MUL.UU W0, #0, W0
00205A  980710     MOV W0, [W14+2]
00205C  980721     MOV W1, [W14+4]
49:                
50:                    length >>= 1;
00205E  90001E     MOV [W14+2], W0
002060  9000AE     MOV [W14+4], W1
002062  D10081     LSR W1, W1
002064  D38000     RRC W0, W0
002066  980710     MOV W0, [W14+2]
002068  980721     MOV W1, [W14+4]
51:                    MemAddress.pointer = 0;
00206A  200000     MOV #0x0, W0
00206C  200001     MOV #0x0, W1
00206E  980750     MOV W0, [W14+10]
002070  980761     MOV W1, [W14+12]
52:                    while (length < 0xAC00) {
002072  370025     BRA 0x20BE
0020BE  90011E     MOV [W14+2], W2
0020C0  9001AE     MOV [W14+4], W3
0020C2  2ABFF0     MOV #0xABFF, W0
0020C4  200001     MOV #0x0, W1
0020C6  510F80     SUB W2, W0, [W15]
0020C8  598F81     SUBB W3, W1, [W15]
0020CA  36FFD4     BRA LEU, 0x2074
53:                        ClrWdt();
002074  FE6000     CLRWDT
54:                        TBLPAG = MemAddress.tlbpag;
002076  90484E     MOV.B [W14+12], W0
002078  B7E032     MOV.B WREG, TBLPAG
55:                        wMemory = __builtin_tblrdl(MemAddress.offset);
00207A  90005E     MOV [W14+10], W0
00207C  BA0010     TBLRDL [W0], W0
00207E  980740     MOV W0, [W14+8]
56:                        Result = LOBYTE(wMemory);
002080  90004E     MOV [W14+8], W0
002082  984760     MOV.B W0, [W14+6]
57:                        CS = CS + Result;
002084  90406E     MOV.B [W14+6], W0
002086  FB8000     ZE W0, W0
002088  400F1E     ADD W0, [W14], [W14]
58:                        Result = HIBYTE(wMemory);
00208A  90004E     MOV [W14+8], W0
00208C  DE8048     ASR W0, #8, W0
00208E  984760     MOV.B W0, [W14+6]
59:                        CS = CS + Result;
002090  90406E     MOV.B [W14+6], W0
002092  FB8000     ZE W0, W0
002094  400F1E     ADD W0, [W14], [W14]
60:                        wMemory = __builtin_tblrdh(MemAddress.offset);
002096  90005E     MOV [W14+10], W0
002098  BA8010     TBLRDH [W0], W0
00209A  980740     MOV W0, [W14+8]
61:                        Result = LOBYTE(wMemory);
00209C  90004E     MOV [W14+8], W0
00209E  984760     MOV.B W0, [W14+6]
62:                        CS = CS + Result;
0020A0  90406E     MOV.B [W14+6], W0
0020A2  FB8000     ZE W0, W0
0020A4  400F1E     ADD W0, [W14], [W14]
63:                        MemAddress.pointer++;
0020A6  90005E     MOV [W14+10], W0
0020A8  9000EE     MOV [W14+12], W1
0020AA  400062     ADD W0, #0x2, W0
0020AC  4880E0     ADDC W1, #0x0, W1
0020AE  980750     MOV W0, [W14+10]
0020B0  980761     MOV W1, [W14+12]
64:                        length += 2;
0020B2  90001E     MOV [W14+2], W0
0020B4  9000AE     MOV [W14+4], W1
0020B6  400062     ADD W0, #0x2, W0
0020B8  4880E0     ADDC W1, #0x0, W1
0020BA  980710     MOV W0, [W14+2]
0020BC  980721     MOV W1, [W14+4]
65:                    }
66:                
67:                    MemAddress.pointer = (__prog__ u16*) (0xF80000);
0020CC  200000     MOV #0x0, W0
0020CE  200F81     MOV #0xF8, W1
0020D0  980750     MOV W0, [W14+10]
0020D2  980761     MOV W1, [W14+12]
68:                    TBLPAG = MemAddress.tlbpag;
0020D4  90484E     MOV.B [W14+12], W0
0020D6  B7E032     MOV.B WREG, TBLPAG
69:                    wMemory = __builtin_tblrdl(MemAddress.offset);
0020D8  90005E     MOV [W14+10], W0
0020DA  BA0010     TBLRDL [W0], W0
0020DC  980740     MOV W0, [W14+8]
70:                    wMemory = wMemory & 0x0F;
0020DE  90004E     MOV [W14+8], W0
0020E0  60006F     AND W0, #0xF, W0
0020E2  980740     MOV W0, [W14+8]
71:                    Result = LOBYTE(wMemory);
0020E4  90004E     MOV [W14+8], W0
0020E6  984760     MOV.B W0, [W14+6]
72:                    CS = CS + Result;
0020E8  90406E     MOV.B [W14+6], W0
0020EA  FB8000     ZE W0, W0
0020EC  400F1E     ADD W0, [W14], [W14]
73:                    //    Result = HIBYTE(wMemory);
74:                    //    CS = CS + Result;
75:                    //MemAddress.pointer++;
76:                
77:                    MemAddress.pointer = (__prog__ u16*) (0xF80004);
0020EE  200040     MOV #0x4, W0
0020F0  200F81     MOV #0xF8, W1
0020F2  980750     MOV W0, [W14+10]
0020F4  980761     MOV W1, [W14+12]
78:                    TBLPAG = MemAddress.tlbpag;
0020F6  90484E     MOV.B [W14+12], W0
0020F8  B7E032     MOV.B WREG, TBLPAG
79:                    wMemory = __builtin_tblrdl(MemAddress.offset);
0020FA  90005E     MOV [W14+10], W0
0020FC  BA0010     TBLRDL [W0], W0
0020FE  980740     MOV W0, [W14+8]
80:                    wMemory = wMemory & 0x07;
002100  90004E     MOV [W14+8], W0
002102  600067     AND W0, #0x7, W0
002104  980740     MOV W0, [W14+8]
81:                    Result = LOBYTE(wMemory);
002106  90004E     MOV [W14+8], W0
002108  984760     MOV.B W0, [W14+6]
82:                    CS = CS + Result;
00210A  90406E     MOV.B [W14+6], W0
00210C  FB8000     ZE W0, W0
00210E  400F1E     ADD W0, [W14], [W14]
83:                    //    Result = HIBYTE(wMemory);
84:                    //    CS = CS + Result;
85:                    //MemAddress.pointer++;
86:                
87:                    MemAddress.pointer = (__prog__ u16*) (0xF80006);
002110  200060     MOV #0x6, W0
002112  200F81     MOV #0xF8, W1
002114  980750     MOV W0, [W14+10]
002116  980761     MOV W1, [W14+12]
88:                    TBLPAG = MemAddress.tlbpag;
002118  90484E     MOV.B [W14+12], W0
00211A  B7E032     MOV.B WREG, TBLPAG
89:                    wMemory = __builtin_tblrdl(MemAddress.offset);
00211C  90005E     MOV [W14+10], W0
00211E  BA0010     TBLRDL [W0], W0
002120  980740     MOV W0, [W14+8]
90:                    wMemory = wMemory & 0x87;
002122  9000CE     MOV [W14+8], W1
002124  200870     MOV #0x87, W0
002126  608000     AND W1, W0, W0
002128  980740     MOV W0, [W14+8]
91:                    Result = LOBYTE(wMemory);
00212A  90004E     MOV [W14+8], W0
00212C  984760     MOV.B W0, [W14+6]
92:                    CS = CS + Result;
00212E  90406E     MOV.B [W14+6], W0
002130  FB8000     ZE W0, W0
002132  400F1E     ADD W0, [W14], [W14]
93:                    //    Result = HIBYTE(wMemory);
94:                    //    CS = CS + Result;
95:                    //MemAddress.pointer++;
96:                
97:                    MemAddress.pointer = (__prog__ u16*) (0xF80008);
002134  200080     MOV #0x8, W0
002136  200F81     MOV #0xF8, W1
002138  980750     MOV W0, [W14+10]
00213A  980761     MOV W1, [W14+12]
98:                    TBLPAG = MemAddress.tlbpag;
00213C  90484E     MOV.B [W14+12], W0
00213E  B7E032     MOV.B WREG, TBLPAG
99:                    wMemory = __builtin_tblrdl(MemAddress.offset);
002140  90005E     MOV [W14+10], W0
002142  BA0010     TBLRDL [W0], W0
002144  980740     MOV W0, [W14+8]
100:                   wMemory = wMemory & 0xC7;
002146  9000CE     MOV [W14+8], W1
002148  200C70     MOV #0xC7, W0
00214A  608000     AND W1, W0, W0
00214C  980740     MOV W0, [W14+8]
101:                   Result = LOBYTE(wMemory);
00214E  90004E     MOV [W14+8], W0
002150  984760     MOV.B W0, [W14+6]
102:                   CS = CS + Result;
002152  90406E     MOV.B [W14+6], W0
002154  FB8000     ZE W0, W0
002156  400F1E     ADD W0, [W14], [W14]
103:                   //    Result = HIBYTE(wMemory);
104:                   //    CS = CS + Result;
105:                   //MemAddress.pointer++;
106:               
107:                   MemAddress.pointer = (__prog__ u16*) (0xF8000A);
002158  2000A0     MOV #0xA, W0
00215A  200F81     MOV #0xF8, W1
00215C  980750     MOV W0, [W14+10]
00215E  980761     MOV W1, [W14+12]
108:                   TBLPAG = MemAddress.tlbpag;
002160  90484E     MOV.B [W14+12], W0
002162  B7E032     MOV.B WREG, TBLPAG
109:                   wMemory = __builtin_tblrdl(MemAddress.offset);
002164  90005E     MOV [W14+10], W0
002166  BA0010     TBLRDL [W0], W0
002168  980740     MOV W0, [W14+8]
110:                   wMemory = wMemory & 0xDF;
00216A  9000CE     MOV [W14+8], W1
00216C  200DF0     MOV #0xDF, W0
00216E  608000     AND W1, W0, W0
002170  980740     MOV W0, [W14+8]
111:                   Result = LOBYTE(wMemory);
002172  90004E     MOV [W14+8], W0
002174  984760     MOV.B W0, [W14+6]
112:                   CS = CS + Result;
002176  90406E     MOV.B [W14+6], W0
002178  FB8000     ZE W0, W0
00217A  400F1E     ADD W0, [W14], [W14]
113:                   //    Result = HIBYTE(wMemory);
114:                   //    CS = CS + Result;
115:                   //MemAddress.pointer++;
116:               
117:                   MemAddress.pointer = (__prog__ u16*) (0xF8000C);
00217C  2000C0     MOV #0xC, W0
00217E  200F81     MOV #0xF8, W1
002180  980750     MOV W0, [W14+10]
002182  980761     MOV W1, [W14+12]
118:                   TBLPAG = MemAddress.tlbpag;
002184  90484E     MOV.B [W14+12], W0
002186  B7E032     MOV.B WREG, TBLPAG
119:                   wMemory = __builtin_tblrdl(MemAddress.offset);
002188  90005E     MOV [W14+10], W0
00218A  BA0010     TBLRDL [W0], W0
00218C  980740     MOV W0, [W14+8]
120:                   wMemory = wMemory & 0x67;
00218E  9000CE     MOV [W14+8], W1
002190  200670     MOV #0x67, W0
002192  608000     AND W1, W0, W0
002194  980740     MOV W0, [W14+8]
121:                   Result = LOBYTE(wMemory);
002196  90004E     MOV [W14+8], W0
002198  984760     MOV.B W0, [W14+6]
122:                   CS = CS + Result;
00219A  90406E     MOV.B [W14+6], W0
00219C  FB8000     ZE W0, W0
00219E  400F1E     ADD W0, [W14], [W14]
123:                   //    Result = HIBYTE(wMemory);
124:                   //    CS = CS + Result;
125:                   //MemAddress.pointer++;
126:               
127:                   MemAddress.pointer = (__prog__ u16*) (0xF8000E);
0021A0  2000E0     MOV #0xE, W0
0021A2  200F81     MOV #0xF8, W1
0021A4  980750     MOV W0, [W14+10]
0021A6  980761     MOV W1, [W14+12]
128:                   TBLPAG = MemAddress.tlbpag;
0021A8  90484E     MOV.B [W14+12], W0
0021AA  B7E032     MOV.B WREG, TBLPAG
129:                   wMemory = __builtin_tblrdl(MemAddress.offset);
0021AC  90005E     MOV [W14+10], W0
0021AE  BA0010     TBLRDL [W0], W0
0021B0  980740     MOV W0, [W14+8]
130:                   wMemory = wMemory & 0xE3;
0021B2  9000CE     MOV [W14+8], W1
0021B4  200E30     MOV #0xE3, W0
0021B6  608000     AND W1, W0, W0
0021B8  980740     MOV W0, [W14+8]
131:                   Result = LOBYTE(wMemory);
0021BA  90004E     MOV [W14+8], W0
0021BC  984760     MOV.B W0, [W14+6]
132:                   CS = CS + Result;
0021BE  90406E     MOV.B [W14+6], W0
0021C0  FB8000     ZE W0, W0
0021C2  400F1E     ADD W0, [W14], [W14]
133:                   //    Result = HIBYTE(wMemory);
134:                   //    CS = CS + Result;
135:               
136:                   MemAddress.pointer = (__prog__ u16*) (0xF80010);
0021C4  200100     MOV #0x10, W0
0021C6  200F81     MOV #0xF8, W1
0021C8  980750     MOV W0, [W14+10]
0021CA  980761     MOV W1, [W14+12]
137:                   TBLPAG = MemAddress.tlbpag;
0021CC  90484E     MOV.B [W14+12], W0
0021CE  B7E032     MOV.B WREG, TBLPAG
138:                   wMemory = __builtin_tblrdl(MemAddress.offset);
0021D0  90005E     MOV [W14+10], W0
0021D2  BA0010     TBLRDL [W0], W0
0021D4  980740     MOV W0, [W14+8]
139:                   wMemory = wMemory & 0x3F;
0021D6  9000CE     MOV [W14+8], W1
0021D8  2003F0     MOV #0x3F, W0
0021DA  608000     AND W1, W0, W0
0021DC  980740     MOV W0, [W14+8]
140:                   Result = LOBYTE(wMemory);
0021DE  90004E     MOV [W14+8], W0
0021E0  984760     MOV.B W0, [W14+6]
141:                   CS = CS + Result;
0021E2  90406E     MOV.B [W14+6], W0
0021E4  FB8000     ZE W0, W0
0021E6  400F1E     ADD W0, [W14], [W14]
142:                   //    Result = HIBYTE(wMemory);
143:                   //    CS = CS + Result;
144:                   //PulseCounter = (u32) CS;
145:                   Nop();
0021E8  000000     NOP
146:                   return Result;
0021EA  90406E     MOV.B [W14+6], W0
147:               }
0021EC  FA8000     ULNK
0021EE  060000     RETURN
148:               
149:               void InitApp(void) {
0021F0  FA0000     LNK #0x0
150:                   SRbits.IPL = 0; //global interrupt enable for main application
0021F2  800210     MOV SR, W0
0021F4  A15000     BCLR W0, #5
0021F6  A16000     BCLR W0, #6
0021F8  A17000     BCLR W0, #7
0021FA  880210     MOV W0, SR
151:                   /*--------------------------------------------------------*/
152:                   /* Timers Init*/
153:                   //    T1CON = 0; // Timer reset
154:                   //
155:                   
156:                   IPC0bits.T1IP = 6; // Timer1 Interrupt priority level=7
0021FC  800520     MOV IPC0, W0
0021FE  A1C000     BCLR W0, #12
002200  A0D000     BSET W0, #13
002202  A0E000     BSET W0, #14
002204  880520     MOV W0, IPC0
157:                   T1CONbits.TCKPS = 2; //prescaler 1:64 (25nS*64=1.6uS
002206  800820     MOV T1CON, W0
002208  A14000     BCLR W0, #4
00220A  A05000     BSET W0, #5
00220C  880820     MOV W0, T1CON
158:                   IFS0bits.T1IF = 0; // Reset Timer1 interrupt flag
00220E  A96084     BCLR IFS0, #3
159:                   IEC0bits.T1IE = 0; // Enable Timer1 interrupt
002210  A96094     BCLR IEC0, #3
160:                   TMR1 = 0;
002212  EF2100     CLR TMR1
161:                   PR1 = 12500; // Timer1 period register = 12500 x 6.4uS = 20mS
002214  230D40     MOV #0x30D4, W0
002216  880810     MOV W0, PR1
162:                   T1CONbits.TON = 1; // Enable Timer1 and start the counter
002218  A8E105     BSET 0x105, #7
163:                   //
164:                   T2CON = 0; // Timer reset
00221A  EF2110     CLR T2CON
165:                   T2CONbits.TCKPS = 3; // pescaler 1:64 (25nS * 256 = 6.4uS)
00221C  800880     MOV T2CON, W0
00221E  A04000     BSET W0, #4
002220  A05000     BSET W0, #5
002222  880880     MOV W0, T2CON
166:                   IPC1bits.T2IP = 7; // Timer1 Interrupt priority level=7
002224  800530     MOV IPC1, W0
002226  A0C000     BSET W0, #12
002228  A0D000     BSET W0, #13
00222A  A0E000     BSET W0, #14
00222C  880530     MOV W0, IPC1
167:                   IFS0bits.T2IF = 0; // Reset Timer1 interrupt flag
00222E  A9E084     BCLR IFS0, #7
168:                   IEC0bits.T2IE = 1; // Enable Timer1 interrupt
002230  A8E094     BSET IEC0, #7
169:                   TMR2 = 0;
002232  EF2106     CLR TMR2
170:               
171:                   T3CON = 0; // Timer reset
002234  EF2112     CLR T3CON
172:                   IFS0bits.T3IF = 0; // Reset Timer3 interrupt flag
002236  A90085     BCLR 0x85, #0
173:                   IEC0bits.T3IE = 1; // Enable Timer3 interrupt
002238  A80095     BSET 0x95, #0
174:                   TMR3 = 0;
00223A  EF210A     CLR TMR3
175:                   PR3 = 3999; // Timer3 period register = 4000 x 25S = 100uS
00223C  20F9F0     MOV #0xF9F, W0
00223E  880870     MOV W0, PR3
176:                   T3CONbits.TON = 1; // Enable Timer3 and start the counter
002240  A8E113     BSET 0x113, #7
177:               
178:                   T4CON = 0; // Timer reset
002242  EF211E     CLR T4CON
179:                   T4CONbits.TCKPS = 2; // pescaler 1:64 (25nS * 64 = 1.6uS)
002244  8008F0     MOV T4CON, W0
002246  A14000     BCLR W0, #4
002248  A05000     BSET W0, #5
00224A  8808F0     MOV W0, T4CON
180:                   IPC6bits.T4IP = 6; // Timer1 Interrupt priority level=7
00224C  800580     MOV IPC6, W0
00224E  A1C000     BCLR W0, #12
002250  A0D000     BSET W0, #13
002252  A0E000     BSET W0, #14
002254  880580     MOV W0, IPC6
181:                   IFS1bits.T4IF = 0; // Reset Timer1 interrupt flag
002256  A96087     BCLR 0x87, #3
182:                   IEC1bits.T4IE = 1; // Enable Timer1 interrupt
002258  A86097     BSET 0x97, #3
183:                   PR4 = 1000; // interrupt every 1.6mS
00225A  203E80     MOV #0x3E8, W0
00225C  8808D0     MOV W0, PR4
184:                   TMR4 = 0;
00225E  EF2114     CLR TMR4
185:               
186:                   //timer 5 used for one wire communication
187:                   T5CON = 0; // Timer reset
002260  EF2120     CLR T5CON
188:                   IPC7bits.T5IP = 3; // Timer1 Interrupt priority level=4
002262  800590     MOV IPC7, W0
002264  A00000     BSET W0, #0
002266  A01000     BSET W0, #1
002268  A12000     BCLR W0, #2
00226A  880590     MOV W0, IPC7
189:                   IFS1bits.T5IF = 0; // Reset Timer1 interrupt flag
00226C  A98087     BCLR 0x87, #4
190:                   IEC1bits.T5IE = 0; // Enable Timer1 interrupt
00226E  A98097     BCLR 0x97, #4
191:                   TMR5 = 0;
002270  EF2118     CLR TMR5
192:                   PR5 = 40; // Timer1 period register = 19 x 25nS = 0.5uS
002272  200280     MOV #0x28, W0
002274  8808E0     MOV W0, PR5
193:                   /*--------------------------------------------------------*/
194:               
195:                   /*--------------------------------------------------------*/
196:                   /* Ports Init*/
197:                   PORTA = CLEAR;
002276  EF22C2     CLR PORTA
198:                   LATA = CLEAR;
002278  EF22C4     CLR LATA
199:               
200:                   TRISAbits.TRISA0 = INPUT; //interlock
00227A  A802C0     BSET TRISA, #0
201:                   TRISAbits.TRISA1 = INPUT; //flow switch
00227C  A822C0     BSET TRISA, #1
202:                   TRISAbits.TRISA2 = OUTPUT;
00227E  A942C0     BCLR TRISA, #2
203:                   CS_POT_FAN = HIGH;
002280  A842C4     BSET LATA, #2
204:                   TRISAbits.TRISA3 = OUTPUT;
002282  A962C0     BCLR TRISA, #3
205:                   pLDAC = LOW;
002284  A962C4     BCLR LATA, #3
206:                   TRISAbits.TRISA4 = OUTPUT;
002286  A982C0     BCLR TRISA, #4
207:                   tLDAC = LOW;
002288  A982C4     BCLR LATA, #4
208:                   TRISAbits.TRISA5 = OUTPUT;
00228A  A9A2C0     BCLR TRISA, #5
209:                   DIR = RX_MODE;
00228C  A9A2C4     BCLR LATA, #5
210:                   TRISAbits.TRISA7 = OUTPUT;
00228E  A9E2C0     BCLR TRISA, #7
211:                   DISCHARGE = HIGH;
002290  A8E2C4     BSET LATA, #7
212:                   TRISAbits.TRISA9 = OUTPUT;
002292  A922C1     BCLR 0x2C1, #1
213:                   LED6 = OFF;
002294  A922C5     BCLR 0x2C5, #1
214:                   TRISAbits.TRISA10 = OUTPUT;
002296  A942C1     BCLR 0x2C1, #2
215:                   LED7 = OFF;
002298  A942C5     BCLR 0x2C5, #2
216:                   //TRISAbits.TRISA14 = OUTPUT;
217:                   //LDAC = LOW;
218:                   TRISAbits.TRISA15 = OUTPUT;
00229A  A9E2C1     BCLR 0x2C1, #7
219:                   TEC_ENABLE = DISABLE;
00229C  A9E2C5     BCLR 0x2C5, #7
220:               
221:                   PORTB = CLEAR;
00229E  EF22CA     CLR PORTB
222:                   LATB = CLEAR;
0022A0  EF22CC     CLR LATB
223:               
224:                   //#ifndef __MPLAB_DEBUGGER_ICD3
225:                   TRISBbits.TRISB6 = OUTPUT;
0022A2  A9C2C8     BCLR TRISB, #6
226:                   TRISBbits.TRISB7 = OUTPUT;
0022A4  A9E2C8     BCLR TRISB, #7
227:                   //#endif
228:                   TRISBbits.TRISB12 = OUTPUT;
0022A6  A982C9     BCLR 0x2C9, #4
229:                   LED2 = OFF;
0022A8  A982CD     BCLR 0x2CD, #4
230:                   TRISBbits.TRISB13 = OUTPUT;
0022AA  A9A2C9     BCLR 0x2C9, #5
231:                   LED3 = OFF;
0022AC  A9A2CD     BCLR 0x2CD, #5
232:                   TRISBbits.TRISB14 = OUTPUT;
0022AE  A9C2C9     BCLR 0x2C9, #6
233:                   LED4 = OFF;
0022B0  A9C2CD     BCLR 0x2CD, #6
234:                   TRISBbits.TRISB15 = OUTPUT;
0022B2  A9E2C9     BCLR 0x2C9, #7
235:                   LED5 = OFF;
0022B4  A9E2CD     BCLR 0x2CD, #7
236:               
237:                   PORTC = CLEAR;
0022B6  EF22D2     CLR PORTC
238:                   LATC = CLEAR;
0022B8  EF22D4     CLR LATC
239:                   TRISCbits.TRISC3 = OUTPUT;
0022BA  A962D0     BCLR TRISC, #3
240:                   BT_AUTO_PAIRING = OFF;
0022BC  A962D4     BCLR LATC, #3
241:                   TRISCbits.TRISC13 = OUTPUT;
0022BE  A9A2D1     BCLR 0x2D1, #5
242:                   PUMP_SPI_EN = DISABLE;
0022C0  A962DD     BCLR 0x2DD, #3
243:                   TRISCbits.TRISC14 = INPUT;
0022C2  A8C2D1     BSET 0x2D1, #6
244:                   //CS_ADC_PUMP = HIGH;
245:               
246:                   PORTD = CLEAR;
0022C4  EF22DA     CLR PORTD
247:                   LATD = CLEAR;
0022C6  EF22DC     CLR LATD
248:               
249:                   TRISDbits.TRISD0 = OUTPUT;
0022C8  A902D8     BCLR TRISD, #0
250:                   pCS_DAC = HIGH;
0022CA  A802DC     BSET LATD, #0
251:                   TRISDbits.TRISD1 = INPUT; //TRIGGER2
0022CC  A822D8     BSET TRISD, #1
252:                   TRISDbits.TRISD2 = INPUT; //TRIGGER1
0022CE  A842D8     BSET TRISD, #2
253:                   TRISDbits.TRISD4 = OUTPUT;
0022D0  A982D8     BCLR TRISD, #4
254:                   LD_INHIBIT1 = HIGH;
0022D2  A882DC     BSET LATD, #4
255:                   TRISDbits.TRISD8 = OUTPUT;
0022D4  A902D9     BCLR 0x2D9, #0
256:                   CS_TEC_DAC = HIGH;
0022D6  A802DD     BSET 0x2DD, #0
257:                   TRISDbits.TRISD9 = OUTPUT;
0022D8  A922D9     BCLR 0x2D9, #1
258:                   CS_ADC_TEC = HIGH;
0022DA  A822DD     BSET 0x2DD, #1
259:                   TRISDbits.TRISD10 = OUTPUT;
0022DC  A942D9     BCLR 0x2D9, #2
260:                   TEC_SPI_EN = DISABLE;
0022DE  A942DD     BCLR 0x2DD, #2
261:                   TRISDbits.TRISD11 = OUTPUT;
0022E0  A962D9     BCLR 0x2D9, #3
262:                   PUMP_SPI_EN = SET;
0022E2  A862DD     BSET 0x2DD, #3
263:                   TRISDbits.TRISD13 = OUTPUT; //TODO HW DEBUG change after task done
0022E4  A9A2D9     BCLR 0x2D9, #5
264:                   CS_LD_DAC = HIGH;
0022E6  A8A2DD     BSET 0x2DD, #5
265:                   TRISDbits.TRISD14 = OUTPUT;
0022E8  A9C2D9     BCLR 0x2D9, #6
266:                   LED0 = OFF;
0022EA  A9C2DD     BCLR 0x2DD, #6
267:                   TRISDbits.TRISD15 = OUTPUT; //UART TX
0022EC  A9E2D9     BCLR 0x2D9, #7
268:                   LED1 = OFF;
0022EE  A9E2DD     BCLR 0x2DD, #7
269:               
270:                   PORTE = CLEAR;
0022F0  EF22E2     CLR PORTE
271:                   LATE = CLEAR;
0022F2  EF22E4     CLR LATE
272:               
273:                   TRISEbits.TRISE0 = OUTPUT;
0022F4  A902E0     BCLR TRISE, #0
274:                   //SAFE_IGBT = LOW;
275:                   TRISEbits.TRISE1 = OUTPUT;
0022F6  A922E0     BCLR TRISE, #1
276:                   PULSE_PWM = LOW;
0022F8  A922E4     BCLR LATE, #1
277:                   TRISEbits.TRISE3 = OUTPUT;
0022FA  A962E0     BCLR TRISE, #3
278:                   FAN_PWM = HIGH;
0022FC  A862E4     BSET LATE, #3
279:                   TRISEbits.TRISE4 = OUTPUT;
0022FE  A982E0     BCLR TRISE, #4
280:                   TRISEbits.TRISE5 = INPUT;
002300  A8A2E0     BSET TRISE, #5
281:                   TRISEbits.TRISE7 = INPUT;
002302  A8E2E0     BSET TRISE, #7
282:               
283:                   PORTF = CLEAR;
002304  EF22EA     CLR PORTF
284:                   LATF = CLEAR;
002306  EF22EC     CLR LATF
285:               
286:                   TRISFbits.TRISF1 = OUTPUT;
002308  A922E8     BCLR TRISF, #1
287:                   BT_MASTER_RESET = LOW;
00230A  A922EC     BCLR LATF, #1
288:                   TRISFbits.TRISF2 = INPUT;
00230C  A842E8     BSET TRISF, #2
289:                   TRISFbits.TRISF3 = OUTPUT; //UART TX
00230E  A962E8     BCLR TRISF, #3
290:               
291:                   PORTG = CLEAR;
002310  EF22F2     CLR PORTG
292:                   LATG = CLEAR;
002312  EF22F4     CLR LATG
293:               
294:                   TRISGbits.TRISG0 = OUTPUT;
002314  A902F0     BCLR TRISG, #0
295:                   BT_AUTO_MASTER = OFF;
002316  A902F4     BCLR LATG, #0
296:                   TRISGbits.TRISG1 = OUTPUT;
002318  A922F0     BCLR TRISG, #1
297:                   BT_BAUD_RATE = OFF;
00231A  A922F4     BCLR LATG, #1
298:                   TRISGbits.TRISG2 = OUTPUT;
00231C  A942F0     BCLR TRISG, #2
299:                   LD_SPI_ENABLE = HIGH;
00231E  A842F4     BSET LATG, #2
300:                   TRISGbits.TRISG3 = OUTPUT;
002320  A962F0     BCLR TRISG, #3
301:                   CS_DAC = HIGH;
002322  A862F4     BSET LATG, #3
302:                   TRISGbits.TRISG6 = INPUT;
002324  A8C2F0     BSET TRISG, #6
303:                   TRISGbits.TRISG8 = OUTPUT;
002326  A902F1     BCLR 0x2F1, #0
304:                   CS_ADC_LD = HIGH;
002328  A802F5     BSET 0x2F5, #0
305:                   TRISGbits.TRISG9 = OUTPUT;
00232A  A922F1     BCLR 0x2F1, #1
306:                   CHARGER_ENABLE = HIGH;
00232C  A822F5     BSET 0x2F5, #1
307:                   TRISGbits.TRISG15 = OUTPUT;
00232E  A9E2F1     BCLR 0x2F1, #7
308:                   SAFE_IGBT_EN = LOW;
002330  A9E2F5     BCLR 0x2F5, #7
309:                   /*--------------------------------------------------------*/
310:               
311:                   /*-------------------------------------------------------------------------------------------------------------------*/
312:                   /* UART Init*/
313:                   U1MODEbits.UARTEN = 0; // Bit15 TX, RX DISABLED, ENABLE at end of func
002332  A9E221     BCLR 0x221, #7
314:                   //U1MODEbits.notimplemented;	// Bit14
315:                   U1MODEbits.USIDL = 0; // Bit13 Continue in Idle
002334  A9A221     BCLR 0x221, #5
316:                   U1MODEbits.IREN = 0; // Bit12 No IR translation
002336  A98221     BCLR 0x221, #4
317:                   U1MODEbits.RTSMD = 1; // Bit11 Simplex Mode
002338  A86221     BSET 0x221, #3
318:                   //U1MODEbits.notimplemented;	// Bit10
319:                   U1MODEbits.UEN = 0; // Bits8,9 TX,RX enabled, CTS,RTS not
00233A  801100     MOV U1MODE, W0
00233C  A18000     BCLR W0, #8
00233E  A19000     BCLR W0, #9
002340  881100     MOV W0, U1MODE
320:                   U1MODEbits.WAKE = 0; // Bit7 No Wake up (since we don't sleep here)
002342  A9E220     BCLR U1MODE, #7
321:                   U1MODEbits.LPBACK = 0; // Bit6 No Loop Back
002344  A9C220     BCLR U1MODE, #6
322:                   U1MODEbits.ABAUD = 0; // Bit5 No Autobaud (would require sending '55')
002346  A9A220     BCLR U1MODE, #5
323:                   U1MODEbits.URXINV = 0; // Bit4 IdleState = 1  (for dsPIC)
002348  A98220     BCLR U1MODE, #4
324:                   U1MODEbits.BRGH = 0; // Bit3 16 clocks per bit period
00234A  A96220     BCLR U1MODE, #3
325:                   //U1MODEbits.PDSEL = 0; // Bits1,2 8bit, No Parity
326:                   U1MODEbits.PDSEL = 0; // 9 bits
00234C  801100     MOV U1MODE, W0
00234E  A11000     BCLR W0, #1
002350  A12000     BCLR W0, #2
002352  881100     MOV W0, U1MODE
327:                   U1MODEbits.STSEL = 0; // Bit0 One Stop Bit
002354  A90220     BCLR U1MODE, #0
328:               
329:                   U1BRG = (FCY / (16 * BAUDRATE));
002356  200150     MOV #0x15, W0
002358  881140     MOV W0, U1BRG
330:                   //U1BRG = (FCY / (16 * BAUDRATE)) - 1; //to match veriscite we need increase the value by one
331:                   // Load all values in for U1STA SFR
332:                   U1STAbits.UTXISEL1 = 0; //Bit15 Int when Char is transferred (1/2 config!)
00235A  A9E223     BCLR 0x223, #7
333:                   U1STAbits.UTXINV = 0; //Bit14 N/A, IRDA config
00235C  A9C223     BCLR 0x223, #6
334:                   U1STAbits.UTXISEL0 = 0; //Bit13 Other half of Bit15
00235E  A9A223     BCLR 0x223, #5
335:                   //U1STAbits.notimplemented = 0;	//Bit12
336:                   U1STAbits.UTXBRK = 0; //Bit11 Disabled
002360  A96223     BCLR 0x223, #3
337:                   U1STAbits.UTXEN = 0; //Bit10 TX pins controlled by periph
002362  A94223     BCLR 0x223, #2
338:                   U1STAbits.UTXBF = 0; //Bit9 *Read Only Bit*
002364  A92223     BCLR 0x223, #1
339:                   U1STAbits.TRMT = 0; //Bit8 *Read Only bit*
002366  A90223     BCLR 0x223, #0
340:                   U1STAbits.URXISEL = 0; //Bits6,7 Int. on character recieved
002368  801110     MOV U1STA, W0
00236A  A16000     BCLR W0, #6
00236C  A17000     BCLR W0, #7
00236E  881110     MOV W0, U1STA
341:                   //U1STAbits.ADDEN = 0; //Bit5 Address Detect Disabled
342:                   U1STAbits.ADDEN = 0; //Bit5 Address Detect Enabled
002370  A9A222     BCLR U1STA, #5
343:                   U1STAbits.RIDLE = 0; //Bit4 *Read Only Bit*
002372  A98222     BCLR U1STA, #4
344:                   U1STAbits.PERR = 0; //Bit3 *Read Only Bit*
002374  A96222     BCLR U1STA, #3
345:                   U1STAbits.FERR = 0; //Bit2 *Read Only Bit*
002376  A94222     BCLR U1STA, #2
346:                   U1STAbits.OERR = 0; //Bit1 *Read Only Bit*
002378  A92222     BCLR U1STA, #1
347:                   U1STAbits.URXDA = 0; //Bit0 *Read Only Bit*
00237A  A90222     BCLR U1STA, #0
348:                   IPC2bits.U1RXIP = 5; // High Range Interrupt Priority level, no urgent reason
00237C  800540     MOV IPC2, W0
00237E  A0C000     BSET W0, #12
002380  A1D000     BCLR W0, #13
002382  A0E000     BSET W0, #14
002384  880540     MOV W0, IPC2
349:                   IPC3bits.U1TXIP = 5; //interrup priority level 3(1 - lowest, 7 - highest)
002386  800550     MOV IPC3, W0
002388  A00000     BSET W0, #0
00238A  A11000     BCLR W0, #1
00238C  A02000     BSET W0, #2
00238E  880550     MOV W0, IPC3
350:                   //IPC16bits.U1EIP=6;
351:               
352:                   //IEC4bits.U1EIE=ENABLE;
353:                   IFS0bits.U1TXIF = 0; // Clear the Transmit Interrupt Flag
002390  A98085     BCLR 0x85, #4
354:                   IEC0bits.U1TXIE = 1; // Enable Transmit Interrupts
002392  A88095     BSET 0x95, #4
355:                   IFS0bits.U1RXIF = 0; // Clear the Recieve Interrupt Flag
002394  A96085     BCLR 0x85, #3
356:                   IEC0bits.U1RXIE = 1; // Enable Recieve Interrupts
002396  A86095     BSET 0x95, #3
357:               
358:                   U1MODEbits.UARTEN = 1; // And turn the peripheral on
002398  A8E221     BSET 0x221, #7
359:                   U1STAbits.UTXEN = ENABLE;
00239A  A84223     BSET 0x223, #2
360:               
361:                   /*-------------------------------------------------------*/
362:                   TXbuffer[0] = 0x55; //SYNC
00239C  209E00     MOV #0x9E0, W0
00239E  B3C551     MOV.B #0x55, W1
0023A0  784801     MOV.B W1, [W0]
363:                   TXbuffer[1] = 0x10; //to MASTER
0023A2  209E10     MOV #0x9E1, W0
0023A4  B3C101     MOV.B #0x10, W1
0023A6  784801     MOV.B W1, [W0]
364:                   TXbuffer[2] = HPDL_ADDRESS; //from IPL controler
0023A8  209E20     MOV #0x9E2, W0
0023AA  B3C901     MOV.B #0x90, W1
0023AC  784801     MOV.B W1, [W0]
365:                   TXbuffer[3] = 0; //RRQ not required
0023AE  209E30     MOV #0x9E3, W0
0023B0  EB4080     CLR.B W1
0023B2  784801     MOV.B W1, [W0]
366:                   TXbuffer[4] = 0xFF;
0023B4  209E40     MOV #0x9E4, W0
0023B6  EBC080     SETM.B W1
0023B8  784801     MOV.B W1, [W0]
367:                   TXbuffer[5] = TXbuffer[1] + TXbuffer[2] + TXbuffer[3] + TXbuffer[4];
0023BA  209E10     MOV #0x9E1, W0
0023BC  784090     MOV.B [W0], W1
0023BE  209E20     MOV #0x9E2, W0
0023C0  784010     MOV.B [W0], W0
0023C2  40C080     ADD.B W1, W0, W1
0023C4  209E30     MOV #0x9E3, W0
0023C6  784010     MOV.B [W0], W0
0023C8  40C080     ADD.B W1, W0, W1
0023CA  209E40     MOV #0x9E4, W0
0023CC  784010     MOV.B [W0], W0
0023CE  40C080     ADD.B W1, W0, W1
0023D0  209E50     MOV #0x9E5, W0
0023D2  784801     MOV.B W1, [W0]
368:                   /*-------------------------------------------------------*/
369:                   //
370:                   //    U2MODEbits.UARTEN = 0; // Bit15 TX, RX DISABLED, ENABLE at end of func
371:                   //    U2MODEbits.USIDL = 0; // Bit13 Continue in Idle
372:                   //    U2MODEbits.IREN = 0; // Bit12 No IR translation
373:                   //    U2MODEbits.RTSMD = 0; // Bit11 Simplex Mode
374:                   //    U2MODEbits.UEN = 0; // Bits8,9 TX,RX enabled, CTS,RTS not
375:                   //    U2MODEbits.WAKE = 0; // Bit7 No Wake up (since we don't sleep here)
376:                   //    U2MODEbits.LPBACK = 0; // Bit6 No Loop Back
377:                   //    U2MODEbits.ABAUD = 0; // Bit5 No Autobaud (would require sending '55')
378:                   //    U2MODEbits.URXINV = 0; // Bit4 IdleState = 1  (for dsPIC)
379:                   //    U2MODEbits.BRGH = 0; // Bit3 16 clocks per bit period
380:                   //    U2MODEbits.PDSEL = 0; // 9 bits
381:                   //    U2MODEbits.STSEL = 0; // Bit0 One Stop Bit
382:                   //    U2BRG = (FCY / (16 * BAUDRATE)) - 1;
383:                   //    // Load all values in for U1STA SFR
384:                   //    U2STAbits.UTXISEL1 = 0; //Bit15 Int when Char is transferred (1/2 config!)
385:                   //    U2STAbits.UTXINV = 0; //Bit14 N/A, IRDA config
386:                   //    U2STAbits.UTXISEL0 = 0; //Bit13 Other half of Bit15
387:                   //    //U1STAbits.notimplemented = 0;	//Bit12
388:                   //    U2STAbits.UTXBRK = 0; //Bit11 Disabled
389:                   //    U2STAbits.UTXEN = 0; //Bit10 TX pins controlled by periph
390:                   //    U2STAbits.UTXBF = 0; //Bit9 *Read Only Bit*
391:                   //    U2STAbits.TRMT = 0; //Bit8 *Read Only bit*
392:                   //    U2STAbits.URXISEL = 0; //Bits6,7 Int. on character recieved
393:                   //    //U1STAbits.ADDEN = 0; //Bit5 Address Detect Disabled
394:                   //    U2STAbits.ADDEN = 1; //Bit5 Address Detect Enabled
395:                   //    U2STAbits.RIDLE = 0; //Bit4 *Read Only Bit*
396:                   //    U2STAbits.PERR = 0; //Bit3 *Read Only Bit*
397:                   //    U2STAbits.FERR = 0; //Bit2 *Read Only Bit*
398:                   //    U2STAbits.OERR = 0; //Bit1 *Read Only Bit*
399:                   //    U2STAbits.URXDA = 0; //Bit0 *Read Only Bit*
400:                   //    IPC7bits.U2RXIP = 2; // High Range Interrupt Priority level, no urgent reason
401:                   //    IPC7bits.U2TXIP = 2; //interrup priority level 3(1 - lowest, 7 - highest)
402:                   //    //IPC16bits.U1EIP=6;
403:                   //
404:                   //    //IEC4bits.U1EIE=ENABLE;
405:                   //    IFS1bits.U2TXIF = 0; // Clear the Transmit Interrupt Flag
406:                   //    IEC1bits.U2TXIE = 1; // Enable Transmit Interrupts
407:                   //    IFS1bits.U2RXIF = 0; // Clear the Recieve Interrupt Flag
408:                   //    IEC1bits.U2RXIE = 1; // Enable Recieve Interrupts
409:                   //
410:                   //    U2MODEbits.UARTEN = 1; // And turn the peripheral on
411:                   //    U2STAbits.UTXEN = ENABLE;
412:                   /*-------------------------------------------------------------------------------------------------------------------*/
413:               
414:                   /*-----------------------------------------------------------------------*/
415:                   /* DMA SPI Init*/
416:                   DMA0CON = 0x2001;
0023D4  220010     MOV #0x2001, W0
0023D6  881C00     MOV W0, DMA0CON
417:                   DMA0CNT = 7;
0023D8  200070     MOV #0x7, W0
0023DA  881C50     MOV W0, DMA0CNT
418:                   DMA0REQ = 0x00A;
0023DC  2000A0     MOV #0xA, W0
0023DE  881C10     MOV W0, DMA0REQ
419:               
420:                   DMA0PAD = (volatile unsigned int) &SPI1BUF;
0023E0  202480     MOV #0x248, W0
0023E2  881C40     MOV W0, DMA0PAD
421:                   DMA0STA = __builtin_dmaoffset(Spi1TxBuff);
0023E4  203E00     MOV #0x3E0, W0
0023E6  881C20     MOV W0, DMA0STA
422:               
423:                   IPC1bits.DMA0IP = 4;
0023E8  800530     MOV IPC1, W0
0023EA  A10000     BCLR W0, #0
0023EC  A11000     BCLR W0, #1
0023EE  A02000     BSET W0, #2
0023F0  880530     MOV W0, IPC1
424:                   IFS0bits.DMA0IF = 0; // Clear DMA interrupt
0023F2  A98084     BCLR IFS0, #4
425:                   IEC0bits.DMA0IE = 1; // Enable DMA interrupt
0023F4  A88094     BSET IEC0, #4
426:                   DMA0CONbits.CHEN = 1; // Enable DMA Channel
0023F6  A8E381     BSET 0x381, #7
427:                   /*##########################################*/
428:                   DMA1CON = 0x0001;
0023F8  200010     MOV #0x1, W0
0023FA  881C60     MOV W0, DMA1CON
429:                   DMA1CNT = 7;
0023FC  200070     MOV #0x7, W0
0023FE  881CB0     MOV W0, DMA1CNT
430:                   DMA1REQ = 0x00A;
002400  2000A0     MOV #0xA, W0
002402  881C70     MOV W0, DMA1REQ
431:               
432:                   DMA1PAD = (volatile unsigned int) &SPI1BUF;
002404  202480     MOV #0x248, W0
002406  881CA0     MOV W0, DMA1PAD
433:                   DMA1STA = __builtin_dmaoffset(Spi1RxBuff);
002408  203F00     MOV #0x3F0, W0
00240A  881C80     MOV W0, DMA1STA
434:               
435:                   IPC3bits.DMA1IP = 4;
00240C  800550     MOV IPC3, W0
00240E  A18000     BCLR W0, #8
002410  A19000     BCLR W0, #9
002412  A0A000     BSET W0, #10
002414  880550     MOV W0, IPC3
436:                   IFS0bits.DMA1IF = 0; // Clear DMA interrupt
002416  A9C085     BCLR 0x85, #6
437:                   IEC0bits.DMA1IE = 1; // Enable DMA interrupt
002418  A8C095     BSET 0x95, #6
438:               
439:                   DMA1CONbits.CHEN = 1; // Enable DMA Channel
00241A  A8E38D     BSET 0x38D, #7
440:                   /*-----------------------------------------------------------------------*/
441:               
442:                   /*-----------------------------------------------------------------------*/
443:                   /* SPI Init*/
444:                   //IFS0bits.SPI1IF = 0; // Clear the Interrupt Flag
445:                   IEC0bits.SPI1IE = 0; // Disable the Interrupt
00241C  A94095     BCLR 0x95, #2
446:                   // SPI1CON1 Register Settings
447:                   SPI1CON1bits.DISSCK = 0; // Internal Serial Clock is Enabled
00241E  A98243     BCLR 0x243, #4
448:                   SPI1CON1bits.DISSDO = 0; // SDOx pin is controlled by the module
002420  A96243     BCLR 0x243, #3
449:                   SPI1CON1bits.MODE16 = 1; // Communication is word-wide (16 bits)
002422  A84243     BSET 0x243, #2
450:                   SPI1CON1bits.SMP = 0; // Input data is sampled at the middle of data output time
002424  A92243     BCLR 0x243, #1
451:                   SPI1CON1bits.CKE = 0; // Serial output data changes on transition from Idle clock state to active clock state
002426  A90243     BCLR 0x243, #0
452:                   SPI1CON1bits.SSEN = 0; //SS pin used by module
002428  A9E242     BCLR SPI1CON1, #7
453:                   SPI1CON1bits.CKP = 1; // Idle state for clock is a low level; active state is a high level
00242A  A8C242     BSET SPI1CON1, #6
454:                   SPI1CON1bits.MSTEN = 1; // Master mode Enabled
00242C  A8A242     BSET SPI1CON1, #5
455:                   SPI1CON1bits.SPRE = 3; //secondary prescaler 1:1
00242E  801210     MOV SPI1CON1, W0
002430  A02000     BSET W0, #2
002432  A03000     BSET W0, #3
002434  A14000     BCLR W0, #4
002436  881210     MOV W0, SPI1CON1
456:                   SPI1CON1bits.PPRE = 2; //primary prescaler 4:1
002438  801210     MOV SPI1CON1, W0
00243A  A10000     BCLR W0, #0
00243C  A01000     BSET W0, #1
00243E  881210     MOV W0, SPI1CON1
457:                   // Interrupt Controller Settings
458:                   SPI1STATbits.SPIEN = 1; // Enable SPI module
002440  A8E241     BSET 0x241, #7
459:                   IPC2bits.SPI1IP = 6;
002442  800540     MOV IPC2, W0
002444  A18000     BCLR W0, #8
002446  A09000     BSET W0, #9
002448  A0A000     BSET W0, #10
00244A  880540     MOV W0, IPC2
460:                   IFS0bits.SPI1IF = 0; // Clear the Interrupt Flag
00244C  A94085     BCLR 0x85, #2
461:                   IEC0bits.SPI1IE = 0; // Disable the Interrupt
00244E  A94095     BCLR 0x95, #2
462:                   /*-----------------------------------------------------------------------*/
463:               
464:                   /*-----------------------------------------------------------------------*/
465:                   /* PWM Init*/
466:                   PTCON2bits.PCLKDIV = 6;
002450  802010     MOV PTCON2, W0
002452  A10000     BCLR W0, #0
002454  A01000     BSET W0, #1
002456  A02000     BSET W0, #2
002458  882010     MOV W0, PTCON2
467:                   PWMCON1bits.ITB = 1;
00245A  A82421     BSET 0x421, #1
468:                   PWMCON1bits.DTC = 2;
00245C  802100     MOV PWMCON1, W0
00245E  A16000     BCLR W0, #6
002460  A07000     BSET W0, #7
002462  882100     MOV W0, PWMCON1
469:                   PWMCON1bits.MDCS = 0;
002464  A90421     BCLR 0x421, #0
470:                   PHASE1 = 100;
002466  200640     MOV #0x64, W0
002468  882140     MOV W0, PHASE1
471:                   SPHASE1 = 100;
00246A  200640     MOV #0x64, W0
00246C  882180     MOV W0, SPHASE1
472:                   IOCON1bits.PMOD = 3; //independed
00246E  802110     MOV IOCON1, W0
002470  A0A000     BSET W0, #10
002472  A0B000     BSET W0, #11
002474  882110     MOV W0, IOCON1
473:                   IOCON1bits.PENH = 0;
002476  A9E423     BCLR 0x423, #7
474:                   IOCON1bits.PENL = 0;
002478  A9C423     BCLR 0x423, #6
475:                   PDC1 = 50;
00247A  200320     MOV #0x32, W0
00247C  882130     MOV W0, PDC1
476:                   SDC1 = 50;
00247E  200320     MOV #0x32, W0
002480  882170     MOV W0, SDC1
477:               
478:                   PWMCON2bits.ITB = 1;
002482  A82441     BSET 0x441, #1
479:                   PWMCON2bits.DTC = 2;
002484  802200     MOV PWMCON2, W0
002486  A16000     BCLR W0, #6
002488  A07000     BSET W0, #7
00248A  882200     MOV W0, PWMCON2
480:                   PHASE2 = FAN_PWM_FREQ;
00248C  279180     MOV #0x7918, W0
00248E  882240     MOV W0, PHASE2
481:                   IOCON2bits.PMOD = 3; //independed
002490  802210     MOV IOCON2, W0
002492  A0A000     BSET W0, #10
002494  A0B000     BSET W0, #11
002496  882210     MOV W0, IOCON2
482:                   IOCON2bits.PENH = 0;
002498  A9E443     BCLR 0x443, #7
483:                   IOCON2bits.POLH = 1;
00249A  A8A443     BSET 0x443, #5
484:                   PDC2 = FAN_PWM_FREQ * 0.8; //100% duty cicle
00249C  260E00     MOV #0x60E0, W0
00249E  882230     MOV W0, PDC2
485:                   IOCON2bits.PENH = 1; //fan pwm
0024A0  A8E443     BSET 0x443, #7
486:                   PTCONbits.PTEN = 1;
0024A2  A8E401     BSET 0x401, #7
487:               
488:                   /*-------------------------------------------------------------------------------------------------------------------*/
489:               
490:                   /*-------------------------------------------------------*/
491:                   /* A/D Init*/
492:                   ADCONbits.FORM = 0; // Output in Integer Format
0024A4  A90301     BCLR 0x301, #0
493:                   ADCONbits.EIE = 1; // Enable Early Interrupt
0024A6  A8E300     BSET ADCON, #7
494:                   ADCONbits.ORDER = 0; // Normal Order of Conversion
0024A8  A9C300     BCLR ADCON, #6
495:                   ADCONbits.SEQSAMP = 0; // Simultaneous Sampling
0024AA  A9A300     BCLR ADCON, #5
496:                   ADCONbits.ASYNCSAMP = 1; // Asynchronous Sampling
0024AC  A88300     BSET ADCON, #4
497:                   ADCONbits.SLOWCLK = 0; // High Frequency Clock Input
0024AE  A98301     BCLR 0x301, #4
498:                   ADCONbits.ADCS = 5; // Clock Divider Selection
0024B0  801800     MOV ADCON, W0
0024B2  A00000     BSET W0, #0
0024B4  A11000     BCLR W0, #1
0024B6  A02000     BSET W0, #2
0024B8  881800     MOV W0, ADCON
499:                   ADCPC0bits.TRGSRC0 = 0b00001; // individual Trigger Selected
0024BA  801851     MOV ADCPC0, W1
0024BC  2FFE00     MOV #0xFFE0, W0
0024BE  608000     AND W1, W0, W0
0024C0  A00000     BSET W0, #0
0024C2  881850     MOV W0, ADCPC0
500:                   ADCPC0bits.TRGSRC1 = 0b00001; // individual Primary Trigger Selected
0024C4  801851     MOV ADCPC0, W1
0024C6  2E0FF0     MOV #0xE0FF, W0
0024C8  608080     AND W1, W0, W1
0024CA  201000     MOV #0x100, W0
0024CC  700001     IOR W0, W1, W0
0024CE  881850     MOV W0, ADCPC0
501:                   //    ADCPC1bits.TRGSRC2 = 0b01100; // Time Primary Trigger Selected
502:                   //    ADCPC2bits.TRGSRC4 = 0b01100; // Time Primary Trigger Selected
503:                   //    ADCPC4bits.TRGSRC8 = 0b01100; // Time Primary Trigger Selected
504:                   //    ADCPC4bits.TRGSRC9 = 0b01100; // Time Primary Trigger Selected
505:                   ADPCFGbits.PCFG0 = 0; // AN0 is configured as analog input Temperature #1
0024D0  A90302     BCLR ADPCFG, #0
506:                   ADPCFGbits.PCFG1 = 0; // AN1 is configured as analog input Temperature #2
0024D2  A92302     BCLR ADPCFG, #1
507:               
508:                   ADPCFGbits.PCFG2 = 0; // AN2 is configured as analog input Diode Current #1
0024D4  A94302     BCLR ADPCFG, #2
509:                   ADPCFGbits.PCFG3 = 0; // AN3 is configured as analog input Diode Current #2
0024D6  A96302     BCLR ADPCFG, #3
510:                   //    ADPCFGbits.PCFG4 = 0; // AN4 is configured as analog input
511:                   //    ADPCFGbits.PCFG5 = 0; // AN5 is configured as analog input
512:                   //    ADPCFGbits.PCFG8 = 0; // AN8 is configured as analog input
513:                   //    ADPCFGbits.PCFG9 = 0; // A93 is configured as analog input
514:                   IPC27bits.ADCP0IP = 0x04; // Set ADC Pair 0 Interrupt Priority (Level 4)
0024D8  8006D0     MOV IPC27, W0
0024DA  A18000     BCLR W0, #8
0024DC  A19000     BCLR W0, #9
0024DE  A0A000     BSET W0, #10
0024E0  8806D0     MOV W0, IPC27
515:                   IFS6bits.ADCP0IF = 0; // Clear ADC Pair 0 Interrupt Flag
0024E2  A9C091     BCLR 0x91, #6
516:                   IEC6bits.ADCP0IE = 1; // Enable ADC Pair 0 Interrupt
0024E4  A8C0A1     BSET 0xA1, #6
517:               
518:                   IPC27bits.ADCP1IP = 0x04; // Set ADC Pair 1 Interrupt Priority (Level 4
0024E6  8006D0     MOV IPC27, W0
0024E8  A1C000     BCLR W0, #12
0024EA  A1D000     BCLR W0, #13
0024EC  A0E000     BSET W0, #14
0024EE  8806D0     MOV W0, IPC27
519:                   IFS6bits.ADCP1IF = 0; // Clear ADC Pair 1 Interrupt Flag
0024F0  A9E091     BCLR 0x91, #7
520:                   IEC6bits.ADCP1IE = 1; // Enable ADC Pair 1 Interrupt
0024F2  A8E0A1     BSET 0xA1, #7
521:                   //    IPC28bits.ADCP2IP = 0x04; // Set ADC Pair 2 Interrupt Priority (Level 4)
522:                   //    IFS7bits.ADCP2IF = 0; // Clear ADC Pair 3 Interrupt Flag
523:                   //    IEC7bits.ADCP2IE = 1; // Enable ADC Pair 4 Interrupt
524:                   //    IPC28bits.ADCP4IP = 0x04; // Set ADC Pair 2 Interrupt Priority (Level 4)
525:                   //    IFS7bits.ADCP4IF = 0; // Clear ADC Pair 3 Interrupt Flag
526:                   //    IEC7bits.ADCP4IE = 1; // Enable ADC Pair 4 Interrupt
527:                   ADCONbits.ADON = 1; // Enable ADC Module
0024F4  A8E301     BSET 0x301, #7
528:                   /*-------------------------------------------------------*/
529:               
530:               }
0024F6  FA8000     ULNK
0024F8  060000     RETURN
531:               
532:               u16 SPIReadWriteWord(u16 WordVar) {
0024FA  FA0004     LNK #0x4
0024FC  980710     MOV W0, [W14+2]
533:                   u16 DemoResult;
534:               
535:                   DemoResult = SPI1BUF; // dummy read of the SPI1BUF register to clear the SPIRBF flag
0024FE  801241     MOV SPI1BUF, W1
002500  780F01     MOV W1, [W14]
536:                   SPI1BUF = WordVar; // write the data out to the SPI peripheral
002502  90009E     MOV [W14+2], W1
002504  881241     MOV W1, SPI1BUF
537:                   while (!SPI1STATbits.SPIRBF); // wait for the data to be sent out
002506  000000     NOP
002508  801200     MOV SPI1STAT, W0
00250A  600061     AND W0, #0x1, W0
00250C  E00000     CP0 W0
00250E  32FFFC     BRA Z, 0x2508
538:                   DemoResult = SPI1BUF;
002510  801241     MOV SPI1BUF, W1
002512  780F01     MOV W1, [W14]
539:                   return DemoResult;
002514  78001E     MOV [W14], W0
540:               }
002516  FA8000     ULNK
002518  060000     RETURN
541:               
542:               
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/traps.c
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                     #include <xc.h>
8:                 #elif defined(__C30__)
9:                     #if defined(__dsPIC33E__)
10:                    	#include <p33Exxxx.h>
11:                    #elif defined(__dsPIC33F__)
12:                    	#include <p33Fxxxx.h>
13:                    #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                
19:                #include "user.h"
20:                /******************************************************************************/
21:                /* Trap Function Prototypes                                                   */
22:                /******************************************************************************/
23:                
24:                /* <Other function prototypes for debugging trap code may be inserted here>   */
25:                
26:                /* Use if INTCON2 ALTIVT=1 */
27:                void __attribute__((interrupt,no_auto_psv)) _OscillatorFail(void);
28:                void __attribute__((interrupt,no_auto_psv)) _AddressError(void);
29:                void __attribute__((interrupt,no_auto_psv)) _StackError(void);
30:                void __attribute__((interrupt,no_auto_psv)) _MathError(void);
31:                
32:                #if defined(__HAS_DMA__)
33:                
34:                void __attribute__((interrupt,no_auto_psv)) _DMACError(void);
35:                
36:                #endif
37:                
38:                #if defined(__dsPIC33F__)
39:                
40:                /* Use if INTCON2 ALTIVT=0 */
41:                void __attribute__((interrupt,no_auto_psv)) _AltOscillatorFail(void);
42:                void __attribute__((interrupt,no_auto_psv)) _AltAddressError(void);
43:                void __attribute__((interrupt,no_auto_psv)) _AltStackError(void);
44:                void __attribute__((interrupt,no_auto_psv)) _AltMathError(void);
45:                
46:                    #if defined(__HAS_DMA__)
47:                
48:                    void __attribute__((interrupt,no_auto_psv)) _AltDMACError(void);
49:                
50:                    #endif
51:                
52:                #endif
53:                
54:                /* Default interrupt handler */
55:                void __attribute__((interrupt,no_auto_psv)) _DefaultInterrupt(void);
56:                
57:                #if defined(__dsPIC33E__)
58:                
59:                /* These are additional traps in the 33E family.  Refer to the PIC33E
60:                migration guide.  There are no Alternate Vectors in the 33E family. */
61:                void __attribute__((interrupt,no_auto_psv)) _HardTrapError(void);
62:                void __attribute__((interrupt,no_auto_psv)) _SoftTrapError(void);
63:                
64:                #endif
65:                
66:                /******************************************************************************/
67:                /* Trap Handling                                                              */
68:                /*                                                                            */
69:                /* These trap routines simply ensure that the device continuously loops       */
70:                /* within each routine.  Users who actually experience one of these traps     */
71:                /* can add code to handle the error.  Some basic examples for trap code,      */
72:                /* including assembly routines that process trap sources, are available at    */
73:                /* www.microchip.com/codeexamples                                             */
74:                /******************************************************************************/
75:                
76:                /* Primary (non-alternate) address error trap function declarations */
77:                void __attribute__((interrupt,no_auto_psv)) _OscillatorFail(void)
78:                {
000CAA  BE9F80     MOV.D W0, [W15++]
000CAC  781F82     MOV W2, [W15++]
000CAE  FA0000     LNK #0x0
79:                        INTCON1bits.OSCFAIL = 0;        /* Clear the trap flag */
000CB0  A92080     BCLR INTCON1, #1
80:                        while(1)LED7 ^= 1;
000CB2  801620     MOV LATA, W0
000CB4  DE004A     LSR W0, #10, W0
000CB6  604061     AND.B W0, #0x1, W0
000CB8  A20400     BTG.B W0, #0
000CBA  604061     AND.B W0, #0x1, W0
000CBC  FB8000     ZE W0, W0
000CBE  600061     AND W0, #0x1, W0
000CC0  DD004A     SL W0, #10, W0
000CC2  801622     MOV LATA, W2
000CC4  2FBFF1     MOV #0xFBFF, W1
000CC6  610081     AND W2, W1, W1
000CC8  700001     IOR W0, W1, W0
000CCA  881620     MOV W0, LATA
000CCC  37FFF2     BRA 0xCB2
81:                }
82:                
83:                void __attribute__((interrupt,no_auto_psv)) _AddressError(void)
84:                {
000CCE  BE9F80     MOV.D W0, [W15++]
000CD0  781F82     MOV W2, [W15++]
000CD2  FA0000     LNK #0x0
85:                        INTCON1bits.ADDRERR = 0;        /* Clear the trap flag */
000CD4  A96080     BCLR INTCON1, #3
86:                        while(1)LED7 ^= 1;
000CD6  801620     MOV LATA, W0
000CD8  DE004A     LSR W0, #10, W0
000CDA  604061     AND.B W0, #0x1, W0
000CDC  A20400     BTG.B W0, #0
000CDE  604061     AND.B W0, #0x1, W0
000CE0  FB8000     ZE W0, W0
000CE2  600061     AND W0, #0x1, W0
000CE4  DD004A     SL W0, #10, W0
000CE6  801622     MOV LATA, W2
000CE8  2FBFF1     MOV #0xFBFF, W1
000CEA  610081     AND W2, W1, W1
000CEC  700001     IOR W0, W1, W0
000CEE  881620     MOV W0, LATA
000CF0  37FFF2     BRA 0xCD6
87:                }
88:                void __attribute__((interrupt,no_auto_psv)) _StackError(void)
89:                {
000CF2  BE9F80     MOV.D W0, [W15++]
000CF4  781F82     MOV W2, [W15++]
000CF6  FA0000     LNK #0x0
90:                        INTCON1bits.STKERR = 0;         /* Clear the trap flag */
000CF8  A94080     BCLR INTCON1, #2
91:                        while(1)LED7 ^= 1;
000CFA  801620     MOV LATA, W0
000CFC  DE004A     LSR W0, #10, W0
000CFE  604061     AND.B W0, #0x1, W0
000D00  A20400     BTG.B W0, #0
000D02  604061     AND.B W0, #0x1, W0
000D04  FB8000     ZE W0, W0
000D06  600061     AND W0, #0x1, W0
000D08  DD004A     SL W0, #10, W0
000D0A  801622     MOV LATA, W2
000D0C  2FBFF1     MOV #0xFBFF, W1
000D0E  610081     AND W2, W1, W1
000D10  700001     IOR W0, W1, W0
000D12  881620     MOV W0, LATA
000D14  37FFF2     BRA 0xCFA
92:                }
93:                
94:                void __attribute__((interrupt,no_auto_psv)) _MathError(void)
95:                {
000D16  BE9F80     MOV.D W0, [W15++]
000D18  781F82     MOV W2, [W15++]
000D1A  FA0000     LNK #0x0
96:                        INTCON1bits.MATHERR = 0;        /* Clear the trap flag */
000D1C  A98080     BCLR INTCON1, #4
97:                        while(1)LED7 ^= 1;
000D1E  801620     MOV LATA, W0
000D20  DE004A     LSR W0, #10, W0
000D22  604061     AND.B W0, #0x1, W0
000D24  A20400     BTG.B W0, #0
000D26  604061     AND.B W0, #0x1, W0
000D28  FB8000     ZE W0, W0
000D2A  600061     AND W0, #0x1, W0
000D2C  DD004A     SL W0, #10, W0
000D2E  801622     MOV LATA, W2
000D30  2FBFF1     MOV #0xFBFF, W1
000D32  610081     AND W2, W1, W1
000D34  700001     IOR W0, W1, W0
000D36  881620     MOV W0, LATA
000D38  37FFF2     BRA 0xD1E
98:                }
99:                
100:               #if defined(__HAS_DMA__)
101:               
102:               void __attribute__((interrupt,no_auto_psv)) _DMACError(void)
103:               {
000D3A  BE9F80     MOV.D W0, [W15++]
000D3C  781F82     MOV W2, [W15++]
000D3E  FA0000     LNK #0x0
104:                       INTCON1bits.DMACERR = 0;        /* Clear the trap flag */
000D40  A9A080     BCLR INTCON1, #5
105:                       while(1)LED7 ^= 1;
000D42  801620     MOV LATA, W0
000D44  DE004A     LSR W0, #10, W0
000D46  604061     AND.B W0, #0x1, W0
000D48  A20400     BTG.B W0, #0
000D4A  604061     AND.B W0, #0x1, W0
000D4C  FB8000     ZE W0, W0
000D4E  600061     AND W0, #0x1, W0
000D50  DD004A     SL W0, #10, W0
000D52  801622     MOV LATA, W2
000D54  2FBFF1     MOV #0xFBFF, W1
000D56  610081     AND W2, W1, W1
000D58  700001     IOR W0, W1, W0
000D5A  881620     MOV W0, LATA
000D5C  37FFF2     BRA 0xD42
106:               }
107:               
108:               #endif
109:               
110:               #if defined(__dsPIC33F__)
111:               
112:               /* Alternate address error trap function declarations */
113:               void __attribute__((interrupt,no_auto_psv)) _AltOscillatorFail(void)
114:               {
000D5E  BE9F80     MOV.D W0, [W15++]
000D60  781F82     MOV W2, [W15++]
000D62  FA0000     LNK #0x0
115:                       INTCON1bits.OSCFAIL = 0;        /* Clear the trap flag */
000D64  A92080     BCLR INTCON1, #1
116:                       while(1)LED7 ^= 1;
000D66  801620     MOV LATA, W0
000D68  DE004A     LSR W0, #10, W0
000D6A  604061     AND.B W0, #0x1, W0
000D6C  A20400     BTG.B W0, #0
000D6E  604061     AND.B W0, #0x1, W0
000D70  FB8000     ZE W0, W0
000D72  600061     AND W0, #0x1, W0
000D74  DD004A     SL W0, #10, W0
000D76  801622     MOV LATA, W2
000D78  2FBFF1     MOV #0xFBFF, W1
000D7A  610081     AND W2, W1, W1
000D7C  700001     IOR W0, W1, W0
000D7E  881620     MOV W0, LATA
000D80  37FFF2     BRA 0xD66
117:               }
118:               
119:               void __attribute__((interrupt,no_auto_psv)) _AltAddressError(void)
120:               {
000D82  BE9F80     MOV.D W0, [W15++]
000D84  781F82     MOV W2, [W15++]
000D86  FA0000     LNK #0x0
121:                       INTCON1bits.ADDRERR = 0;        /* Clear the trap flag */
000D88  A96080     BCLR INTCON1, #3
122:                       while(1)LED7 ^= 1;
000D8A  801620     MOV LATA, W0
000D8C  DE004A     LSR W0, #10, W0
000D8E  604061     AND.B W0, #0x1, W0
000D90  A20400     BTG.B W0, #0
000D92  604061     AND.B W0, #0x1, W0
000D94  FB8000     ZE W0, W0
000D96  600061     AND W0, #0x1, W0
000D98  DD004A     SL W0, #10, W0
000D9A  801622     MOV LATA, W2
000D9C  2FBFF1     MOV #0xFBFF, W1
000D9E  610081     AND W2, W1, W1
000DA0  700001     IOR W0, W1, W0
000DA2  881620     MOV W0, LATA
000DA4  37FFF2     BRA 0xD8A
123:               }
124:               
125:               void __attribute__((interrupt,no_auto_psv)) _AltStackError(void)
126:               {
000DA6  BE9F80     MOV.D W0, [W15++]
000DA8  781F82     MOV W2, [W15++]
000DAA  FA0000     LNK #0x0
127:                       INTCON1bits.STKERR = 0;         /* Clear the trap flag */
000DAC  A94080     BCLR INTCON1, #2
128:                       while(1)LED7 ^= 1;
000DAE  801620     MOV LATA, W0
000DB0  DE004A     LSR W0, #10, W0
000DB2  604061     AND.B W0, #0x1, W0
000DB4  A20400     BTG.B W0, #0
000DB6  604061     AND.B W0, #0x1, W0
000DB8  FB8000     ZE W0, W0
000DBA  600061     AND W0, #0x1, W0
000DBC  DD004A     SL W0, #10, W0
000DBE  801622     MOV LATA, W2
000DC0  2FBFF1     MOV #0xFBFF, W1
000DC2  610081     AND W2, W1, W1
000DC4  700001     IOR W0, W1, W0
000DC6  881620     MOV W0, LATA
000DC8  37FFF2     BRA 0xDAE
129:               }
130:               
131:               void __attribute__((interrupt,no_auto_psv)) _AltMathError(void)
132:               {
000DCA  BE9F80     MOV.D W0, [W15++]
000DCC  781F82     MOV W2, [W15++]
000DCE  FA0000     LNK #0x0
133:                       INTCON1bits.MATHERR = 0;        /* Clear the trap flag */
000DD0  A98080     BCLR INTCON1, #4
134:                       while(1)LED7 ^= 1;
000DD2  801620     MOV LATA, W0
000DD4  DE004A     LSR W0, #10, W0
000DD6  604061     AND.B W0, #0x1, W0
000DD8  A20400     BTG.B W0, #0
000DDA  604061     AND.B W0, #0x1, W0
000DDC  FB8000     ZE W0, W0
000DDE  600061     AND W0, #0x1, W0
000DE0  DD004A     SL W0, #10, W0
000DE2  801622     MOV LATA, W2
000DE4  2FBFF1     MOV #0xFBFF, W1
000DE6  610081     AND W2, W1, W1
000DE8  700001     IOR W0, W1, W0
000DEA  881620     MOV W0, LATA
000DEC  37FFF2     BRA 0xDD2
135:               }
136:               
137:                   #if defined(__HAS_DMA__)
138:               
139:                   void __attribute__((interrupt,no_auto_psv)) _AltDMACError(void)
140:                   {
000DEE  BE9F80     MOV.D W0, [W15++]
000DF0  781F82     MOV W2, [W15++]
000DF2  FA0000     LNK #0x0
141:                        INTCON1bits.DMACERR = 0;        /* Clear the trap flag */
000DF4  A9A080     BCLR INTCON1, #5
142:                        while(1)LED7 ^= 1;
000DF6  801620     MOV LATA, W0
000DF8  DE004A     LSR W0, #10, W0
000DFA  604061     AND.B W0, #0x1, W0
000DFC  A20400     BTG.B W0, #0
000DFE  604061     AND.B W0, #0x1, W0
000E00  FB8000     ZE W0, W0
000E02  600061     AND W0, #0x1, W0
000E04  DD004A     SL W0, #10, W0
000E06  801622     MOV LATA, W2
000E08  2FBFF1     MOV #0xFBFF, W1
000E0A  610081     AND W2, W1, W1
000E0C  700001     IOR W0, W1, W0
000E0E  881620     MOV W0, LATA
000E10  37FFF2     BRA 0xDF6
143:                   }
144:               
145:                   #endif
146:               
147:               #endif
148:               
149:               /******************************************************************************/
150:               /* Default Interrupt Handler                                                  */
151:               /*                                                                            */
152:               /* This executes when an interrupt occurs for an interrupt source with an     */
153:               /* improperly defined or undefined interrupt handling routine.                */
154:               /******************************************************************************/
155:               void __attribute__((interrupt,no_auto_psv)) _DefaultInterrupt(void)
156:               {
000E12  BE9F80     MOV.D W0, [W15++]
000E14  781F82     MOV W2, [W15++]
000E16  FA0000     LNK #0x0
157:                       while(1)LED1 ^= 1;
000E18  8016E0     MOV LATD, W0
000E1A  DE004F     LSR W0, #15, W0
000E1C  784000     MOV.B W0, W0
000E1E  A20400     BTG.B W0, #0
000E20  604061     AND.B W0, #0x1, W0
000E22  FB8000     ZE W0, W0
000E24  DD004F     SL W0, #15, W0
000E26  8016E2     MOV LATD, W2
000E28  27FFF1     MOV #0x7FFF, W1
000E2A  610081     AND W2, W1, W1
000E2C  700001     IOR W0, W1, W0
000E2E  8816E0     MOV W0, LATD
000E30  37FFF3     BRA 0xE18
158:               }
159:               
160:               #if defined(__dsPIC33E__)
161:               
162:               /* These traps are new to the dsPIC33E family.  Refer to the device Interrupt
163:               chapter of the FRM to understand trap priority. */
164:               void __attribute__((interrupt,no_auto_psv)) _HardTrapError(void)
165:               {
166:                   while(1);
167:               }
168:               void __attribute__((interrupt,no_auto_psv)) _SoftTrapError(void)
169:               {
170:                   while(1);
171:               }
172:               
173:               #endif
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/tip.c
1:                 /******************************************************************************/
2:                 /* Files to Include*/
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition                    */
17:                #include <stdbool.h>       /* Includes true/false definition                  */
18:                
19:                #include "system.h"        /* System funct/params, like osc/peripheral config */
20:                #include "user.h"
21:                
22:                
23:                #define READ_ROM            0x33
24:                #define SKIP_ROM            0xCC
25:                #define WRITE_SCRATCHPAD	0x0F
26:                #define COPY_SCRATCHPAD		0x55
27:                #define READ_MEMORY         0xF0
28:                #define READ_SCRATCHPAD		0xAA
29:                #define SEARCH_ROM          0xF0
30:                #define MACH_ROM            0x55
31:                
32:                #define TIP_INIT_TASK           0
33:                #define TIP_READ_DATA_TASK      1
34:                #define TIP_READ_ID_TASK        2
35:                #define TIP_VALIDATION          3
36:                #define TIP_WRITE_DATA_TASK     4
37:                #define TIP_LATCH_DATA          5
38:                #define TIP_CONNECTION_SENS     6
39:                #define TIP_WRITE_COMPLETED     7
40:                #define TIP_WAIT_FOR_WRITE      8
41:                
42:                u16 current_tip_task = 0;
43:                u32 LastStoredPulseCntr = 0;
44:                u16 WritePulseCounterTimer = 0;
45:                u8 IDData[128];
46:                
47:                u8 ROM_NO[8];
48:                u8 ID1[8];
49:                u8 ID2[8];
50:                u8 ID_APP[8];
51:                u8 ID_LIGHTGUIDE[8];
52:                u16 LastDiscrepancy;
53:                u16 LastFamilyDiscrepancy;
54:                u16 LastDeviceFlag;
55:                u8 crc8;
56:                u16 *pntrIDApp;
57:                u16 *pntrIDLg;
58:                
59:                extern u16 Trigger;
60:                extern u16 SystemStateToUpdate;
61:                
62:                u16 OWSearch();
63:                void tip_tasks(void);
64:                void Delay_uSxN(u16 uSxN);
65:                unsigned char OW_reset_pulse(void);
66:                void OW_write_bit(unsigned char write_bit);
67:                unsigned char OW_read_bit(void);
68:                void OW_write_byte(unsigned char write_data);
69:                unsigned char OW_read_byte(void);
70:                void drive_OW_low(void);
71:                void drive_OW_high(void);
72:                unsigned char read_OW(void);
73:                void ReadChipIdData(void);
74:                
75:                /**********************************************************************
76:                 * Function:        void tip_tasks(void)
77:                 * PreCondition:    None
78:                 * Input:           None
79:                 * Output:          None
80:                 * Overview:	    Dallas id components managment.
81:                 *                  This code generates reset sequence as per the protocol
82:                 ***********************************************************************/
83:                void tip_tasks(void) {
0015F0  FA0002     LNK #0x2
84:                    u16 i;
85:                    if (Devices.PulseInProgress == 0) {
0015F2  8043B1     MOV Devices, W1
0015F4  200800     MOV #0x80, W0
0015F6  608000     AND W1, W0, W0
0015F8  E00000     CP0 W0
0015FA  3A00E6     BRA NZ, 0x17C8
86:                        
87:                        if ((Devices.ApplicatorIsConnected == FALSE) || (Devices2.LightGuideReconnected == TRUE)) {
0015FC  8043B1     MOV Devices, W1
0015FE  202000     MOV #0x200, W0
001600  608000     AND W1, W0, W0
001602  E00000     CP0 W0
001604  320005     BRA Z, 0x1610
001606  8045C1     MOV 0x8B8, W1
001608  202000     MOV #0x200, W0
00160A  608000     AND W1, W0, W0
00160C  E00000     CP0 W0
00160E  320003     BRA Z, 0x1616
88:                            current_tip_task = TIP_INIT_TASK;
001610  EF283A     CLR current_tip_task
89:                            CommFlags.TipAccepted = FALSE;
001612  A968B6     BCLR 0x8B6, #3
90:                            Devices2.LightGuideReconnected = FALSE;
001614  A928B9     BCLR 0x8B9, #1
91:                        }
92:                
93:                        switch (current_tip_task) { // to read info from id chip take 15mS aprox.
001616  8041D0     MOV current_tip_task, W0
001618  500FE2     SUB W0, #0x2, [W15]
00161A  32001E     BRA Z, 0x1658
00161C  500FE2     SUB W0, #0x2, [W15]
00161E  3E0005     BRA GTU, 0x162A
001620  E00000     CP0 W0
001622  320008     BRA Z, 0x1634
001624  500FE1     SUB W0, #0x1, [W15]
001626  320055     BRA Z, 0x16D2
001628  3700CF     BRA 0x17C8
00162A  500FE3     SUB W0, #0x3, [W15]
00162C  3200BE     BRA Z, 0x17AA
00162E  500FE8     SUB W0, #0x8, [W15]
001630  320091     BRA Z, 0x1754
001632  3700CA     BRA 0x17C8
94:                            case TIP_INIT_TASK:
95:                                if (Devices.ApplicatorIsConnected) {
001634  8043B1     MOV Devices, W1
001636  202000     MOV #0x200, W0
001638  608000     AND W1, W0, W0
00163A  E00000     CP0 W0
00163C  3200B8     BRA Z, 0x17AE
96:                                    if (!OW_reset_pulse()) {
00163E  070207     RCALL OW_reset_pulse
001640  E00400     CP0.B W0
001642  3A0003     BRA NZ, 0x164A
97:                                        //Tip present
98:                                        current_tip_task = TIP_READ_ID_TASK;
001644  200020     MOV #0x2, W0
001646  8841D0     MOV W0, current_tip_task
99:                                    } else {
100:                                       //tip not present
101:                                       CommFlags.TipAccepted = FALSE;
00164A  A968B6     BCLR 0x8B6, #3
102:                                       Devices.SystemStatedUpdate = TRUE;
00164C  A80877     BSET 0x877, #0
103:                                       SystemStateToUpdate = SYS_STATE_FAULT;
00164E  2000F0     MOV #0xF, W0
001650  8846E0     MOV W0, 0x8DC
104:                                       FaultNumber = FAULT_NO_ID;
001652  200270     MOV #0x27, W0
001654  8843C0     MOV W0, FaultNumber
105:                                   }
106:                               }
107:                               break;
001648  3700BF     BRA 0x17C8
001656  3700B8     BRA 0x17C8
0017AE  000000     NOP
0017B0  37000B     BRA 0x17C8
108:               
109:                           case TIP_READ_ID_TASK:
110:                               if (!OW_reset_pulse()) {
001658  0701FA     RCALL OW_reset_pulse
00165A  E00400     CP0.B W0
00165C  3A0038     BRA NZ, 0x16CE
111:                                   LastDiscrepancy = 0;
00165E  EF2842     CLR LastDiscrepancy
112:                                   LastDeviceFlag = FALSE;
001660  EF2846     CLR LastDeviceFlag
113:                                   LastFamilyDiscrepancy = 0;
001662  EF2844     CLR LastFamilyDiscrepancy
114:                                   if (OWSearch()) {
001664  070142     RCALL OWSearch
001666  E00000     CP0 W0
001668  32000E     BRA Z, 0x1686
115:                                       for (i = 0; i < 8; i++) ID1[i] = ROM_NO[i];
00166A  EB0000     CLR W0
00166C  780F00     MOV W0, [W14]
00166E  370007     BRA 0x167E
001670  20B600     MOV #0xB60, W0
001672  40001E     ADD W0, [W14], W0
001674  784090     MOV.B [W0], W1
001676  20B680     MOV #0xB68, W0
001678  40001E     ADD W0, [W14], W0
00167A  784801     MOV.B W1, [W0]
00167C  E80F1E     INC [W14], [W14]
00167E  78001E     MOV [W14], W0
001680  500FE7     SUB W0, #0x7, [W15]
001682  36FFF6     BRA LEU, 0x1670
116:                                       Devices2.ChipIdIsConnected1 = TRUE;
001684  A8A8B8     BSET 0x8B8, #5
117:                                   }
118:                                   if (Devices2.LighGuideIsConnected == TRUE) {
001686  8045C0     MOV 0x8B8, W0
001688  600070     AND W0, #0x10, W0
00168A  E00000     CP0 W0
00168C  320011     BRA Z, 0x16B0
119:                                       if (OWSearch()) {
00168E  07012D     RCALL OWSearch
001690  E00000     CP0 W0
001692  32000E     BRA Z, 0x16B0
120:                                           for (i = 0; i < 8; i++) ID2[i] = ROM_NO[i];
001694  EB0000     CLR W0
001696  780F00     MOV W0, [W14]
001698  370007     BRA 0x16A8
00169A  20B600     MOV #0xB60, W0
00169C  40001E     ADD W0, [W14], W0
00169E  784090     MOV.B [W0], W1
0016A0  20B700     MOV #0xB70, W0
0016A2  40001E     ADD W0, [W14], W0
0016A4  784801     MOV.B W1, [W0]
0016A6  E80F1E     INC [W14], [W14]
0016A8  78001E     MOV [W14], W0
0016AA  500FE7     SUB W0, #0x7, [W15]
0016AC  36FFF6     BRA LEU, 0x169A
121:                                           Devices2.ChipIdIsConnected2 = TRUE;
0016AE  A8C8B8     BSET 0x8B8, #6
122:                                       }
123:                                   }
124:                                   if (Devices2.ChipIdIsConnected1 || Devices2.ChipIdIsConnected2)current_tip_task = TIP_READ_DATA_TASK;
0016B0  8045C1     MOV 0x8B8, W1
0016B2  200200     MOV #0x20, W0
0016B4  608000     AND W1, W0, W0
0016B6  E00000     CP0 W0
0016B8  3A0005     BRA NZ, 0x16C4
0016BA  8045C1     MOV 0x8B8, W1
0016BC  200400     MOV #0x40, W0
0016BE  608000     AND W1, W0, W0
0016C0  E00000     CP0 W0
0016C2  320003     BRA Z, 0x16CA
0016C4  200010     MOV #0x1, W0
0016C6  8841D0     MOV W0, current_tip_task
125:                                   else current_tip_task = TIP_INIT_TASK;
0016CA  EF283A     CLR current_tip_task
126:                               } else {
127:                                   current_tip_task = TIP_INIT_TASK;
0016CE  EF283A     CLR current_tip_task
128:                               }
129:                               break;
0016C8  37007F     BRA 0x17C8
0016CC  37007D     BRA 0x17C8
0016D0  37007B     BRA 0x17C8
130:               
131:                           case TIP_READ_DATA_TASK:
132:                               if (Devices2.ChipIdIsConnected1) {
0016D2  8045C1     MOV 0x8B8, W1
0016D4  200200     MOV #0x20, W0
0016D6  608000     AND W1, W0, W0
0016D8  E00000     CP0 W0
0016DA  320013     BRA Z, 0x1702
133:                                   if (!OW_reset_pulse()) {
0016DC  0701B8     RCALL OW_reset_pulse
0016DE  E00400     CP0.B W0
0016E0  3A000F     BRA NZ, 0x1700
134:                                       OW_write_byte(MACH_ROM);
0016E2  B3C550     MOV.B #0x55, W0
0016E4  0701E5     RCALL OW_write_byte
135:                                       for (i = 0; i < 8; i++) OW_write_byte(ID1[i]);
0016E6  EB0000     CLR W0
0016E8  780F00     MOV W0, [W14]
0016EA  370005     BRA 0x16F6
0016EC  20B680     MOV #0xB68, W0
0016EE  40001E     ADD W0, [W14], W0
0016F0  784010     MOV.B [W0], W0
0016F2  0701DE     RCALL OW_write_byte
0016F4  E80F1E     INC [W14], [W14]
0016F6  78001E     MOV [W14], W0
0016F8  500FE7     SUB W0, #0x7, [W15]
0016FA  36FFF8     BRA LEU, 0x16EC
136:                                       ReadChipIdData();
0016FC  070067     RCALL ReadChipIdData
0016FE  370001     BRA 0x1702
137:                                       //current_tip_task = TIP_VALIDATION;
138:                                   } else {
139:                                       current_tip_task = TIP_INIT_TASK;
001700  EF283A     CLR current_tip_task
140:                                   }
141:                               }
142:                               if (Devices2.ChipIdIsConnected2) {
001702  8045C1     MOV 0x8B8, W1
001704  200400     MOV #0x40, W0
001706  608000     AND W1, W0, W0
001708  E00000     CP0 W0
00170A  320013     BRA Z, 0x1732
143:                                   if (!OW_reset_pulse()) {
00170C  0701A0     RCALL OW_reset_pulse
00170E  E00400     CP0.B W0
001710  3A000F     BRA NZ, 0x1730
144:                                       OW_write_byte(MACH_ROM);
001712  B3C550     MOV.B #0x55, W0
001714  0701CD     RCALL OW_write_byte
145:                                       for (i = 0; i < 8; i++) OW_write_byte(ID2[i]);
001716  EB0000     CLR W0
001718  780F00     MOV W0, [W14]
00171A  370005     BRA 0x1726
00171C  20B700     MOV #0xB70, W0
00171E  40001E     ADD W0, [W14], W0
001720  784010     MOV.B [W0], W0
001722  0701C6     RCALL OW_write_byte
001724  E80F1E     INC [W14], [W14]
001726  78001E     MOV [W14], W0
001728  500FE7     SUB W0, #0x7, [W15]
00172A  36FFF8     BRA LEU, 0x171C
146:                                       ReadChipIdData();
00172C  07004F     RCALL ReadChipIdData
00172E  370001     BRA 0x1732
147:                                       //current_tip_task = TIP_VALIDATION;
148:                                   } else {
149:                                       current_tip_task = TIP_INIT_TASK;
001730  EF283A     CLR current_tip_task
150:                                   }
151:                               }
152:               
153:                               if ((Devices2.ChipIdIsConnected1)&&(Devices2.ChipIdIsConnected1)&&(FaultNumber != FAULT_UNKNOWN_LIGHTGUIDE_TYPE)) {
001732  8045C1     MOV 0x8B8, W1
001734  200200     MOV #0x20, W0
001736  608000     AND W1, W0, W0
001738  E00000     CP0 W0
00173A  32003B     BRA Z, 0x17B2
00173C  8045C1     MOV 0x8B8, W1
00173E  200200     MOV #0x20, W0
001740  608000     AND W1, W0, W0
001742  E00000     CP0 W0
001744  320038     BRA Z, 0x17B6
001746  8043C1     MOV FaultNumber, W1
001748  2002B0     MOV #0x2B, W0
00174A  508F80     SUB W1, W0, [W15]
00174C  320036     BRA Z, 0x17BA
154:                                   current_tip_task = TIP_VALIDATION;
00174E  200030     MOV #0x3, W0
001750  8841D0     MOV W0, current_tip_task
155:                               }
156:                               break;
001752  37003A     BRA 0x17C8
0017B2  000000     NOP
0017B4  370009     BRA 0x17C8
0017B6  000000     NOP
0017B8  370007     BRA 0x17C8
0017BA  000000     NOP
0017BC  370005     BRA 0x17C8
157:               
158:                           case TIP_VALIDATION:
159:               
160:                               break;
0017AA  000000     NOP
0017AC  37000D     BRA 0x17C8
161:               
162:                           case TIP_WAIT_FOR_WRITE:
163:                               if (Devices.ApplicatorIsConnected) {
001754  8043B1     MOV Devices, W1
001756  202000     MOV #0x200, W0
001758  608000     AND W1, W0, W0
00175A  E00000     CP0 W0
00175C  320024     BRA Z, 0x17A6
164:                                   if ((PulseCounter - LastStoredPulseCntr) >= 10) {
00175E  8043D2     MOV PulseCounter, W2
001760  8043E3     MOV 0x87C, W3
001762  8041E0     MOV LastStoredPulseCntr, W0
001764  8041F1     MOV 0x83E, W1
001766  510100     SUB W2, W0, W2
001768  598181     SUBB W3, W1, W3
00176A  200090     MOV #0x9, W0
00176C  200001     MOV #0x0, W1
00176E  510F80     SUB W2, W0, [W15]
001770  598F81     SUBB W3, W1, [W15]
001772  360006     BRA LEU, 0x1780
165:                                       if (!Trigger) current_tip_task = TIP_WRITE_DATA_TASK;
001774  804530     MOV Trigger, W0
001776  E00000     CP0 W0
001778  3A0022     BRA NZ, 0x17BE
00177A  200040     MOV #0x4, W0
00177C  8841D0     MOV W0, current_tip_task
166:                                   } else if (WritePulseCounterTimer > 15000) {
001780  804201     MOV WritePulseCounterTimer, W1
001782  23A980     MOV #0x3A98, W0
001784  508F80     SUB W1, W0, [W15]
001786  36001D     BRA LEU, 0x17C2
167:                                       if (PulseCounter > LastStoredPulseCntr) {
001788  8043D2     MOV PulseCounter, W2
00178A  8043E3     MOV 0x87C, W3
00178C  8041E0     MOV LastStoredPulseCntr, W0
00178E  8041F1     MOV 0x83E, W1
001790  510F80     SUB W2, W0, [W15]
001792  598F81     SUBB W3, W1, [W15]
001794  360006     BRA LEU, 0x17A2
168:                                           if (!Trigger) current_tip_task = TIP_WRITE_DATA_TASK;
001796  804530     MOV Trigger, W0
001798  E00000     CP0 W0
00179A  3A0015     BRA NZ, 0x17C6
00179C  200040     MOV #0x4, W0
00179E  8841D0     MOV W0, current_tip_task
169:                                       } else WritePulseCounterTimer = 0;
0017A2  EF2840     CLR WritePulseCounterTimer
170:                                   }
171:                               } else {
172:                                   current_tip_task = TIP_INIT_TASK;
0017A6  EF283A     CLR current_tip_task
173:                               }
174:                               break;
00177E  370024     BRA 0x17C8
0017A0  370013     BRA 0x17C8
0017A4  370011     BRA 0x17C8
0017A8  37000F     BRA 0x17C8
0017BE  000000     NOP
0017C0  370003     BRA 0x17C8
0017C2  000000     NOP
0017C4  370001     BRA 0x17C8
0017C6  000000     NOP
175:                       }
176:                   }
177:               }
0017C8  FA8000     ULNK
0017CA  060000     RETURN
178:               
179:               void ReadChipIdData(void) {
0017CC  FA0002     LNK #0x2
180:                   u16 s;
181:                   if ((SystemState == SYS_STATE_FAULT)&&(FaultNumber == FAULT_UNKNOWN_LIGHTGUIDE_TYPE)) {
0017CE  8045D0     MOV 0x8BA, W0
0017D0  500FEF     SUB W0, #0xF, [W15]
0017D2  3A0008     BRA NZ, 0x17E4
0017D4  8043C1     MOV FaultNumber, W1
0017D6  2002B0     MOV #0x2B, W0
0017D8  508F80     SUB W1, W0, [W15]
0017DA  3A0004     BRA NZ, 0x17E4
182:                       Devices.SystemStatedUpdate = TRUE;
0017DC  A80877     BSET 0x877, #0
183:                       SystemStateToUpdate = SYS_STATE_STANDBY;
0017DE  200100     MOV #0x10, W0
0017E0  8846E0     MOV W0, 0x8DC
184:                       FaultNumber = CLEAR;
0017E2  EF2878     CLR FaultNumber
185:                   }
186:               
187:                   OW_write_byte(READ_MEMORY);
0017E4  B3CF00     MOV.B #0xF0, W0
0017E6  070164     RCALL OW_write_byte
188:                   OW_write_byte(0); //address of pulse counter register 0x00-0x03(0x00 is MSB, 0x03 is LSB)
0017E8  EB4000     CLR.B W0
0017EA  070162     RCALL OW_write_byte
189:                   OW_write_byte(0);
0017EC  EB4000     CLR.B W0
0017EE  070160     RCALL OW_write_byte
190:                   for (s = 0; s < 128; ++s) IDData[s] = OW_read_byte();
0017F0  EB0000     CLR W0
0017F2  780F00     MOV W0, [W14]
0017F4  370005     BRA 0x1800
0017F6  07016E     RCALL OW_read_byte
0017F8  20AE01     MOV #0xAE0, W1
0017FA  40809E     ADD W1, [W14], W1
0017FC  784880     MOV.B W0, [W1]
0017FE  E80F1E     INC [W14], [W14]
001800  2007F0     MOV #0x7F, W0
001802  78009E     MOV [W14], W1
001804  508F80     SUB W1, W0, [W15]
001806  36FFF7     BRA LEU, 0x17F6
191:                   if (IDData[0] == 0x10) {//ID of applicator get data
001808  20AE00     MOV #0xAE0, W0
00180A  784010     MOV.B [W0], W0
00180C  504FF0     SUB.B W0, #0x10, [W15]
00180E  3A0028     BRA NZ, 0x1860
192:                       for (s = 0; s < 8; s++) ID_APP[s] = ID1[s];
001810  EB0000     CLR W0
001812  780F00     MOV W0, [W14]
001814  370007     BRA 0x1824
001816  20B680     MOV #0xB68, W0
001818  40001E     ADD W0, [W14], W0
00181A  784090     MOV.B [W0], W1
00181C  20B780     MOV #0xB78, W0
00181E  40001E     ADD W0, [W14], W0
001820  784801     MOV.B W1, [W0]
001822  E80F1E     INC [W14], [W14]
001824  78001E     MOV [W14], W0
001826  500FE7     SUB W0, #0x7, [W15]
001828  36FFF6     BRA LEU, 0x1816
193:                       PulseCounter = IDData[60];
00182A  20B1C0     MOV #0xB1C, W0
00182C  784010     MOV.B [W0], W0
00182E  FB8000     ZE W0, W0
001830  EB0080     CLR W1
001832  8843D0     MOV W0, PulseCounter
001834  8843E1     MOV W1, 0x87C
194:                       PulseCounter <<= 16;
001836  8043D0     MOV PulseCounter, W0
001838  8043E1     MOV 0x87C, W1
00183A  DD00C0     SL W0, #0, W1
00183C  200000     MOV #0x0, W0
00183E  8843D0     MOV W0, PulseCounter
001840  8843E1     MOV W1, 0x87C
195:                       PulseCounter = PulseCounter + IDData[61];
001842  20B1D0     MOV #0xB1D, W0
001844  784010     MOV.B [W0], W0
001846  FB8100     ZE W0, W2
001848  EB0180     CLR W3
00184A  8043D0     MOV PulseCounter, W0
00184C  8043E1     MOV 0x87C, W1
00184E  400002     ADD W0, W2, W0
001850  488083     ADDC W1, W3, W1
001852  8843D0     MOV W0, PulseCounter
001854  8843E1     MOV W1, 0x87C
196:                       LastStoredPulseCntr = PulseCounter;
001856  8043D0     MOV PulseCounter, W0
001858  8043E1     MOV 0x87C, W1
00185A  8841E0     MOV W0, LastStoredPulseCntr
00185C  8841F1     MOV W1, 0x83E
00185E  370043     BRA 0x18E6
197:                   } else if ((IDData[0] == 0x20) || (IDData[0] == 0x40) || (IDData[0] == 0x30)) {
001860  20AE00     MOV #0xAE0, W0
001862  784090     MOV.B [W0], W1
001864  B3C200     MOV.B #0x20, W0
001866  50CF80     SUB.B W1, W0, [W15]
001868  32000A     BRA Z, 0x187E
00186A  20AE00     MOV #0xAE0, W0
00186C  784090     MOV.B [W0], W1
00186E  B3C400     MOV.B #0x40, W0
001870  50CF80     SUB.B W1, W0, [W15]
001872  320005     BRA Z, 0x187E
001874  20AE00     MOV #0xAE0, W0
001876  784090     MOV.B [W0], W1
001878  B3C300     MOV.B #0x30, W0
00187A  50CF80     SUB.B W1, W0, [W15]
00187C  3A0028     BRA NZ, 0x18CE
198:                       LgTypeId = IDData[0];
00187E  20AE00     MOV #0xAE0, W0
001880  784010     MOV.B [W0], W0
001882  FB8000     ZE W0, W0
001884  884410     MOV W0, LgTypeId
199:                       for (s = 0; s < 8; s++) ID_LIGHTGUIDE[s] = ID1[s];
001886  EB0000     CLR W0
001888  780F00     MOV W0, [W14]
00188A  370007     BRA 0x189A
00188C  20B680     MOV #0xB68, W0
00188E  40001E     ADD W0, [W14], W0
001890  784090     MOV.B [W0], W1
001892  20B800     MOV #0xB80, W0
001894  40001E     ADD W0, [W14], W0
001896  784801     MOV.B W1, [W0]
001898  E80F1E     INC [W14], [W14]
00189A  78001E     MOV [W14], W0
00189C  500FE7     SUB W0, #0x7, [W15]
00189E  36FFF6     BRA LEU, 0x188C
200:                       LgPulseCounter = IDData[10];
0018A0  20AEA0     MOV #0xAEA, W0
0018A2  784010     MOV.B [W0], W0
0018A4  FB8000     ZE W0, W0
0018A6  EB0080     CLR W1
0018A8  8843F0     MOV W0, LgPulseCounter
0018AA  884401     MOV W1, 0x880
201:                       LgPulseCounter <<= 16;
0018AC  8043F0     MOV LgPulseCounter, W0
0018AE  804401     MOV 0x880, W1
0018B0  DD00C0     SL W0, #0, W1
0018B2  200000     MOV #0x0, W0
0018B4  8843F0     MOV W0, LgPulseCounter
0018B6  884401     MOV W1, 0x880
202:                       LgPulseCounter = LgPulseCounter + IDData[11];
0018B8  20AEB0     MOV #0xAEB, W0
0018BA  784010     MOV.B [W0], W0
0018BC  FB8100     ZE W0, W2
0018BE  EB0180     CLR W3
0018C0  8043F0     MOV LgPulseCounter, W0
0018C2  804401     MOV 0x880, W1
0018C4  400002     ADD W0, W2, W0
0018C6  488083     ADDC W1, W3, W1
0018C8  8843F0     MOV W0, LgPulseCounter
0018CA  884401     MOV W1, 0x880
0018CC  37000C     BRA 0x18E6
203:                   } else if (LgTypeId == 0) {
0018CE  804410     MOV LgTypeId, W0
0018D0  E00000     CP0 W0
0018D2  3A0009     BRA NZ, 0x18E6
204:                       if (FaultNumber == 0) {
0018D4  8043C0     MOV FaultNumber, W0
0018D6  E00000     CP0 W0
0018D8  3A0006     BRA NZ, 0x18E6
205:                           CommFlags.TipAccepted = FALSE;
0018DA  A968B6     BCLR 0x8B6, #3
206:                           Devices.SystemStatedUpdate = TRUE;
0018DC  A80877     BSET 0x877, #0
207:                           SystemStateToUpdate = SYS_STATE_FAULT;
0018DE  2000F0     MOV #0xF, W0
0018E0  8846E0     MOV W0, 0x8DC
208:                           FaultNumber = FAULT_UNKNOWN_LIGHTGUIDE_TYPE;
0018E2  2002B0     MOV #0x2B, W0
0018E4  8843C0     MOV W0, FaultNumber
209:                       }
210:                   }
211:               }
0018E6  FA8000     ULNK
0018E8  060000     RETURN
212:               
213:               u16 OWSearch() {
0018EA  FA000E     LNK #0xE
214:                   u16 id_bit_number;
215:                   u16 last_zero, rom_byte_number, search_result;
216:                   u16 id_bit, cmp_id_bit;
217:                   u8 rom_byte_mask, search_direction;
218:               
219:                   // initialize for search
220:                   id_bit_number = 1;
0018EC  200010     MOV #0x1, W0
0018EE  780F00     MOV W0, [W14]
221:                   last_zero = 0;
0018F0  EB0000     CLR W0
0018F2  980710     MOV W0, [W14+2]
222:                   rom_byte_number = 0;
0018F4  EB0000     CLR W0
0018F6  980720     MOV W0, [W14+4]
223:                   rom_byte_mask = 1;
0018F8  B3C010     MOV.B #0x1, W0
0018FA  984F00     MOV.B W0, [W14+8]
224:                   search_result = 0;
0018FC  EB0000     CLR W0
0018FE  980730     MOV W0, [W14+6]
225:                   crc8 = 0;
001900  EF6848     CLR.B crc8
226:               
227:                   if (!LastDeviceFlag) {
001902  804230     MOV LastDeviceFlag, W0
001904  E00000     CP0 W0
001906  3A0079     BRA NZ, 0x19FA
228:                       // 1-Wire reset
229:                       if (OW_reset_pulse()) {
001908  0700A2     RCALL OW_reset_pulse
00190A  E00400     CP0.B W0
00190C  320005     BRA Z, 0x1918
230:                           // reset the search
231:                           LastDiscrepancy = 0;
00190E  EF2842     CLR LastDiscrepancy
232:                           LastDeviceFlag = FALSE;
001910  EF2846     CLR LastDeviceFlag
233:                           LastFamilyDiscrepancy = 0;
001912  EF2844     CLR LastFamilyDiscrepancy
234:                           return FALSE;
001914  EB0000     CLR W0
001916  37007E     BRA 0x1A14
235:                       }
236:               
237:                       // issue the search command 
238:                       OW_write_byte(SEARCH_ROM);
001918  B3CF00     MOV.B #0xF0, W0
00191A  0700CA     RCALL OW_write_byte
239:               
240:                       // loop to do the search
241:                       do {
242:                           // read a bit and its complement
243:                           id_bit = OW_read_bit();
00191C  0700BB     RCALL OW_read_bit
00191E  FB8000     ZE W0, W0
001920  980750     MOV W0, [W14+10]
244:                           cmp_id_bit = OW_read_bit();
001922  0700B8     RCALL OW_read_bit
001924  FB8000     ZE W0, W0
001926  980760     MOV W0, [W14+12]
245:               
246:                           // check for no devices on 1-wire
247:                           if ((id_bit == 1) && (cmp_id_bit == 1))
001928  90005E     MOV [W14+10], W0
00192A  500FE1     SUB W0, #0x1, [W15]
00192C  3A0003     BRA NZ, 0x1934
00192E  90006E     MOV [W14+12], W0
001930  500FE1     SUB W0, #0x1, [W15]
001932  320053     BRA Z, 0x19DA
248:                               break;
249:                           else {
250:                               // all devices coupled have 0 or 1
251:                               if (id_bit != cmp_id_bit)
001934  9000DE     MOV [W14+10], W1
001936  90006E     MOV [W14+12], W0
001938  508F80     SUB W1, W0, [W15]
00193A  320003     BRA Z, 0x1942
252:                                   search_direction = id_bit; // bit write value for search
00193C  90005E     MOV [W14+10], W0
00193E  984F10     MOV.B W0, [W14+9]
001940  370020     BRA 0x1982
253:                               else {
254:                                   // if this discrepancy if before the Last Discrepancy
255:                                   // on a previous next then pick the same as last time
256:                                   if (id_bit_number < LastDiscrepancy)
001942  804210     MOV LastDiscrepancy, W0
001944  78009E     MOV [W14], W1
001946  508F80     SUB W1, W0, [W15]
001948  31000B     BRA C, 0x1960
257:                                       search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
00194A  20B601     MOV #0xB60, W1
00194C  90002E     MOV [W14+4], W0
00194E  408000     ADD W1, W0, W0
001950  784090     MOV.B [W0], W1
001952  90480E     MOV.B [W14+8], W0
001954  60C000     AND.B W1, W0, W0
001956  FB8000     ZE W0, W0
001958  EA0000     NEG W0, W0
00195A  DE004F     LSR W0, #15, W0
00195C  984F10     MOV.B W0, [W14+9]
00195E  370007     BRA 0x196E
258:                                   else
259:                                       // if equal to last pick 1, if not then pick 0
260:                                       search_direction = (id_bit_number == LastDiscrepancy);
001960  804210     MOV LastDiscrepancy, W0
001962  68001E     XOR W0, [W14], W0
001964  A7F000     BTSC W0, #15
001966  EA0000     NEG W0, W0
001968  E90000     DEC W0, W0
00196A  DE004F     LSR W0, #15, W0
00196C  984F10     MOV.B W0, [W14+9]
261:               
262:                                   // if 0 was picked then record its position in LastZero
263:                                   if (search_direction == 0) {
00196E  90481E     MOV.B [W14+9], W0
001970  E00400     CP0.B W0
001972  3A0007     BRA NZ, 0x1982
264:                                       last_zero = id_bit_number;
001974  78009E     MOV [W14], W1
001976  980711     MOV W1, [W14+2]
265:               
266:                                       // check for Last discrepancy in family
267:                                       if (last_zero < 9)
001978  90001E     MOV [W14+2], W0
00197A  500FE8     SUB W0, #0x8, [W15]
00197C  3E0002     BRA GTU, 0x1982
268:                                           LastFamilyDiscrepancy = last_zero;
00197E  90009E     MOV [W14+2], W1
001980  884221     MOV W1, LastFamilyDiscrepancy
269:                                   }
270:                               }
271:               
272:                               // set or clear the bit in the ROM byte rom_byte_number
273:                               // with mask rom_byte_mask
274:                               if (search_direction == 1)
001982  90481E     MOV.B [W14+9], W0
001984  504FE1     SUB.B W0, #0x1, [W15]
001986  3A000B     BRA NZ, 0x199E
275:                                   ROM_NO[rom_byte_number] |= rom_byte_mask;
001988  20B601     MOV #0xB60, W1
00198A  90002E     MOV [W14+4], W0
00198C  408000     ADD W1, W0, W0
00198E  784090     MOV.B [W0], W1
001990  90480E     MOV.B [W14+8], W0
001992  70C080     IOR.B W1, W0, W1
001994  20B602     MOV #0xB60, W2
001996  90002E     MOV [W14+4], W0
001998  410000     ADD W2, W0, W0
00199A  784801     MOV.B W1, [W0]
00199C  37000D     BRA 0x19B8
276:                               else
277:                                   ROM_NO[rom_byte_number] &= ~rom_byte_mask;
00199E  20B601     MOV #0xB60, W1
0019A0  90002E     MOV [W14+4], W0
0019A2  408000     ADD W1, W0, W0
0019A4  784010     MOV.B [W0], W0
0019A6  784080     MOV.B W0, W1
0019A8  90480E     MOV.B [W14+8], W0
0019AA  EAC000     COM.B W0, W0
0019AC  60C000     AND.B W1, W0, W0
0019AE  784080     MOV.B W0, W1
0019B0  20B602     MOV #0xB60, W2
0019B2  90002E     MOV [W14+4], W0
0019B4  410000     ADD W2, W0, W0
0019B6  784801     MOV.B W1, [W0]
278:               
279:                               // serial number search direction write bit
280:                               OW_write_bit(search_direction);
0019B8  90481E     MOV.B [W14+9], W0
0019BA  070058     RCALL OW_write_bit
281:               
282:                               // increment the byte counter id_bit_number
283:                               // and shift the mask rom_byte_mask
284:                               id_bit_number++;
0019BC  E80F1E     INC [W14], [W14]
285:                               rom_byte_mask <<= 1;
0019BE  90480E     MOV.B [W14+8], W0
0019C0  404000     ADD.B W0, W0, W0
0019C2  984F00     MOV.B W0, [W14+8]
286:               
287:                               // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
288:                               if (rom_byte_mask == 0) {
0019C4  90480E     MOV.B [W14+8], W0
0019C6  E00400     CP0.B W0
0019C8  3A0005     BRA NZ, 0x19D4
289:                                   //docrc8(ROM_NO[rom_byte_number]);  // accumulate the CRC
290:                                   rom_byte_number++;
0019CA  90002E     MOV [W14+4], W0
0019CC  E80000     INC W0, W0
0019CE  980720     MOV W0, [W14+4]
291:                                   rom_byte_mask = 1;
0019D0  B3C010     MOV.B #0x1, W0
0019D2  984F00     MOV.B W0, [W14+8]
292:                               }
293:                           }
294:                       } while (rom_byte_number < 8); // loop until through all ROM bytes 0-7
0019D4  90002E     MOV [W14+4], W0
0019D6  500FE7     SUB W0, #0x7, [W15]
0019D8  36FFA1     BRA LEU, 0x191C
295:               
296:                       // if the search was successful then
297:                       if (!((id_bit_number < 65) || (crc8 != 0))) {
0019DA  200400     MOV #0x40, W0
0019DC  78009E     MOV [W14], W1
0019DE  508F80     SUB W1, W0, [W15]
0019E0  36000C     BRA LEU, 0x19FA
0019E2  BFC848     MOV.B crc8, WREG
0019E4  E00400     CP0.B W0
0019E6  3A0009     BRA NZ, 0x19FA
298:                           // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
299:                           LastDiscrepancy = last_zero;
0019E8  90009E     MOV [W14+2], W1
0019EA  884211     MOV W1, LastDiscrepancy
300:               
301:                           // check for last device
302:                           if (LastDiscrepancy == 0)LastDeviceFlag = TRUE;
0019EC  804210     MOV LastDiscrepancy, W0
0019EE  E00000     CP0 W0
0019F0  3A0002     BRA NZ, 0x19F6
0019F2  200010     MOV #0x1, W0
0019F4  884230     MOV W0, LastDeviceFlag
303:               
304:                           search_result = TRUE;
0019F6  200010     MOV #0x1, W0
0019F8  980730     MOV W0, [W14+6]
305:                       }
306:                   }
307:                   if (!search_result || !ROM_NO[0]) {
0019FA  90003E     MOV [W14+6], W0
0019FC  E00000     CP0 W0
0019FE  320004     BRA Z, 0x1A08
001A00  20B600     MOV #0xB60, W0
001A02  784010     MOV.B [W0], W0
001A04  E00400     CP0.B W0
001A06  3A0005     BRA NZ, 0x1A12
308:                       LastDiscrepancy = 0;
001A08  EF2842     CLR LastDiscrepancy
309:                       LastDeviceFlag = FALSE;
001A0A  EF2846     CLR LastDeviceFlag
310:                       LastFamilyDiscrepancy = 0;
001A0C  EF2844     CLR LastFamilyDiscrepancy
311:                       search_result = FALSE;
001A0E  EB0000     CLR W0
001A10  980730     MOV W0, [W14+6]
312:                   }
313:               
314:                   return search_result;
001A12  90003E     MOV [W14+6], W0
315:               }
001A14  FA8000     ULNK
001A16  060000     RETURN
316:               
317:               /**********************************************************************
318:                * Function:        void drive_OW_low (void)
319:                * PreCondition:    None
320:                * Input:		   None
321:                * Output:		   None
322:                * Overview:		   Configure the OW_PIN as Output and drive the OW_PIN LOW.
323:                ***********************************************************************/
324:               void drive_OW_low(void) {
001A18  FA0000     LNK #0x0
325:                   OW_PIN_DIRECTION = OUTPUT;
001A1A  A9E2F4     BCLR LATG, #7
326:                   OW_WRITE_PIN = LOW;
001A1C  A9E2F0     BCLR TRISG, #7
327:               }
001A1E  FA8000     ULNK
001A20  060000     RETURN
328:               
329:               /**********************************************************************
330:                * Function:        void drive_OW_high (void)
331:                * PreCondition:    None
332:                * Input:		   None
333:                * Output:		   None
334:                * Overview:		   Configure the OW_PIN as Output and drive the OW_PIN HIGH.
335:                ***********************************************************************/
336:               void drive_OW_high(void) {
001A22  FA0000     LNK #0x0
337:                   OW_PIN_DIRECTION = OUTPUT;
001A24  A9E2F4     BCLR LATG, #7
338:                   OW_WRITE_PIN = HIGH;
001A26  A8E2F0     BSET TRISG, #7
339:               }
001A28  FA8000     ULNK
001A2A  060000     RETURN
340:               
341:               /**********************************************************************
342:                * Function:        unsigned char read_OW (void)
343:                * PreCondition:    None
344:                * Input:		   None
345:                * Output:		   Return the status of OW pin.
346:                * Overview:		   Configure as Input pin and Read the status of OW_PIN
347:                ***********************************************************************/
348:               unsigned char read_OW(void) {
001A2C  FA0002     LNK #0x2
349:                   unsigned char read_data = 0;
001A2E  EB4000     CLR.B W0
001A30  784F00     MOV.B W0, [W14]
350:               
351:                   OW_WRITE_PIN = INPUT;
001A32  A8E2F0     BSET TRISG, #7
352:                   if (HIGH == OW_READ_PIN) read_data = SET;
001A34  801791     MOV PORTG, W1
001A36  200800     MOV #0x80, W0
001A38  608000     AND W1, W0, W0
001A3A  E00000     CP0 W0
001A3C  320003     BRA Z, 0x1A44
001A3E  B3C010     MOV.B #0x1, W0
001A40  784F00     MOV.B W0, [W14]
001A42  370002     BRA 0x1A48
353:                   else read_data = CLEAR;
001A44  EB4000     CLR.B W0
001A46  784F00     MOV.B W0, [W14]
354:               
355:                   return read_data;
001A48  78401E     MOV.B [W14], W0
356:               }
001A4A  FA8000     ULNK
001A4C  060000     RETURN
357:               
358:               /**********************************************************************
359:                * Function:        unsigned char OW_reset_pulse(void)
360:                * PreCondition:    None
361:                * Input:		   None
362:                * Output:		   Return the Presense Pulse from the slave.
363:                * Overview:		   Initialization sequence start with reset pulse.
364:                *				   This code generates reset sequence as per the protocol
365:                ***********************************************************************/
366:               unsigned char OW_reset_pulse(void) {
001A4E  FA0002     LNK #0x2
367:                   unsigned char presence_detect;
368:               
369:                   drive_OW_low(); // Drive the bus low
001A50  07FFE3     RCALL drive_OW_low
370:                   Delay_uSxN(480); // delay 480 microsecond (us)
001A52  201E00     MOV #0x1E0, W0
001A54  070057     RCALL Delay_uSxN
371:                   drive_OW_high(); // Release the bus
001A56  07FFE5     RCALL drive_OW_high
372:                   Delay_uSxN(70); // delay 70 microsecond (us)
001A58  200460     MOV #0x46, W0
001A5A  070054     RCALL Delay_uSxN
373:                   presence_detect = read_OW(); //Sample for presence pulse from slave
001A5C  07FFE7     RCALL read_OW
001A5E  784F00     MOV.B W0, [W14]
374:                   Delay_uSxN(410); // delay 410 microsecond (us)
001A60  2019A0     MOV #0x19A, W0
001A62  070050     RCALL Delay_uSxN
375:                   drive_OW_high(); // Release the bus
001A64  07FFDE     RCALL drive_OW_high
376:                   return presence_detect;
001A66  78401E     MOV.B [W14], W0
377:               }
001A68  FA8000     ULNK
001A6A  060000     RETURN
378:               
379:               /**********************************************************************
380:                * Function:        void OW_write_bit (unsigned char write_data)
381:                * PreCondition:    None
382:                * Input:		   Write a bit to 1-wire slave device.
383:                * Output:		   None
384:                * Overview:		   This function used to transmit a single bit to slave device.
385:                *
386:                ***********************************************************************/
387:               void OW_write_bit(unsigned char write_bit) {
001A6C  FA0002     LNK #0x2
001A6E  784F00     MOV.B W0, [W14]
388:                   if (write_bit) {
001A70  78401E     MOV.B [W14], W0
001A72  E00400     CP0.B W0
001A74  320007     BRA Z, 0x1A84
389:                       //writing a bit '1'
390:                       drive_OW_low(); // Drive the bus low
001A76  07FFD0     RCALL drive_OW_low
391:                       Delay_uSxN(6); // delay 6 microsecond (us)
001A78  200060     MOV #0x6, W0
001A7A  070044     RCALL Delay_uSxN
392:                       drive_OW_high(); // Release the bus
001A7C  07FFD2     RCALL drive_OW_high
393:                       Delay_uSxN(64); // delay 64 microsecond (us)
001A7E  200400     MOV #0x40, W0
001A80  070041     RCALL Delay_uSxN
001A82  370006     BRA 0x1A90
394:                   } else {
395:                       //writing a bit '0'
396:                       drive_OW_low(); // Drive the bus low
001A84  07FFC9     RCALL drive_OW_low
397:                       Delay_uSxN(60); // delay 60 microsecond (us)
001A86  2003C0     MOV #0x3C, W0
001A88  07003D     RCALL Delay_uSxN
398:                       drive_OW_high(); // Release the bus
001A8A  07FFCB     RCALL drive_OW_high
399:                       Delay_uSxN(10); // delay 10 microsecond for recovery (us)
001A8C  2000A0     MOV #0xA, W0
001A8E  07003A     RCALL Delay_uSxN
400:                   }
401:               }
001A90  FA8000     ULNK
001A92  060000     RETURN
402:               
403:               /**********************************************************************
404:                * Function:        unsigned char OW_read_bit (void)
405:                * PreCondition:    None
406:                * Input:		   None
407:                * Output:		   Return the status of the OW PIN
408:                * Overview:		   This function used to read a single bit from the slave device.
409:                *
410:                ***********************************************************************/
411:               
412:               unsigned char OW_read_bit(void) {
001A94  FA0002     LNK #0x2
413:                   unsigned char read_data;
414:                   //reading a bit
415:                   drive_OW_low(); // Drive the bus low
001A96  07FFC0     RCALL drive_OW_low
416:                   Delay_uSxN(6); // delay 6 microsecond (us)
001A98  200060     MOV #0x6, W0
001A9A  070034     RCALL Delay_uSxN
417:                   drive_OW_high(); // Release the bus
001A9C  07FFC2     RCALL drive_OW_high
418:                   Delay_uSxN(9); // delay 9 microsecond (us)
001A9E  200090     MOV #0x9, W0
001AA0  070031     RCALL Delay_uSxN
419:                   read_data = read_OW(); //Read the status of OW_PIN
001AA2  07FFC4     RCALL read_OW
001AA4  784F00     MOV.B W0, [W14]
420:                   Delay_uSxN(55); // delay 55 microsecond (us)
001AA6  200370     MOV #0x37, W0
001AA8  07002D     RCALL Delay_uSxN
421:                   return read_data;
001AAA  78401E     MOV.B [W14], W0
422:               }
001AAC  FA8000     ULNK
001AAE  060000     RETURN
423:               
424:               /**********************************************************************
425:                * Function:        void OW_write_byte (unsigned char write_data)
426:                * PreCondition:    None
427:                * Input:		   Send byte to 1-wire slave device
428:                * Output:		   None
429:                * Overview:		   This function used to transmit a complete byte to slave device.
430:                *
431:                ***********************************************************************/
432:               void OW_write_byte(unsigned char write_data) {
001AB0  FA0004     LNK #0x4
001AB2  984720     MOV.B W0, [W14+2]
433:                   unsigned char loop;
434:                   for (loop = 0; loop < 8; loop++) {
001AB4  EB4000     CLR.B W0
001AB6  784F00     MOV.B W0, [W14]
001AB8  370008     BRA 0x1ACA
001AC8  E84F1E     INC.B [W14], [W14]
001ACA  78401E     MOV.B [W14], W0
001ACC  504FE7     SUB.B W0, #0x7, [W15]
001ACE  36FFF5     BRA LEU, 0x1ABA
435:                       OW_write_bit(write_data & 0x01); //Sending LS-bit first
001ABA  90402E     MOV.B [W14+2], W0
001ABC  604061     AND.B W0, #0x1, W0
001ABE  07FFD6     RCALL OW_write_bit
436:                       write_data >>= 1; // shift the data byte for the next bit to send
001AC0  90402E     MOV.B [W14+2], W0
001AC2  FB8000     ZE W0, W0
001AC4  D10000     LSR W0, W0
001AC6  984720     MOV.B W0, [W14+2]
437:                   }
438:               }
001AD0  FA8000     ULNK
001AD2  060000     RETURN
439:               
440:               /**********************************************************************
441:                * Function:        unsigned char OW_read_byte (void)
442:                * PreCondition:    None
443:                * Input:		   None
444:                * Output:		   Return the read byte from slave device
445:                * Overview:		   This function used to read a complete byte from the slave device.
446:                *
447:                ***********************************************************************/
448:               unsigned char OW_read_byte(void) {
001AD4  FA0002     LNK #0x2
449:                   unsigned char loop, result = 0;
001AD6  EB4000     CLR.B W0
001AD8  984710     MOV.B W0, [W14+1]
450:               
451:                   for (loop = 0; loop < 8; loop++) {
001ADA  EB4000     CLR.B W0
001ADC  784F00     MOV.B W0, [W14]
001ADE  37000C     BRA 0x1AF8
001AF6  E84F1E     INC.B [W14], [W14]
001AF8  78401E     MOV.B [W14], W0
001AFA  504FE7     SUB.B W0, #0x7, [W15]
001AFC  36FFF1     BRA LEU, 0x1AE0
452:                       result >>= 1; // shift the result to get it ready for the next bit to receive
001AE0  90401E     MOV.B [W14+1], W0
001AE2  FB8000     ZE W0, W0
001AE4  D10000     LSR W0, W0
001AE6  984710     MOV.B W0, [W14+1]
453:                       if (OW_read_bit())
001AE8  07FFD5     RCALL OW_read_bit
001AEA  E00400     CP0.B W0
001AEC  320004     BRA Z, 0x1AF6
454:                           result |= 0x80; // if result is one, then set MS-bit
001AEE  90409E     MOV.B [W14+1], W1
001AF0  B3C800     MOV.B #0x80, W0
001AF2  70C000     IOR.B W1, W0, W0
001AF4  984710     MOV.B W0, [W14+1]
455:                   }
456:                   return result;
001AFE  90401E     MOV.B [W14+1], W0
457:               }
001B00  FA8000     ULNK
001B02  060000     RETURN
458:               
459:               /**********************************************************************
460:                * Function:        void Delay_uSxN(u16 uSxN)
461:                * PreCondition:    None
462:                * Input:		   uSxN micro seconds to delay
463:                * Output:		   None
464:                * Overview:		   This function used to delay for uSxN micro seconds.
465:                *
466:                ***********************************************************************/
467:               void Delay_uSxN(u16 uSxN) {
001B04  FA0002     LNK #0x2
001B06  780F00     MOV W0, [W14]
468:                   IFS1bits.T5IF = 0;
001B08  A98087     BCLR 0x87, #4
469:                   TMR5 = 0;
001B0A  EF2118     CLR TMR5
470:                   PR5 = uSxN * 40;
001B0C  78009E     MOV [W14], W1
001B0E  200280     MOV #0x28, W0
001B10  B98800     MUL.SS W1, W0, W0
001B12  780000     MOV W0, W0
001B14  8808E0     MOV W0, PR5
471:                   T5CONbits.TON = 1; // Enable Timer1 and start the counter
001B16  A8E121     BSET 0x121, #7
472:                   while (!IFS1bits.T5IF);
001B18  000000     NOP
001B1A  800431     MOV IFS1, W1
001B1C  210000     MOV #0x1000, W0
001B1E  608000     AND W1, W0, W0
001B20  E00000     CP0 W0
001B22  32FFFB     BRA Z, 0x1B1A
473:                   T5CONbits.TON = 0;
001B24  A9E121     BCLR 0x121, #7
474:               }
001B26  FA8000     ULNK
001B28  060000     RETURN
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/tec.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"          /* User funct/params, such as InitApp              */
16:                #include <dsp.h>
17:                #include "termistor.h"
18:                
19:                
20:                /*================= Macros ===============================*/
21:                #define TEC_PID_INIT                0
22:                #define TEC_TASK_INIT               1
23:                #define TEC_TASK_WORK               2
24:                #define TEC_TASK_PID_IN_PROGRESS    3
25:                
26:                #define TEC_V_SENS_TIME 300
27:                /*================================================*/
28:                
29:                /*================= Variables ===============================*/
30:                u16 TecTemperature[5] = {0, 0, 0, 0, 0};
31:                u16 indxTecTemperature = 0;
32:                u16 TECVoltage = 0;
33:                u16 StoredTECValue = 9;
34:                u16 current_tec_task = 0;
35:                u16 CoolingLevel = 50;
36:                float ActualTecTemperature = 0;
37:                float ActualTermistorValue = 0;
38:                float tVal;
39:                double lastTime;
40:                double Input, Output, Setpoint = 0;
41:                double errSum, lastErr = 0;
42:                double kp, ki, kd;
43:                u16 TecVoltageMonitor = 0;
44:                u16 TecCurrentMonoitor = 0;
45:                
46:                extern u16 TecVoltageSensingTimer;
47:                /*================================================*/
48:                
49:                /*================= Functions ===============================*/
50:                //void TecControl(float Voltage);
51:                void TECPIDInit(void);
52:                void tec_tasks(void);
53:                void SetTECVoltage(float Voltage);
54:                float GetTemperatureFromTable();
55:                void PidCompute(void);
56:                
57:                /*================================================*/
58:                
59:                void tec_tasks(void) {
0029AA  FA0002     LNK #0x2
0029AC  BE9F88     MOV.D W8, [W15++]
60:                    u16 i;
61:                
62:                    if (indxTecTemperature == 5) {
0029AE  804000     MOV indxTecTemperature, W0
0029B0  500FE5     SUB W0, #0x5, [W15]
0029B2  3A003C     BRA NZ, 0x2A2C
63:                        indxTecTemperature = 0;
0029B4  EF2800     CLR indxTecTemperature
64:                        ActualTermistorValue = 0;
0029B6  B80060     MUL.UU W0, #0, W0
0029B8  884050     MOV W0, ActualTermistorValue
0029BA  884061     MOV W1, 0x80C
65:                        for (i = 0; i < 5; i++) {
0029BC  EB0000     CLR W0
0029BE  780F00     MOV W0, [W14]
0029C0  370010     BRA 0x29E2
0029E0  E80F1E     INC [W14], [W14]
0029E2  78001E     MOV [W14], W0
0029E4  500FE4     SUB W0, #0x4, [W15]
0029E6  36FFED     BRA LEU, 0x29C2
66:                            ActualTermistorValue = (float) ActualTermistorValue + TecTemperature[i];
0029C2  78001E     MOV [W14], W0
0029C4  400080     ADD W0, W0, W1
0029C6  20B9C0     MOV #0xB9C, W0
0029C8  408000     ADD W1, W0, W0
0029CA  780010     MOV [W0], W0
0029CC  EB0080     CLR W1
0029CE  07F461     RCALL 0x1292
0029D0  BE0200     MOV.D W0, W4
0029D2  804050     MOV ActualTermistorValue, W0
0029D4  804061     MOV 0x80C, W1
0029D6  BE0100     MOV.D W0, W2
0029D8  BE0004     MOV.D W4, W0
0029DA  07F37C     RCALL 0x10D4
0029DC  884050     MOV W0, ActualTermistorValue
0029DE  884061     MOV W1, 0x80C
67:                        }
68:                        tVal = (float) ActualTermistorValue / 5.0 * 3.2;
0029E8  804050     MOV ActualTermistorValue, W0
0029EA  804061     MOV 0x80C, W1
0029EC  200002     MOV #0x0, W2
0029EE  240A03     MOV #0x40A0, W3
0029F0  07F3CE     RCALL 0x118E
0029F2  2CCCD2     MOV #0xCCCD, W2
0029F4  2404C3     MOV #0x404C, W3
0029F6  07F4A2     RCALL 0x133C
0029F8  884070     MOV W0, tVal
0029FA  884081     MOV W1, 0x810
69:                        ActualTermistorValue = (float) tVal * 20.5 / ((5000 - tVal) / 1000);
0029FC  804070     MOV tVal, W0
0029FE  804081     MOV 0x810, W1
002A00  200002     MOV #0x0, W2
002A02  241A43     MOV #0x41A4, W3
002A04  07F49B     RCALL 0x133C
002A06  BE0400     MOV.D W0, W8
002A08  804070     MOV tVal, W0
002A0A  804081     MOV 0x810, W1
002A0C  BE0100     MOV.D W0, W2
002A0E  240000     MOV #0x4000, W0
002A10  2459C1     MOV #0x459C, W1
002A12  07F35F     RCALL 0x10D2
002A14  200002     MOV #0x0, W2
002A16  2447A3     MOV #0x447A, W3
002A18  07F3BA     RCALL 0x118E
002A1A  BE0100     MOV.D W0, W2
002A1C  BE0008     MOV.D W8, W0
002A1E  07F3B7     RCALL 0x118E
002A20  884050     MOV W0, ActualTermistorValue
002A22  884061     MOV W1, 0x80C
70:                        ActualTecTemperature = GetTemperatureFromTable();
002A24  070139     RCALL GetTemperatureFromTable
002A26  884030     MOV W0, ActualTecTemperature
002A28  884041     MOV W1, 0x808
71:                        Devices.TecTemperatureValueIsReady = 1;
002A2A  A8C876     BSET Devices, #6
72:                    }
73:                
74:                    if (Devices2.TecVoltageUpdateByVoltage) {
002A2C  8045C0     MOV 0x8B8, W0
002A2E  600062     AND W0, #0x2, W0
002A30  E00000     CP0 W0
002A32  32000F     BRA Z, 0x2A52
75:                        SetTECVoltage((float) TECVoltage / 1000);
002A34  804010     MOV TECVoltage, W0
002A36  EB0080     CLR W1
002A38  07F42C     RCALL 0x1292
002A3A  200002     MOV #0x0, W2
002A3C  2447A3     MOV #0x447A, W3
002A3E  07F3A7     RCALL 0x118E
002A40  0700EE     RCALL SetTECVoltage
76:                        if (Devices.TecIsEnabled)TEC_ENABLE = SET;
002A42  8043B0     MOV Devices, W0
002A44  600061     AND W0, #0x1, W0
002A46  E00000     CP0 W0
002A48  320002     BRA Z, 0x2A4E
002A4A  A8E2C5     BSET 0x2C5, #7
002A4C  370001     BRA 0x2A50
77:                        else TEC_ENABLE = CLEAR;
002A4E  A9E2C5     BCLR 0x2C5, #7
78:                        Devices2.TecVoltageUpdateByVoltage = FALSE;
002A50  A928B8     BCLR 0x8B8, #1
79:                    }
80:                
81:                    switch (current_tec_task) {
002A52  804020     MOV current_tec_task, W0
002A54  500FE1     SUB W0, #0x1, [W15]
002A56  320015     BRA Z, 0x2A82
002A58  500FE1     SUB W0, #0x1, [W15]
002A5A  390005     BRA NC, 0x2A66
002A5C  500FE2     SUB W0, #0x2, [W15]
002A5E  32001C     BRA Z, 0x2A98
002A60  500FE3     SUB W0, #0x3, [W15]
002A62  320023     BRA Z, 0x2AAA
002A64  37005D     BRA 0x2B20
82:                        case TEC_PID_INIT:
83:                            kp = 0.7;
002A66  233330     MOV #0x3333, W0
002A68  23F331     MOV #0x3F33, W1
002A6A  884150     MOV W0, kp
002A6C  884161     MOV W1, 0x82C
84:                            ki = 0.1;
002A6E  2CCCD0     MOV #0xCCCD, W0
002A70  23DCC1     MOV #0x3DCC, W1
002A72  884170     MOV W0, ki
002A74  884181     MOV W1, 0x830
85:                            kd = 0.0;
002A76  B80060     MUL.UU W0, #0, W0
002A78  884190     MOV W0, kd
002A7A  8841A1     MOV W1, 0x834
86:                            current_tec_task = TEC_TASK_INIT;
002A7C  200010     MOV #0x1, W0
002A7E  884020     MOV W0, current_tec_task
87:                            break;
002A80  37004F     BRA 0x2B20
88:                
89:                        case TEC_TASK_INIT:
90:                            if ((Devices.TecIsEnabled) && (!TECVoltage)) {
002A82  8043B0     MOV Devices, W0
002A84  600061     AND W0, #0x1, W0
002A86  E00000     CP0 W0
002A88  320046     BRA Z, 0x2B16
002A8A  804010     MOV TECVoltage, W0
002A8C  E00000     CP0 W0
002A8E  3A0045     BRA NZ, 0x2B1A
91:                                TEC_ENABLE = SET;
002A90  A8E2C5     BSET 0x2C5, #7
92:                                current_tec_task = TEC_TASK_WORK;
002A92  200020     MOV #0x2, W0
002A94  884020     MOV W0, current_tec_task
93:                            }
94:                            break;
002A96  370044     BRA 0x2B20
002B16  000000     NOP
002B18  370003     BRA 0x2B20
002B1A  000000     NOP
002B1C  370001     BRA 0x2B20
95:                
96:                        case TEC_TASK_WORK:
97:                            if (Devices.TecTemperatureValueIsReady) {
002A98  8043B1     MOV Devices, W1
002A9A  200400     MOV #0x40, W0
002A9C  608000     AND W1, W0, W0
002A9E  E00000     CP0 W0
002AA0  32003E     BRA Z, 0x2B1E
98:                                Devices.TecTemperatureValueIsReady = 0;
002AA2  A9C876     BCLR Devices, #6
99:                                current_tec_task = TEC_TASK_PID_IN_PROGRESS;
002AA4  200030     MOV #0x3, W0
002AA6  884020     MOV W0, current_tec_task
100:                           }
101:                           break;
002AA8  37003B     BRA 0x2B20
002B1E  000000     NOP
102:               
103:                       case TEC_TASK_PID_IN_PROGRESS:
104:                           if (Devices.TecIsEnabled) {
002AAA  8043B0     MOV Devices, W0
002AAC  600061     AND W0, #0x1, W0
002AAE  E00000     CP0 W0
002AB0  32002E     BRA Z, 0x2B0E
105:                               Input = ActualTecTemperature;
002AB2  804030     MOV ActualTecTemperature, W0
002AB4  804041     MOV 0x808, W1
002AB6  8840B0     MOV W0, Input
002AB8  8840C1     MOV W1, 0x818
106:                               PidCompute();
002ABA  07005B     RCALL PidCompute
107:                               if (Output < -3) {
002ABC  8040D0     MOV Output, W0
002ABE  8040E1     MOV 0x81C, W1
002AC0  B3C018     MOV.B #0x1, W8
002AC2  200002     MOV #0x0, W2
002AC4  2C0403     MOV #0xC040, W3
002AC6  07F3A5     RCALL 0x1212
002AC8  E00000     CP0 W0
002ACA  350001     BRA LT, 0x2ACE
002ACC  EB4400     CLR.B W8
002ACE  E00408     CP0.B W8
002AD0  320018     BRA Z, 0x2B02
108:                                   tVal = Output * (-1);
002AD2  8040D0     MOV Output, W0
002AD4  8040E1     MOV 0x81C, W1
002AD6  A2F001     BTG W1, #15
002AD8  884070     MOV W0, tVal
002ADA  884081     MOV W1, 0x810
109:                                   if (tVal > 15.6) {
002ADC  804070     MOV tVal, W0
002ADE  804081     MOV 0x810, W1
002AE0  B3C018     MOV.B #0x1, W8
002AE2  2999A2     MOV #0x999A, W2
002AE4  241793     MOV #0x4179, W3
002AE6  07F397     RCALL 0x1216
002AE8  E00000     CP0 W0
002AEA  3C0001     BRA GT, 0x2AEE
002AEC  EB4400     CLR.B W8
002AEE  E00408     CP0.B W8
002AF0  320004     BRA Z, 0x2AFA
110:                                       tVal = 15.6;
002AF2  2999A0     MOV #0x999A, W0
002AF4  241791     MOV #0x4179, W1
002AF6  884070     MOV W0, tVal
002AF8  884081     MOV W1, 0x810
111:                                   }
112:                                   SetTECVoltage(tVal);
002AFA  804070     MOV tVal, W0
002AFC  804081     MOV 0x810, W1
002AFE  07008F     RCALL SetTECVoltage
002B00  370001     BRA 0x2B04
113:               
114:                               } else {
115:                                   TEC_ENABLE = DISABLE;
002B02  A9E2C5     BCLR 0x2C5, #7
116:                               }
117:                               Devices2.InfoDataReadyToSend = 1;
002B04  A868B8     BSET 0x8B8, #3
118:                               current_tec_task = TEC_TASK_WORK;
002B06  200020     MOV #0x2, W0
002B08  884020     MOV W0, current_tec_task
119:                               Nop();
002B0A  000000     NOP
120:                           } else {
121:                               TEC_ENABLE = CLEAR;
002B0E  A9E2C5     BCLR 0x2C5, #7
122:                               Devices.TecIsEnabled = FALSE;
002B10  A90876     BCLR Devices, #0
123:                               current_tec_task = TEC_PID_INIT;
002B12  EF2804     CLR current_tec_task
124:               
125:                           }
126:                           break;
002B0C  370009     BRA 0x2B20
002B14  370005     BRA 0x2B20
127:                   }
128:               
129:                   if (TecVoltageSensingTimer > TEC_V_SENS_TIME) {
002B20  8044C1     MOV TecVoltageSensingTimer, W1
002B22  2012C0     MOV #0x12C, W0
002B24  508F80     SUB W1, W0, [W15]
002B26  360022     BRA LEU, 0x2B6C
130:                       TecVoltageSensingTimer = 0;
002B28  EF2898     CLR TecVoltageSensingTimer
131:                       while (!CommFlags.SPI1RxDone);
002B2A  000000     NOP
002B2C  8045B0     MOV 0x8B6, W0
002B2E  600064     AND W0, #0x4, W0
002B30  E00000     CP0 W0
002B32  32FFFC     BRA Z, 0x2B2C
132:                       TEC_SPI_EN = HIGH;
002B34  A842DD     BSET 0x2DD, #2
133:                       CS_ADC_TEC = LOW;
002B36  A922DD     BCLR 0x2DD, #1
134:                       i = SPIReadWriteWord(MCP3002_CH0);
002B38  2C0000     MOV #0xC000, W0
002B3A  07FCDF     RCALL SPIReadWriteWord
002B3C  780F00     MOV W0, [W14]
135:                       i >>= 1;
002B3E  78001E     MOV [W14], W0
002B40  D10000     LSR W0, W0
002B42  780F00     MOV W0, [W14]
136:                       TecCurrentMonoitor = (TecCurrentMonoitor + i) / 2; //i tec
002B44  8041C0     MOV TecCurrentMonoitor, W0
002B46  40001E     ADD W0, [W14], W0
002B48  D10000     LSR W0, W0
002B4A  8841C0     MOV W0, TecCurrentMonoitor
137:                       CS_ADC_TEC = HIGH;
002B4C  A822DD     BSET 0x2DD, #1
138:                       TEC_SPI_EN = LOW;
002B4E  A942DD     BCLR 0x2DD, #2
139:               
140:                       TEC_SPI_EN = HIGH;
002B50  A842DD     BSET 0x2DD, #2
141:                       CS_ADC_TEC = LOW;
002B52  A922DD     BCLR 0x2DD, #1
142:                       i = SPIReadWriteWord(MCP3002_CH1);
002B54  2E0000     MOV #0xE000, W0
002B56  07FCD1     RCALL SPIReadWriteWord
002B58  780F00     MOV W0, [W14]
143:                       i >>= 1;
002B5A  78001E     MOV [W14], W0
002B5C  D10000     LSR W0, W0
002B5E  780F00     MOV W0, [W14]
144:                       TecVoltageMonitor = (TecVoltageMonitor + i) / 2; //v tec
002B60  8041B0     MOV TecVoltageMonitor, W0
002B62  40001E     ADD W0, [W14], W0
002B64  D10000     LSR W0, W0
002B66  8841B0     MOV W0, TecVoltageMonitor
145:                       CS_ADC_TEC = HIGH;
002B68  A822DD     BSET 0x2DD, #1
146:                       TEC_SPI_EN = LOW;
002B6A  A942DD     BCLR 0x2DD, #2
147:                   }
148:               }
002B6C  BE044F     MOV.D [--W15], W8
002B6E  FA8000     ULNK
002B70  060000     RETURN
149:               
150:               void PidCompute(void) {
002B72  FA0008     LNK #0x8
002B74  BE9F88     MOV.D W8, [W15++]
151:                   double error = Setpoint - Input;
002B76  8040F4     MOV Setpoint, W4
002B78  804105     MOV 0x820, W5
002B7A  8040B0     MOV Input, W0
002B7C  8040C1     MOV 0x818, W1
002B7E  BE0100     MOV.D W0, W2
002B80  BE0004     MOV.D W4, W0
002B82  07F2A7     RCALL 0x10D2
002B84  BE8F00     MOV.D W0, [W14]
152:                   errSum += error;
002B86  804110     MOV errSum, W0
002B88  804121     MOV 0x824, W1
002B8A  BE011E     MOV.D [W14], W2
002B8C  07F2A3     RCALL 0x10D4
002B8E  884110     MOV W0, errSum
002B90  884121     MOV W1, 0x824
153:                   if (errSum > 120)errSum = 120;
002B92  804110     MOV errSum, W0
002B94  804121     MOV 0x824, W1
002B96  B3C018     MOV.B #0x1, W8
002B98  200002     MOV #0x0, W2
002B9A  242F03     MOV #0x42F0, W3
002B9C  07F33C     RCALL 0x1216
002B9E  E00000     CP0 W0
002BA0  3C0001     BRA GT, 0x2BA4
002BA2  EB4400     CLR.B W8
002BA4  E00408     CP0.B W8
002BA6  320005     BRA Z, 0x2BB2
002BA8  200000     MOV #0x0, W0
002BAA  242F01     MOV #0x42F0, W1
002BAC  884110     MOV W0, errSum
002BAE  884121     MOV W1, 0x824
002BB0  37000F     BRA 0x2BD0
154:                   else if (errSum < -120)errSum = -120;
002BB2  804110     MOV errSum, W0
002BB4  804121     MOV 0x824, W1
002BB6  B3C018     MOV.B #0x1, W8
002BB8  200002     MOV #0x0, W2
002BBA  2C2F03     MOV #0xC2F0, W3
002BBC  07F32A     RCALL 0x1212
002BBE  E00000     CP0 W0
002BC0  350001     BRA LT, 0x2BC4
002BC2  EB4400     CLR.B W8
002BC4  E00408     CP0.B W8
002BC6  320004     BRA Z, 0x2BD0
002BC8  200000     MOV #0x0, W0
002BCA  2C2F01     MOV #0xC2F0, W1
002BCC  884110     MOV W0, errSum
002BCE  884121     MOV W1, 0x824
155:                   double dErr = error - lastErr; /*Compute PID Output*/
002BD0  804130     MOV lastErr, W0
002BD2  804141     MOV 0x828, W1
002BD4  BE0100     MOV.D W0, W2
002BD6  BE001E     MOV.D [W14], W0
002BD8  07F27C     RCALL 0x10D2
002BDA  980720     MOV W0, [W14+4]
002BDC  980731     MOV W1, [W14+6]
156:                   Output = kp * error + ki * errSum + kd * dErr;
002BDE  804150     MOV kp, W0
002BE0  804161     MOV 0x82C, W1
002BE2  BE011E     MOV.D [W14], W2
002BE4  07F3AB     RCALL 0x133C
002BE6  BE0400     MOV.D W0, W8
002BE8  804174     MOV ki, W4
002BEA  804185     MOV 0x830, W5
002BEC  804110     MOV errSum, W0
002BEE  804121     MOV 0x824, W1
002BF0  BE0100     MOV.D W0, W2
002BF2  BE0004     MOV.D W4, W0
002BF4  07F3A3     RCALL 0x133C
002BF6  BE0100     MOV.D W0, W2
002BF8  BE0008     MOV.D W8, W0
002BFA  07F26C     RCALL 0x10D4
002BFC  BE0400     MOV.D W0, W8
002BFE  804190     MOV kd, W0
002C00  8041A1     MOV 0x834, W1
002C02  90012E     MOV [W14+4], W2
002C04  9001BE     MOV [W14+6], W3
002C06  07F39A     RCALL 0x133C
002C08  BE0100     MOV.D W0, W2
002C0A  BE0008     MOV.D W8, W0
002C0C  07F263     RCALL 0x10D4
002C0E  8840D0     MOV W0, Output
002C10  8840E1     MOV W1, 0x81C
157:                   lastErr = error; /*Remember some variables for next time*/
002C12  BE011E     MOV.D [W14], W2
002C14  884132     MOV W2, lastErr
002C16  884143     MOV W3, 0x828
158:               }
002C18  BE044F     MOV.D [--W15], W8
002C1A  FA8000     ULNK
002C1C  060000     RETURN
159:               
160:               void SetTECVoltage(float Voltage) {
002C1E  FA0006     LNK #0x6
002C20  781F88     MOV W8, [W15++]
002C22  980710     MOV W0, [W14+2]
002C24  980721     MOV W1, [W14+4]
161:                   u16 Val;
162:               
163:                   Voltage = (21.69 - Voltage) / 4.026 / 0.00488;
002C26  90011E     MOV [W14+2], W2
002C28  9001AE     MOV [W14+4], W3
002C2A  2851F0     MOV #0x851F, W0
002C2C  241AD1     MOV #0x41AD, W1
002C2E  07F251     RCALL 0x10D2
002C30  2D4FE2     MOV #0xD4FE, W2
002C32  240803     MOV #0x4080, W3
002C34  07F2AC     RCALL 0x118E
002C36  2E8682     MOV #0xE868, W2
002C38  23B9F3     MOV #0x3B9F, W3
002C3A  07F2A9     RCALL 0x118E
002C3C  980710     MOV W0, [W14+2]
002C3E  980721     MOV W1, [W14+4]
164:                   if (Voltage > 1023)Voltage = 1023;
002C40  B3C018     MOV.B #0x1, W8
002C42  2C0002     MOV #0xC000, W2
002C44  2447F3     MOV #0x447F, W3
002C46  90001E     MOV [W14+2], W0
002C48  9000AE     MOV [W14+4], W1
002C4A  07F2E5     RCALL 0x1216
002C4C  E00000     CP0 W0
002C4E  3C0001     BRA GT, 0x2C52
002C50  EB4400     CLR.B W8
002C52  E00408     CP0.B W8
002C54  320004     BRA Z, 0x2C5E
002C56  2C0000     MOV #0xC000, W0
002C58  2447F1     MOV #0x447F, W1
002C5A  980710     MOV W0, [W14+2]
002C5C  980721     MOV W1, [W14+4]
165:                   Val = (int) Voltage;
002C5E  90001E     MOV [W14+2], W0
002C60  9000AE     MOV [W14+4], W1
002C62  07F2DB     RCALL 0x121A
002C64  780000     MOV W0, W0
002C66  780F00     MOV W0, [W14]
166:                   Val <<= 2;
002C68  78001E     MOV [W14], W0
002C6A  DD0042     SL W0, #2, W0
002C6C  780F00     MOV W0, [W14]
167:                   Val = 0x1000 + Val;
002C6E  210000     MOV #0x1000, W0
002C70  400F1E     ADD W0, [W14], [W14]
168:                   while (!CommFlags.SPI1RxDone);
002C72  000000     NOP
002C74  8045B0     MOV 0x8B6, W0
002C76  600064     AND W0, #0x4, W0
002C78  E00000     CP0 W0
002C7A  32FFFC     BRA Z, 0x2C74
169:                   TEC_SPI_EN = HIGH;
002C7C  A842DD     BSET 0x2DD, #2
170:                   CS_TEC_DAC = LOW;
002C7E  A902DD     BCLR 0x2DD, #0
171:                   SPIReadWriteWord(Val);
002C80  78001E     MOV [W14], W0
002C82  07FC3B     RCALL SPIReadWriteWord
172:                   CS_TEC_DAC = HIGH;
002C84  A802DD     BSET 0x2DD, #0
173:                   TEC_SPI_EN = LOW;
002C86  A942DD     BCLR 0x2DD, #2
174:                   if (Devices.TecIsEnabled == TRUE)TEC_ENABLE = ENABLE;
002C88  8043B0     MOV Devices, W0
002C8A  600061     AND W0, #0x1, W0
002C8C  E00000     CP0 W0
002C8E  320001     BRA Z, 0x2C92
002C90  A8E2C5     BSET 0x2C5, #7
175:               
176:               }
002C92  78044F     MOV [--W15], W8
002C94  FA8000     ULNK
002C96  060000     RETURN
177:               
178:               float GetTemperatureFromTable() {
002C98  FA000E     LNK #0xE
002C9A  BE9F88     MOV.D W8, [W15++]
179:                   float ReturnTemperature;
180:                   u16 i;
181:                   float a, b;
182:               
183:                   for (i = 0; i < 51; i++) {
002C9C  EB0000     CLR W0
002C9E  980720     MOV W0, [W14+4]
002CA0  370069     BRA 0x2D74
002D6E  90002E     MOV [W14+4], W0
002D70  E80000     INC W0, W0
002D72  980720     MOV W0, [W14+4]
002D74  9000AE     MOV [W14+4], W1
002D76  200320     MOV #0x32, W0
002D78  508F80     SUB W1, W0, [W15]
002D7A  36FF93     BRA LEU, 0x2CA2
184:                       if (TempTable[i][1] == ActualTermistorValue) {
002CA2  90002E     MOV [W14+4], W0
002CA4  DD0043     SL W0, #3, W0
002CA6  4000E4     ADD W0, #0x4, W1
002CA8  294580     MOV #0x9458, W0
002CAA  408000     ADD W1, W0, W0
002CAC  BE0210     MOV.D [W0], W4
002CAE  804050     MOV ActualTermistorValue, W0
002CB0  804061     MOV 0x80C, W1
002CB2  BE0100     MOV.D W0, W2
002CB4  BE0004     MOV.D W4, W0
002CB6  07F2AD     RCALL 0x1212
002CB8  E00000     CP0 W0
002CBA  3A0007     BRA NZ, 0x2CCA
185:                           ReturnTemperature = TempTable[i][0];
002CBC  90002E     MOV [W14+4], W0
002CBE  DD00C3     SL W0, #3, W1
002CC0  294580     MOV #0x9458, W0
002CC2  408000     ADD W1, W0, W0
002CC4  781F30     MOV [W0++], [W14++]
002CC6  781720     MOV [W0--], [W14--]
186:                           break;
002CC8  370059     BRA 0x2D7C
187:                       } else if (TempTable[i][1] < ActualTermistorValue) {
002CCA  90002E     MOV [W14+4], W0
002CCC  DD0043     SL W0, #3, W0
002CCE  4000E4     ADD W0, #0x4, W1
002CD0  294580     MOV #0x9458, W0
002CD2  408000     ADD W1, W0, W0
002CD4  BE0210     MOV.D [W0], W4
002CD6  804050     MOV ActualTermistorValue, W0
002CD8  804061     MOV 0x80C, W1
002CDA  B3C018     MOV.B #0x1, W8
002CDC  BE0100     MOV.D W0, W2
002CDE  BE0004     MOV.D W4, W0
002CE0  07F298     RCALL 0x1212
002CE2  E00000     CP0 W0
002CE4  350001     BRA LT, 0x2CE8
002CE6  EB4400     CLR.B W8
002CE8  E00408     CP0.B W8
002CEA  320041     BRA Z, 0x2D6E
188:                           a = (TempTable[i - 1][1] - TempTable[i][1]) / (TempTable[i - 1][0] - TempTable[i][0]);
002CEC  90002E     MOV [W14+4], W0
002CEE  E90000     DEC W0, W0
002CF0  DD0043     SL W0, #3, W0
002CF2  4000E4     ADD W0, #0x4, W1
002CF4  294580     MOV #0x9458, W0
002CF6  408000     ADD W1, W0, W0
002CF8  BE0210     MOV.D [W0], W4
002CFA  90002E     MOV [W14+4], W0
002CFC  DD0043     SL W0, #3, W0
002CFE  4000E4     ADD W0, #0x4, W1
002D00  294580     MOV #0x9458, W0
002D02  408000     ADD W1, W0, W0
002D04  BE0010     MOV.D [W0], W0
002D06  BE0100     MOV.D W0, W2
002D08  BE0004     MOV.D W4, W0
002D0A  07F1E3     RCALL 0x10D2
002D0C  BE0400     MOV.D W0, W8
002D0E  90002E     MOV [W14+4], W0
002D10  E90000     DEC W0, W0
002D12  DD00C3     SL W0, #3, W1
002D14  294580     MOV #0x9458, W0
002D16  408000     ADD W1, W0, W0
002D18  BE0210     MOV.D [W0], W4
002D1A  90002E     MOV [W14+4], W0
002D1C  DD00C3     SL W0, #3, W1
002D1E  294580     MOV #0x9458, W0
002D20  408000     ADD W1, W0, W0
002D22  BE0010     MOV.D [W0], W0
002D24  BE0100     MOV.D W0, W2
002D26  BE0004     MOV.D W4, W0
002D28  07F1D4     RCALL 0x10D2
002D2A  BE0100     MOV.D W0, W2
002D2C  BE0008     MOV.D W8, W0
002D2E  07F22F     RCALL 0x118E
002D30  980730     MOV W0, [W14+6]
002D32  980741     MOV W1, [W14+8]
189:                           b = TempTable[i][1]-(a * TempTable[i][0]);
002D34  90002E     MOV [W14+4], W0
002D36  DD0043     SL W0, #3, W0
002D38  4000E4     ADD W0, #0x4, W1
002D3A  294580     MOV #0x9458, W0
002D3C  408000     ADD W1, W0, W0
002D3E  BE0410     MOV.D [W0], W8
002D40  90002E     MOV [W14+4], W0
002D42  DD00C3     SL W0, #3, W1
002D44  294580     MOV #0x9458, W0
002D46  408000     ADD W1, W0, W0
002D48  BE0010     MOV.D [W0], W0
002D4A  90013E     MOV [W14+6], W2
002D4C  9001CE     MOV [W14+8], W3
002D4E  07F2F6     RCALL 0x133C
002D50  BE0100     MOV.D W0, W2
002D52  BE0008     MOV.D W8, W0
002D54  07F1BE     RCALL 0x10D2
002D56  980750     MOV W0, [W14+10]
002D58  980761     MOV W1, [W14+12]
190:                           ReturnTemperature = (ActualTermistorValue - b) / a;
002D5A  804050     MOV ActualTermistorValue, W0
002D5C  804061     MOV 0x80C, W1
002D5E  90015E     MOV [W14+10], W2
002D60  9001EE     MOV [W14+12], W3
002D62  07F1B7     RCALL 0x10D2
002D64  90013E     MOV [W14+6], W2
002D66  9001CE     MOV [W14+8], W3
002D68  07F212     RCALL 0x118E
002D6A  BE8F00     MOV.D W0, [W14]
191:                           break;
002D6C  370007     BRA 0x2D7C
192:                       }
193:                   }
194:                   return ReturnTemperature;
002D7C  BE001E     MOV.D [W14], W0
195:               }
002D7E  BE044F     MOV.D [--W15], W8
002D80  FA8000     ULNK
002D82  060000     RETURN
196:               
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/system.c
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                
17:                #include <stdint.h>          /* For uint16_t definition                       */
18:                #include <stdbool.h>         /* For true/false definition                     */
19:                
20:                #include "system.h"          /* variables/params used by system.c             */
21:                
22:                /******************************************************************************/
23:                /* System Level Functions                                                     */
24:                /*                                                                            */
25:                /* Custom oscillator configuration funtions, reset source evaluation          */
26:                /* functions, and other non-peripheral microcontroller initialization         */
27:                /* functions get placed in system.c.                                          */
28:                /*                                                                            */
29:                /******************************************************************************/
30:                
31:                /* Refer to the device Family Reference Manual Oscillator section for
32:                information about available oscillator configurations.  Typically
33:                this would involve configuring the oscillator tuning register or clock
34:                switching useing the compiler's __builtin_write_OSCCON functions.
35:                Refer to the C Compiler for PIC24 MCUs and dsPIC DSCs User Guide in the
36:                compiler installation directory /doc folder for documentation on the
37:                __builtin functions.*/
38:                
39:                void ConfigureOscillator(void) {
0037E2  FA0000     LNK #0x0
40:                    PLLFBD = 38; // M=PLLFBD+2 -> M = 40
0037E4  200260     MOV #0x26, W0
0037E6  883A30     MOV W0, PLLFBD
41:                    CLKDIVbits.PLLPOST = 0; // N1=CLKDIVbits.PLLPOST+2 -> N1 = 2
0037E8  803A20     MOV CLKDIV, W0
0037EA  A16000     BCLR W0, #6
0037EC  A17000     BCLR W0, #7
0037EE  883A20     MOV W0, CLKDIV
42:                    CLKDIVbits.PLLPRE = 0; //N2=CLKDIVbits.PLLPRE+2 -> N2 = 2
0037F0  803A21     MOV CLKDIV, W1
0037F2  2FFE00     MOV #0xFFE0, W0
0037F4  608000     AND W1, W0, W0
0037F6  883A20     MOV W0, CLKDIV
43:                    OSCTUN = 0;
0037F8  EF2748     CLR OSCTUN
44:                    RCONbits.SWDTEN = 0;
0037FA  A9A740     BCLR RCON, #5
45:                
46:                    ACLKCONbits.FRCSEL = 1; /* FRC provides input for Auxiliary PLL (x16) */
0037FC  A8C750     BSET ACLKCON, #6
47:                    ACLKCONbits.SELACLK = 1; /* Auxiliary Oscillator provides clock source for PWM & ADC */
0037FE  A8A751     BSET 0x751, #5
48:                    ACLKCONbits.APSTSCLR = 7; /* Divide Auxiliary clock by 256 */
003800  803A80     MOV ACLKCON, W0
003802  A08000     BSET W0, #8
003804  A09000     BSET W0, #9
003806  A0A000     BSET W0, #10
003808  883A80     MOV W0, ACLKCON
49:                    ACLKCONbits.ENAPLL = 1; /* Enable Auxiliary PLL */
00380A  A8E751     BSET 0x751, #7
50:                    while (ACLKCONbits.APLLCK != 1); /* Wait for Auxiliary PLL to Lock */
00380C  000000     NOP
00380E  803A81     MOV ACLKCON, W1
003810  240000     MOV #0x4000, W0
003812  608000     AND W1, W0, W0
003814  E00000     CP0 W0
003816  32FFFB     BRA Z, 0x380E
51:                #if 0
52:                    /* Disable Watch Dog Timer */
53:                    RCONbits.SWDTEN = 0;
54:                
55:                    /* When clock switch occurs switch to Primary Osc (HS, XT, EC) */
56:                    __builtin_write_OSCCONH(0x02); /* Set OSCCONH for clock switch */
57:                    __builtin_write_OSCCONL(0x01); /* Start clock switching */
58:                    while (OSCCONbits.COSC != 0b011);
59:                
60:                    /* Wait for Clock switch to occur */
61:                    /* Wait for PLL to lock, only if PLL is needed */
62:                    /* while(OSCCONbits.LOCK != 1); */
63:                #endif
64:                }
003818  FA8000     ULNK
00381A  060000     RETURN
65:                
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/pump.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"          /* User funct/params, such as InitApp              */
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define PUMP_STARTUP            0//
20:                #define PUMP_ON_TASK            1
21:                #define WAIT_FOR_FLOW           2
22:                #define CHECK_FLOW              3//
23:                #define WAIT_FLOW_BOUNCING      4//
24:                #define PUMP_OFF_TASK           5//
25:                #define PUMP_SYSTEM_FAULT       6//
26:                #define WAIT_FOR_STARTUP        7//
27:                #define INIT_PUMP_TASK          8//
28:                #define PUMP_TECHMODE           9
29:                
30:                #define PUMP_V_SENS_TIME        200//sens pump voltage every 2sec
31:                /*================================================*/
32:                
33:                /*================= Variables ===============================*/
34:                u16 PumpVoltage = 0;
35:                u16 current_pump_task = INIT_PUMP_TASK;
36:                u16 PumpTimer = 0;
37:                u16 PumpVoltageMonitor = 818;
38:                
39:                extern u16 PumpVoltageSensingTimer;
40:                extern u16 SystemStateToUpdate;
41:                /*================================================*/
42:                
43:                /*================= Functions ===============================*/
44:                void SetPumpVoltage(u16 Voltage);
45:                void pump_tasks(void);
46:                void PumpFault(void);
47:                
48:                extern u16 SPIReadWriteWord(u16 WordVar);
49:                
50:                /*================================================*/
51:                
52:                /**********************************************************************
53:                 * Function:        void SetPumpVoltage(u16 Voltage)
54:                 * PreCondition:    None
55:                 * Input:	    Voltage - set volage for pump driver
56:                 * Output:	    None
57:                 * Overview:	    This function used to calculate and send to SPI module the voltage for pump driver
58:                 *
59:                 ***********************************************************************/
60:                void SetPumpVoltage(u16 Voltage) {
0032EA  FA0002     LNK #0x2
0032EC  780F00     MOV W0, [W14]
61:                    Voltage <<= 2;
0032EE  78001E     MOV [W14], W0
0032F0  DD0042     SL W0, #2, W0
0032F2  780F00     MOV W0, [W14]
62:                    Voltage = 0x1000 + Voltage;
0032F4  210000     MOV #0x1000, W0
0032F6  400F1E     ADD W0, [W14], [W14]
63:                    while (!CommFlags.SPI1RxDone);
0032F8  000000     NOP
0032FA  8045B0     MOV 0x8B6, W0
0032FC  600064     AND W0, #0x4, W0
0032FE  E00000     CP0 W0
003300  32FFFC     BRA Z, 0x32FA
64:                    PUMP_SPI_EN = HIGH;
003302  A862DD     BSET 0x2DD, #3
65:                    pCS_DAC = LOW;
003304  A902DC     BCLR LATD, #0
66:                    if (PumpVoltage > 1023)PumpVoltage = 1023;
003306  804681     MOV PumpVoltage, W1
003308  203FF0     MOV #0x3FF, W0
00330A  508F80     SUB W1, W0, [W15]
00330C  360002     BRA LEU, 0x3312
00330E  203FF0     MOV #0x3FF, W0
003310  884680     MOV W0, PumpVoltage
67:                    SPIReadWriteWord(Voltage);
003312  78001E     MOV [W14], W0
003314  07F8F2     RCALL SPIReadWriteWord
68:                    pCS_DAC = HIGH;
003316  A802DC     BSET LATD, #0
69:                    PUMP_SPI_EN = LOW;
003318  A962DD     BCLR 0x2DD, #3
70:                }
00331A  FA8000     ULNK
00331C  060000     RETURN
71:                
72:                /**********************************************************************
73:                 * Function:        void SetPumpVoltage(u16 Voltage)
74:                 * PreCondition:    None
75:                 * Input:	    Voltage - set volage for pump driver
76:                 * Output:	    None
77:                 * Overview:	    This function used to calculate and send to SPI module the voltage for pump driver
78:                 *
79:                 ***********************************************************************/
80:                void pump_tasks(void) {
00331E  FA0002     LNK #0x2
81:                    u16 val;
82:                    if (Devices.PumpVoltageUpdate) {
003320  8043B0     MOV Devices, W0
003322  600070     AND W0, #0x10, W0
003324  E00000     CP0 W0
003326  320008     BRA Z, 0x3338
83:                        if (!Devices.PumpIsEnabled)PumpVoltage = 0;
003328  8043B0     MOV Devices, W0
00332A  600064     AND W0, #0x4, W0
00332C  E00000     CP0 W0
00332E  3A0001     BRA NZ, 0x3332
003330  EF28D0     CLR PumpVoltage
84:                        SetPumpVoltage(PumpVoltage);
003332  804680     MOV PumpVoltage, W0
003334  07FFDA     RCALL SetPumpVoltage
85:                        Devices.PumpVoltageUpdate = FALSE;
003336  A98876     BCLR Devices, #4
86:                    }
87:                
88:                    switch (current_pump_task) {
003338  8046A0     MOV 0x8D4, W0
00333A  500FE5     SUB W0, #0x5, [W15]
00333C  320071     BRA Z, 0x3420
00333E  500FE5     SUB W0, #0x5, [W15]
003340  3E0007     BRA GTU, 0x3350
003342  500FE3     SUB W0, #0x3, [W15]
003344  320042     BRA Z, 0x33CA
003346  500FE3     SUB W0, #0x3, [W15]
003348  3E0053     BRA GTU, 0x33F0
00334A  E00000     CP0 W0
00334C  320022     BRA Z, 0x3392
00334E  370086     BRA 0x345C
003350  500FE7     SUB W0, #0x7, [W15]
003352  320010     BRA Z, 0x3374
003354  500FE7     SUB W0, #0x7, [W15]
003356  390077     BRA NC, 0x3446
003358  500FE8     SUB W0, #0x8, [W15]
00335A  3A0080     BRA NZ, 0x345C
89:                        case INIT_PUMP_TASK:
90:                            PUMP_SPI_EN = HIGH;
00335C  A862DD     BSET 0x2DD, #3
91:                            CS_ADC_PUMP = LOW;
00335E  A9A2D5     BCLR 0x2D5, #5
92:                            val = SPIReadWriteWord(MCP3002_CH1);
003360  2E0000     MOV #0xE000, W0
003362  07F8CB     RCALL SPIReadWriteWord
003364  780F00     MOV W0, [W14]
93:                            CS_ADC_PUMP = HIGH;
003366  A8A2D5     BSET 0x2D5, #5
94:                            PUMP_SPI_EN = LOW;
003368  A962DD     BCLR 0x2DD, #3
95:                            SetPumpVoltage(0);
00336A  EB0000     CLR W0
00336C  07FFBE     RCALL SetPumpVoltage
96:                            current_pump_task = WAIT_FOR_STARTUP;
00336E  200070     MOV #0x7, W0
003370  8846A0     MOV W0, 0x8D4
97:                            break;
003372  370074     BRA 0x345C
98:                
99:                        case WAIT_FOR_STARTUP:
100:                           if (Devices.PumpIsEnabled) {
003374  8043B0     MOV Devices, W0
003376  600064     AND W0, #0x4, W0
003378  E00000     CP0 W0
00337A  320005     BRA Z, 0x3386
101:               #ifndef __BLACKBOX
102:                               SetPumpVoltage(900); //set pump max speed
00337C  203840     MOV #0x384, W0
00337E  07FFB5     RCALL SetPumpVoltage
103:               #endif
104:                               PumpTimer = 0; //reset timer
003380  EF28D2     CLR PumpTimer
105:                               current_pump_task = PUMP_STARTUP;
003382  EF28D4     CLR 0x8D4
106:                           } else {
107:                               if (!FLOW_SWITCH)PumpFault();
003386  801610     MOV PORTA, W0
003388  600061     AND W0, #0x1, W0
00338A  E00000     CP0 W0
00338C  3A005E     BRA NZ, 0x344A
00338E  07008A     RCALL PumpFault
108:                           }
109:                           break;
003384  37006B     BRA 0x345C
003390  370065     BRA 0x345C
00344A  000000     NOP
00344C  370007     BRA 0x345C
110:               
111:                       case PUMP_STARTUP:
112:                           if (!FLOW_SWITCH) {
003392  801610     MOV PORTA, W0
003394  600061     AND W0, #0x1, W0
003396  E00000     CP0 W0
003398  3A0011     BRA NZ, 0x33BC
113:                               if (!Devices.PumpIsEnabled) {//check if need pump off
00339A  8043B0     MOV Devices, W0
00339C  600064     AND W0, #0x4, W0
00339E  E00000     CP0 W0
0033A0  3A0007     BRA NZ, 0x33B0
114:                                   SetPumpVoltage(0);
0033A2  EB0000     CLR W0
0033A4  07FFA2     RCALL SetPumpVoltage
115:                                   Devices.PumpIsReady = FALSE;
0033A6  A96876     BCLR Devices, #3
116:                                   PumpTimer = CLEAR;
0033A8  EF28D2     CLR PumpTimer
117:                                   current_pump_task = PUMP_OFF_TASK;
0033AA  200050     MOV #0x5, W0
0033AC  8846A0     MOV W0, 0x8D4
118:                               } else {
119:                                   SetPumpVoltage(500);
0033B0  201F40     MOV #0x1F4, W0
0033B2  07FF9B     RCALL SetPumpVoltage
120:                                   Devices.PumpIsReady = TRUE;
0033B4  A86876     BSET Devices, #3
121:                                   current_pump_task = CHECK_FLOW;
0033B6  200030     MOV #0x3, W0
0033B8  8846A0     MOV W0, 0x8D4
122:                               }
123:                           } else if (PumpTimer > 20000)current_pump_task = PUMP_SYSTEM_FAULT;
0033BC  804691     MOV PumpTimer, W1
0033BE  24E200     MOV #0x4E20, W0
0033C0  508F80     SUB W1, W0, [W15]
0033C2  360045     BRA LEU, 0x344E
0033C4  200060     MOV #0x6, W0
0033C6  8846A0     MOV W0, 0x8D4
124:                           break;
0033AE  370056     BRA 0x345C
0033BA  370050     BRA 0x345C
0033C8  370049     BRA 0x345C
00344E  000000     NOP
003450  370005     BRA 0x345C
125:               
126:                       case CHECK_FLOW:
127:                           if (!Devices.PumpIsEnabled) {//check if need pump off
0033CA  8043B0     MOV Devices, W0
0033CC  600064     AND W0, #0x4, W0
0033CE  E00000     CP0 W0
0033D0  3A0007     BRA NZ, 0x33E0
128:                               SetPumpVoltage(0);
0033D2  EB0000     CLR W0
0033D4  07FF8A     RCALL SetPumpVoltage
129:                               Devices.PumpIsReady = FALSE;
0033D6  A96876     BCLR Devices, #3
130:                               PumpTimer = CLEAR;
0033D8  EF28D2     CLR PumpTimer
131:                               current_pump_task = PUMP_OFF_TASK;
0033DA  200050     MOV #0x5, W0
0033DC  8846A0     MOV W0, 0x8D4
132:                           } else {
133:                               if (FLOW_SWITCH) {//no water
0033E0  801610     MOV PORTA, W0
0033E2  600061     AND W0, #0x1, W0
0033E4  E00000     CP0 W0
0033E6  320035     BRA Z, 0x3452
134:                                   PumpTimer = 0; //reset timer
0033E8  EF28D2     CLR PumpTimer
135:                                   current_pump_task = WAIT_FLOW_BOUNCING; //check after bouncing 
0033EA  200040     MOV #0x4, W0
0033EC  8846A0     MOV W0, 0x8D4
136:                               }
137:                           }
138:                           break;
0033DE  37003E     BRA 0x345C
0033EE  370036     BRA 0x345C
003452  000000     NOP
003454  370003     BRA 0x345C
139:               
140:                       case WAIT_FLOW_BOUNCING:
141:                           if (!FLOW_SWITCH) {
0033F0  801610     MOV PORTA, W0
0033F2  600061     AND W0, #0x1, W0
0033F4  E00000     CP0 W0
0033F6  3A000F     BRA NZ, 0x3416
142:                               if (!Devices.PumpIsEnabled) {//check if need pump off
0033F8  8043B0     MOV Devices, W0
0033FA  600064     AND W0, #0x4, W0
0033FC  E00000     CP0 W0
0033FE  3A0007     BRA NZ, 0x340E
143:                                   SetPumpVoltage(0);
003400  EB0000     CLR W0
003402  07FF73     RCALL SetPumpVoltage
144:                                   Devices.PumpIsReady = FALSE;
003404  A96876     BCLR Devices, #3
145:                                   PumpTimer = CLEAR;
003406  EF28D2     CLR PumpTimer
146:                                   current_pump_task = PUMP_OFF_TASK;
003408  200050     MOV #0x5, W0
00340A  8846A0     MOV W0, 0x8D4
147:                               } else {
148:                                   Devices.PumpIsReady = TRUE;
00340E  A86876     BSET Devices, #3
149:                                   current_pump_task = CHECK_FLOW;
003410  200030     MOV #0x3, W0
003412  8846A0     MOV W0, 0x8D4
150:                               }
151:                           } else if (PumpTimer > 20)PumpFault();
003416  804690     MOV PumpTimer, W0
003418  500FF4     SUB W0, #0x14, [W15]
00341A  36001D     BRA LEU, 0x3456
00341C  070043     RCALL PumpFault
152:                           break;
00340C  370027     BRA 0x345C
003414  370023     BRA 0x345C
00341E  37001E     BRA 0x345C
003456  000000     NOP
003458  370001     BRA 0x345C
153:               
154:                       case PUMP_OFF_TASK:
155:                           if (FLOW_SWITCH)current_pump_task = INIT_PUMP_TASK;
003420  801610     MOV PORTA, W0
003422  600061     AND W0, #0x1, W0
003424  E00000     CP0 W0
003426  320003     BRA Z, 0x342E
003428  200080     MOV #0x8, W0
00342A  8846A0     MOV W0, 0x8D4
156:                           else {
157:                               if (PumpTimer > 15000)PumpFault();
00342E  804691     MOV PumpTimer, W1
003430  23A980     MOV #0x3A98, W0
003432  508F80     SUB W1, W0, [W15]
003434  360001     BRA LEU, 0x3438
003436  070036     RCALL PumpFault
158:                               if (Devices.PumpIsEnabled) current_pump_task = INIT_PUMP_TASK;
003438  8043B0     MOV Devices, W0
00343A  600064     AND W0, #0x4, W0
00343C  E00000     CP0 W0
00343E  32000D     BRA Z, 0x345A
003440  200080     MOV #0x8, W0
003442  8846A0     MOV W0, 0x8D4
159:                           }
160:                           break;
00342C  370017     BRA 0x345C
003444  37000B     BRA 0x345C
00345A  000000     NOP
161:               
162:                       case PUMP_SYSTEM_FAULT:
163:                           //shut down system here
164:                           break;
003446  000000     NOP
003448  370009     BRA 0x345C
165:                   }
166:                   
167:                   if (PumpVoltageSensingTimer > PUMP_V_SENS_TIME) {
00345C  8044B1     MOV PumpVoltageSensingTimer, W1
00345E  200C80     MOV #0xC8, W0
003460  508F80     SUB W1, W0, [W15]
003462  36001E     BRA LEU, 0x34A0
168:                       Nop();
003464  000000     NOP
169:                       Nop();
003466  000000     NOP
170:                       Nop();
003468  000000     NOP
171:                       PumpVoltageSensingTimer = 0;
00346A  EF2896     CLR PumpVoltageSensingTimer
172:                       while (!CommFlags.SPI1RxDone);
00346C  000000     NOP
00346E  8045B0     MOV 0x8B6, W0
003470  600064     AND W0, #0x4, W0
003472  E00000     CP0 W0
003474  32FFFC     BRA Z, 0x346E
173:                       PUMP_SPI_EN = HIGH;
003476  A862DD     BSET 0x2DD, #3
174:                       CS_ADC_PUMP = LOW;
003478  A9A2D5     BCLR 0x2D5, #5
175:                       val = SPIReadWriteWord(MCP3002_CH1);
00347A  2E0000     MOV #0xE000, W0
00347C  07F83E     RCALL SPIReadWriteWord
00347E  780F00     MOV W0, [W14]
176:                       val >>= 1;
003480  78001E     MOV [W14], W0
003482  D10000     LSR W0, W0
003484  780F00     MOV W0, [W14]
177:                       PumpVoltageMonitor = (PumpVoltageMonitor + val) / 2; //v pump is 24vdc r divider 10k*24/(49.9k+10k)=4V
003486  8046B0     MOV 0x8D6, W0
003488  40001E     ADD W0, [W14], W0
00348A  D10000     LSR W0, W0
00348C  8846B0     MOV W0, 0x8D6
178:                       CS_ADC_PUMP = HIGH;
00348E  A8A2D5     BSET 0x2D5, #5
179:                       PUMP_SPI_EN = LOW;
003490  A962DD     BCLR 0x2DD, #3
180:                       if (PumpVoltageMonitor < 700) {
003492  8046B1     MOV 0x8D6, W1
003494  202BB0     MOV #0x2BB, W0
003496  508F80     SUB W1, W0, [W15]
003498  3E0003     BRA GTU, 0x34A0
181:                           PumpFault();
00349A  070004     RCALL PumpFault
182:                           FaultNumber = FAULT_PUMP_DRIVER;
00349C  2002A0     MOV #0x2A, W0
00349E  8843C0     MOV W0, FaultNumber
183:                       }
184:                   }
185:               }
0034A0  FA8000     ULNK
0034A2  060000     RETURN
186:               
187:               void PumpFault(void) {
0034A4  FA0000     LNK #0x0
188:                   Devices.SystemStatedUpdate = TRUE;
0034A6  A80877     BSET 0x877, #0
189:                   SystemStateToUpdate = SYS_STATE_FAULT;
0034A8  2000F0     MOV #0xF, W0
0034AA  8846E0     MOV W0, 0x8DC
190:                   FaultNumber = FAULT_COOLING_SYSTEM;
0034AC  2001C0     MOV #0x1C, W0
0034AE  8843C0     MOV W0, FaultNumber
191:                   SetPumpVoltage(0);
0034B0  EB0000     CLR W0
0034B2  07FF1B     RCALL SetPumpVoltage
192:                   Devices.PumpIsReady = FALSE;
0034B4  A96876     BCLR Devices, #3
193:                   Devices.PumpIsEnabled = FALSE;
0034B6  A94876     BCLR Devices, #2
194:                   PumpTimer = CLEAR;
0034B8  EF28D2     CLR PumpTimer
195:                   current_pump_task = PUMP_SYSTEM_FAULT;
0034BA  200060     MOV #0x6, W0
0034BC  8846A0     MOV W0, 0x8D4
196:               }
0034BE  FA8000     ULNK
0034C0  060000     RETURN
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/main.c
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #ifdef __DEBUG
17:                #ifndef __MPLAB_DEBUGGER_ICD3
18:                #define __SIMULATOR
19:                #endif
20:                #endif
21:                
22:                
23:                #include <stdint.h>        /* Includes uint16_t definition                    */
24:                #include <stdbool.h>       /* Includes true/false definition                  */
25:                
26:                #include "system.h"        /* System funct/params, like osc/peripheral config */
27:                #include "user.h"          /* User funct/params, such as InitApp              */
28:                
29:                /******************************************************************************/
30:                /* Global Variable Declaration                                                */
31:                /******************************************************************************/
32:                extern void comm_tasks(void);
33:                //extern void ADMeasurments(void);
34:                //extern void InitBt(void);
35:                extern void SystemCheck(void);
36:                //extern void BtCommTask(void);
37:                /******************************************************************************/
38:                /* Main Program                                                               */
39:                
40:                /******************************************************************************/
41:                
42:                int16_t main(void) {
00381C  FA0000     LNK #0x0
43:                
44:                    /* Configure the oscillator for the device */
45:                
46:                #ifndef __SIMULATOR
47:                    ConfigureOscillator();
00381E  07FFE1     RCALL ConfigureOscillator
48:                #endif
49:                    //MemorySelfTest();
50:                    /* Initialize IO ports and peripherals */
51:                    InitApp();
003820  07F4E7     RCALL InitApp
52:                    //TECPIDInit();
53:                #ifndef __TESTER
54:                    //InitBt();
55:                #endif
56:                    while (1) {
57:                        ClrWdt();
003822  FE6000     CLRWDT
58:                        LED0 ^= 1;
003824  8016E0     MOV LATD, W0
003826  DE004E     LSR W0, #14, W0
003828  604061     AND.B W0, #0x1, W0
00382A  A20400     BTG.B W0, #0
00382C  604061     AND.B W0, #0x1, W0
00382E  FB8000     ZE W0, W0
003830  600061     AND W0, #0x1, W0
003832  DD004E     SL W0, #14, W0
003834  8016E2     MOV LATD, W2
003836  2BFFF1     MOV #0xBFFF, W1
003838  610081     AND W2, W1, W1
00383A  700001     IOR W0, W1, W0
00383C  8816E0     MOV W0, LATD
59:                        comm_tasks();
00383E  07F66D     RCALL comm_tasks
60:                        SystemCheck();
003840  07F174     RCALL SystemCheck
61:                        //BtCommTask();
62:                    }
003842  37FFEF     BRA 0x3822
63:                }
64:                
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/interrupts.c
1:                 /******************************************************************************/
2:                 /* Files to Include                                                           */
3:                 /******************************************************************************/
4:                 
5:                 /* Device header file */
6:                 #if defined(__XC16__)
7:                 #include <xc.h>
8:                 #elif defined(__C30__)
9:                 #if defined(__dsPIC33E__)
10:                #include <p33Exxxx.h>
11:                #elif defined(__dsPIC33F__)
12:                #include <p33Fxxxx.h>
13:                #endif
14:                #endif
15:                
16:                #include <stdint.h>        /* Includes uint16_t definition   */
17:                #include <stdbool.h>       /* Includes true/false definition */
18:                #include "user.h"
19:                
20:                /******************************************************************************/
21:                /* Interrupt Vector Options                                                   */
22:                /******************************************************************************/
23:                /*                                                                            */
24:                /* Refer to the C30 (MPLAB C Compiler for PIC24F MCUs and dsPIC33F DSCs) User */
25:                /* Guide for an up to date list of the available interrupt options.           */
26:                /* Alternately these names can be pulled from the device linker scripts.      */
27:                /*                                                                            */
28:                /* dsPIC33F Primary Interrupt Vector Names:                                   */
29:                /*                                                                            */
30:                /* _INT0Interrupt      _C1Interrupt                                           */
31:                /* _IC1Interrupt       _DMA3Interrupt                                         */
32:                /* _OC1Interrupt       _IC3Interrupt                                          */
33:                /* _T1Interrupt        _IC4Interrupt                                          */
34:                /* _DMA0Interrupt      _IC5Interrupt                                          */
35:                /* _IC2Interrupt       _IC6Interrupt                                          */
36:                /* _OC2Interrupt       _OC5Interrupt                                          */
37:                /* _T2Interrupt        _OC6Interrupt                                          */
38:                /* _T3Interrupt        _OC7Interrupt                                          */
39:                /* _SPI1ErrInterrupt   _OC8Interrupt                                          */
40:                /* _SPI1Interrupt      _DMA4Interrupt                                         */
41:                /* _U1RXInterrupt      _T6Interrupt                                           */
42:                /* _U1TXInterrupt      _T7Interrupt                                           */
43:                /* _ADC1Interrupt      _SI2C2Interrupt                                        */
44:                /* _DMA1Interrupt      _MI2C2Interrupt                                        */
45:                /* _SI2C1Interrupt     _T8Interrupt                                           */
46:                /* _MI2C1Interrupt     _T9Interrupt                                           */
47:                /* _CNInterrupt        _INT3Interrupt                                         */
48:                /* _INT1Interrupt      _INT4Interrupt                                         */
49:                /* _ADC2Interrupt      _C2RxRdyInterrupt                                      */
50:                /* _DMA2Interrupt      _C2Interrupt                                           */
51:                /* _OC3Interrupt       _DCIErrInterrupt                                       */
52:                /* _OC4Interrupt       _DCIInterrupt                                          */
53:                /* _T4Interrupt        _DMA5Interrupt                                         */
54:                /* _T5Interrupt        _U1ErrInterrupt                                        */
55:                /* _INT2Interrupt      _U2ErrInterrupt                                        */
56:                /* _U2RXInterrupt      _DMA6Interrupt                                         */
57:                /* _U2TXInterrupt      _DMA7Interrupt                                         */
58:                /* _SPI2ErrInterrupt   _C1TxReqInterrupt                                      */
59:                /* _SPI2Interrupt      _C2TxReqInterrupt                                      */
60:                /* _C1RxRdyInterrupt                                                          */
61:                /*                                                                            */
62:                /* dsPIC33E Primary Interrupt Vector Names:                                   */
63:                /*                                                                            */
64:                /* _INT0Interrupt     _IC4Interrupt      _U4TXInterrupt                       */
65:                /* _IC1Interrupt      _IC5Interrupt      _SPI3ErrInterrupt                    */
66:                /* _OC1Interrupt      _IC6Interrupt      _SPI3Interrupt                       */
67:                /* _T1Interrupt       _OC5Interrupt      _OC9Interrupt                        */
68:                /* _DMA0Interrupt     _OC6Interrupt      _IC9Interrupt                        */
69:                /* _IC2Interrupt      _OC7Interrupt      _PWM1Interrupt                       */
70:                /* _OC2Interrupt      _OC8Interrupt      _PWM2Interrupt                       */
71:                /* _T2Interrupt       _PMPInterrupt      _PWM3Interrupt                       */
72:                /* _T3Interrupt       _DMA4Interrupt     _PWM4Interrupt                       */
73:                /* _SPI1ErrInterrupt  _T6Interrupt       _PWM5Interrupt                       */
74:                /* _SPI1Interrupt     _T7Interrupt       _PWM6Interrupt                       */
75:                /* _U1RXInterrupt     _SI2C2Interrupt    _PWM7Interrupt                       */
76:                /* _U1TXInterrupt     _MI2C2Interrupt    _DMA8Interrupt                       */
77:                /* _AD1Interrupt      _T8Interrupt       _DMA9Interrupt                       */
78:                /* _DMA1Interrupt     _T9Interrupt       _DMA10Interrupt                      */
79:                /* _NVMInterrupt      _INT3Interrupt     _DMA11Interrupt                      */
80:                /* _SI2C1Interrupt    _INT4Interrupt     _SPI4ErrInterrupt                    */
81:                /* _MI2C1Interrupt    _C2RxRdyInterrupt  _SPI4Interrupt                       */
82:                /* _CM1Interrupt      _C2Interrupt       _OC10Interrupt                       */
83:                /* _CNInterrupt       _QEI1Interrupt     _IC10Interrupt                       */
84:                /* _INT1Interrupt     _DCIEInterrupt     _OC11Interrupt                       */
85:                /* _AD2Interrupt      _DCIInterrupt      _IC11Interrupt                       */
86:                /* _IC7Interrupt      _DMA5Interrupt     _OC12Interrupt                       */
87:                /* _IC8Interrupt      _RTCCInterrupt     _IC12Interrupt                       */
88:                /* _DMA2Interrupt     _U1ErrInterrupt    _DMA12Interrupt                      */
89:                /* _OC3Interrupt      _U2ErrInterrupt    _DMA13Interrupt                      */
90:                /* _OC4Interrupt      _CRCInterrupt      _DMA14Interrupt                      */
91:                /* _T4Interrupt       _DMA6Interrupt     _OC13Interrupt                       */
92:                /* _T5Interrupt       _DMA7Interrupt     _IC13Interrupt                       */
93:                /* _INT2Interrupt     _C1TxReqInterrupt  _OC14Interrupt                       */
94:                /* _U2RXInterrupt     _C2TxReqInterrupt  _IC14Interrupt                       */
95:                /* _U2TXInterrupt     _QEI2Interrupt     _OC15Interrupt                       */
96:                /* _SPI2ErrInterrupt  _U3ErrInterrupt    _IC15Interrupt                       */
97:                /* _SPI2Interrupt     _U3RXInterrupt     _OC16Interrupt                       */
98:                /* _C1RxRdyInterrupt  _U3TXInterrupt     _IC16Interrupt                       */
99:                /* _C1Interrupt       _USB1Interrupt     _ICDInterrupt                        */
100:               /* _DMA3Interrupt     _U4ErrInterrupt    _PWMSpEventMatchInterrupt            */
101:               /* _IC3Interrupt      _U4RXInterrupt     _PWMSecSpEventMatchInterrupt         */
102:               /*                                                                            */
103:               /* For alternate interrupt vector naming, simply add 'Alt' between the prim.  */
104:               /* interrupt vector name '_' and the first character of the primary interrupt */
105:               /* vector name.  There is no Alternate Vector or 'AIVT' for the 33E family.   */
106:               /*                                                                            */
107:               /* For example, the vector name _ADC2Interrupt becomes _AltADC2Interrupt in   */
108:               /* the alternate vector table.                                                */
109:               /*                                                                            */
110:               /* Example Syntax:                                                            */
111:               /*                                                                            */
112:               /* void __attribute__((interrupt,auto_psv)) <Vector Name>(void)               */
113:               /* {                                                                          */
114:               /*     <Clear Interrupt Flag>                                                 */
115:               /* }                                                                          */
116:               /*                                                                            */
117:               /* For more comprehensive interrupt examples refer to the C30 (MPLAB C        */
118:               /* Compiler for PIC24 MCUs and dsPIC DSCs) User Guide in the                  */
119:               /* <C30 compiler instal directory>/doc directory for the latest compiler      */
120:               /* release.  For XC16, refer to the MPLAB XC16 C Compiler User's Guide in the */
121:               /* <XC16 compiler instal directory>/doc folder.                               */
122:               /*                                                                            */
123:               /******************************************************************************/
124:               /* Interrupt Routines                                                         */
125:               /******************************************************************************/
126:               u8 HeaderCheckSum;
127:               u8 FrameCheckSum;
128:               u16 BytesToEndOfFrame;
129:               u16 CommTimeOutCount = 0;
130:               u16 cnt100uS = 0;
131:               u16 cntSPIMeasure = 0;
132:               u16 TecPidTimer = 0;
133:               u16 PumpVoltageSensingTimer = 0;
134:               u16 TecVoltageSensingTimer = 0;
135:               u16 IndxDiodeCurrent = 0;
136:               
137:               extern u8 RXbuffer[256]; //rx bufer
138:               extern u8 indxRXbuffer; //index of rx buffer
139:               extern u8 TXbuffer[256]; //tx bufer
140:               extern u8 indxTXbuff; //index of tx buffer
141:               extern u16 FrameLen;
142:               extern u16 DelayCounter;
143:               extern u16 offTimeCntr;
144:               extern u32 ChargerTimeCntr;
145:               extern u16 tx100uS;
146:               extern u16 TriggerCounter;
147:               extern u16 PumpTimer;
148:               extern u16 SimmerTimer;
149:               extern u16 FanTimer;
150:               extern u16 InterlockTimeOut;
151:               extern u16 SPIMeasure;
152:               extern u16 Pulse_On_Time;
153:               extern u16 appShortTimeOut;
154:               extern u16 LightGuideShortTimeOut;
155:               extern u16 btIndxTx;
156:               extern u16 btIndxRx;
157:               extern u16 CharsToSend;
158:               extern unsigned char bttx_buffer[8];
159:               extern unsigned char BtRx_Buffer[8];
160:               
161:               extern u16 SimmerMonitor[5];
162:               extern u16 CapacitorMonitor[5];
163:               extern u16 DiodeCurrent1[5];
164:               extern u16 DiodeCurrent2[5];
165:               extern u16 TempSensorApplicator[5];
166:               extern u16 TempSensorAmbient[5];
167:               extern u16 TecTemperature[5];
168:               extern u16 indxTecTemperature;
169:               extern u16 WaterTemperature[5];
170:               extern u16 ADMeasurementsDone;
171:               extern u16 WritePulseCounterTimer;
172:               extern u16 TemperatureAdSamplingCounter;
173:               extern u16 indxWaterTemperature;
174:               extern u16 LddriverCurrentOffTime;
175:               extern u16 FlickerTimer;
176:               
177:               void __attribute__((interrupt, no_auto_psv)) _T3Interrupt(void) {
000E32  BE9F80     MOV.D W0, [W15++]
000E34  781F82     MOV W2, [W15++]
000E36  FA0000     LNK #0x0
178:                   static u16 mSecCounter = 0;
179:                   IFS0bits.T3IF = CLEAR; /* reset Timer 1 interrupt flag */
000E38  A90085     BCLR 0x85, #0
180:               
181:                   if (mSecCounter++ >= 9) {//to count in 1mS
000E3A  8044E1     MOV mSecCounter, W1
000E3C  B3C010     MOV.B #0x1, W0
000E3E  508FE8     SUB W1, #0x8, [W15]
000E40  3E0001     BRA GTU, 0xE44
000E42  EB4000     CLR.B W0
000E44  E80081     INC W1, W1
000E46  8844E1     MOV W1, mSecCounter
000E48  E00400     CP0.B W0
000E4A  320032     BRA Z, 0xEB0
182:                       mSecCounter = 0;
000E4C  EF289C     CLR mSecCounter
183:                       TriggerCounter++;
000E4E  804540     MOV TriggerCounter, W0
000E50  E80000     INC W0, W0
000E52  884540     MOV W0, TriggerCounter
184:                       PumpTimer++;
000E54  804690     MOV PumpTimer, W0
000E56  E80000     INC W0, W0
000E58  884690     MOV W0, PumpTimer
185:                       TemperatureAdSamplingCounter++;      
000E5A  804620     MOV TemperatureAdSamplingCounter, W0
000E5C  E80000     INC W0, W0
000E5E  884620     MOV W0, TemperatureAdSamplingCounter
186:                       appShortTimeOut++;
000E60  804500     MOV appShortTimeOut, W0
000E62  E80000     INC W0, W0
000E64  884500     MOV W0, appShortTimeOut
187:                       LightGuideShortTimeOut++;
000E66  804510     MOV LightGuideShortTimeOut, W0
000E68  E80000     INC W0, W0
000E6A  884510     MOV W0, LightGuideShortTimeOut
188:                       InterlockTimeOut++;
000E6C  804570     MOV InterlockTimeOut, W0
000E6E  E80000     INC W0, W0
000E70  884570     MOV W0, InterlockTimeOut
189:                       WritePulseCounterTimer++;
000E72  804200     MOV WritePulseCounterTimer, W0
000E74  E80000     INC W0, W0
000E76  884200     MOV W0, WritePulseCounterTimer
190:                       tx100uS++;
000E78  804650     MOV tx100uS, W0
000E7A  E80000     INC W0, W0
000E7C  884650     MOV W0, tx100uS
191:                       CommTimeOutCount++;
000E7E  804470     MOV CommTimeOutCount, W0
000E80  E80000     INC W0, W0
000E82  884470     MOV W0, CommTimeOutCount
192:                       if (CommTimeOutCount > 2)indxRXbuffer = 0;
000E84  804470     MOV CommTimeOutCount, W0
000E86  500FE2     SUB W0, #0x2, [W15]
000E88  360001     BRA LEU, 0xE8C
000E8A  EF68C6     CLR.B indxRXbuffer
193:                       PumpVoltageSensingTimer++;
000E8C  8044B0     MOV PumpVoltageSensingTimer, W0
000E8E  E80000     INC W0, W0
000E90  8844B0     MOV W0, PumpVoltageSensingTimer
194:                       TecVoltageSensingTimer++;
000E92  8044C0     MOV TecVoltageSensingTimer, W0
000E94  E80000     INC W0, W0
000E96  8844C0     MOV W0, TecVoltageSensingTimer
195:                       ChargerTimeCntr++;
000E98  804320     MOV ChargerTimeCntr, W0
000E9A  804331     MOV 0x866, W1
000E9C  400061     ADD W0, #0x1, W0
000E9E  4880E0     ADDC W1, #0x0, W1
000EA0  884320     MOV W0, ChargerTimeCntr
000EA2  884331     MOV W1, 0x866
196:                       FlickerTimer++;
000EA4  8043A0     MOV FlickerTimer, W0
000EA6  E80000     INC W0, W0
000EA8  8843A0     MOV W0, FlickerTimer
197:                       offTimeCntr++;
000EAA  804290     MOV offTimeCntr, W0
000EAC  E80000     INC W0, W0
000EAE  884290     MOV W0, offTimeCntr
198:                   }
199:                   cntSPIMeasure++;
000EB0  804490     MOV cntSPIMeasure, W0
000EB2  E80000     INC W0, W0
000EB4  884490     MOV W0, cntSPIMeasure
200:                   LED1 ^= 1;
000EB6  8016E0     MOV LATD, W0
000EB8  DE004F     LSR W0, #15, W0
000EBA  784000     MOV.B W0, W0
000EBC  A20400     BTG.B W0, #0
000EBE  604061     AND.B W0, #0x1, W0
000EC0  FB8000     ZE W0, W0
000EC2  DD004F     SL W0, #15, W0
000EC4  8016E2     MOV LATD, W2
000EC6  27FFF1     MOV #0x7FFF, W1
000EC8  610081     AND W2, W1, W1
000ECA  700001     IOR W0, W1, W0
000ECC  8816E0     MOV W0, LATD
201:               }
000ECE  FA8000     ULNK
000ED0  78014F     MOV [--W15], W2
000ED2  BE004F     MOV.D [--W15], W0
000ED4  064000     RETFIE
202:               
203:               void __attribute__((interrupt, no_auto_psv)) _T2Interrupt(void) {
000ED6  BE9F80     MOV.D W0, [W15++]
000ED8  FA0000     LNK #0x0
204:                   IFS0bits.T2IF = CLEAR; /* reset Timer 1 interrupt flag */
000EDA  A9E084     BCLR IFS0, #7
205:                   Devices.PulseInProgress = 0; //end of pulse
000EDC  A9E876     BCLR Devices, #7
206:                   LED0 = 0;
000EDE  A9C2DD     BCLR 0x2DD, #6
207:                   PulseCounter++;
000EE0  8043D0     MOV PulseCounter, W0
000EE2  8043E1     MOV 0x87C, W1
000EE4  400061     ADD W0, #0x1, W0
000EE6  4880E0     ADDC W1, #0x0, W1
000EE8  8843D0     MOV W0, PulseCounter
000EEA  8843E1     MOV W1, 0x87C
208:                   T2CONbits.TON = 0;
000EEC  A9E111     BCLR 0x111, #7
209:                   //LD_INHIBIT1 = HIGH;
210:                   LD_EN_PWM = 0;
000EEE  A9E423     BCLR 0x423, #7
211:                   PULSE_PWM = 0;
000EF0  A922E4     BCLR LATE, #1
212:                   TRISEbits.TRISE1 = INPUT;
000EF2  A822E0     BSET TRISE, #1
213:                   offTimeCntr = 0;
000EF4  EF2852     CLR offTimeCntr
214:                   PR2 = 0;
000EF6  EF210C     CLR PR2
215:                   PDC1 = 0;
000EF8  EF2426     CLR PDC1
216:                   SDC1 = 0;
000EFA  EF242E     CLR SDC1
217:               }
000EFC  FA8000     ULNK
000EFE  BE004F     MOV.D [--W15], W0
000F00  064000     RETFIE
218:               
219:               void __attribute__((interrupt, no_auto_psv)) _T4Interrupt(void) {
000F02  BE9F80     MOV.D W0, [W15++]
000F04  FA0000     LNK #0x0
220:                   IFS1bits.T4IF = CLEAR; /* reset Timer 1 interrupt flag */
000F06  A96087     BCLR 0x87, #3
221:                   if (Devices.PulseInProgress)ADCPC0bits.SWTRG1 = 1;
000F08  8043B1     MOV Devices, W1
000F0A  200800     MOV #0x80, W0
000F0C  608000     AND W1, W0, W0
000F0E  E00000     CP0 W0
000F10  320002     BRA Z, 0xF16
000F12  A8A30B     BSET 0x30B, #5
000F14  370001     BRA 0xF18
222:                   else T4CONbits.TON = 0;
000F16  A9E11F     BCLR 0x11F, #7
223:               }
000F18  FA8000     ULNK
000F1A  BE004F     MOV.D [--W15], W0
000F1C  064000     RETFIE
224:               
225:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void) {
000F1E  BE9F80     MOV.D W0, [W15++]
000F20  BE9F82     MOV.D W2, [W15++]
000F22  FA0000     LNK #0x0
226:                   IFS0bits.U1RXIF = CLEAR;
000F24  A96085     BCLR 0x85, #3
227:                   RXbuffer[indxRXbuffer++] = U1RXREG;
000F26  BFC8C6     MOV.B indxRXbuffer, WREG
000F28  FB8080     ZE W0, W1
000F2A  801132     MOV U1RXREG, W2
000F2C  784182     MOV.B W2, W3
000F2E  208E02     MOV #0x8E0, W2
000F30  78F103     MOV.B W3, [W2+W1]
000F32  E84000     INC.B W0, W0
000F34  B7E8C6     MOV.B WREG, indxRXbuffer
228:                   LED2 ^= 1;
000F36  801660     MOV LATB, W0
000F38  DE004C     LSR W0, #12, W0
000F3A  604061     AND.B W0, #0x1, W0
000F3C  A20400     BTG.B W0, #0
000F3E  604061     AND.B W0, #0x1, W0
000F40  FB8000     ZE W0, W0
000F42  600061     AND W0, #0x1, W0
000F44  DD004C     SL W0, #12, W0
000F46  801662     MOV LATB, W2
000F48  2EFFF1     MOV #0xEFFF, W1
000F4A  610081     AND W2, W1, W1
000F4C  700001     IOR W0, W1, W0
000F4E  881660     MOV W0, LATB
229:                   CommTimeOutCount = 0;
000F50  EF288E     CLR CommTimeOutCount
230:                   if (indxRXbuffer == 1) {
000F52  BFC8C6     MOV.B indxRXbuffer, WREG
000F54  504FE1     SUB.B W0, #0x1, [W15]
000F56  3A0007     BRA NZ, 0xF66
231:                       if (RXbuffer[0] != 0x55)
000F58  208E00     MOV #0x8E0, W0
000F5A  784090     MOV.B [W0], W1
000F5C  B3C550     MOV.B #0x55, W0
000F5E  50CF80     SUB.B W1, W0, [W15]
000F60  320034     BRA Z, 0xFCA
232:                           indxRXbuffer = 0;
000F62  EF68C6     CLR.B indxRXbuffer
000F64  370032     BRA 0xFCA
233:                   } else if (indxRXbuffer == 2) {
000F66  BFC8C6     MOV.B indxRXbuffer, WREG
000F68  504FE2     SUB.B W0, #0x2, [W15]
000F6A  3A000B     BRA NZ, 0xF82
234:                       if (RXbuffer[1] == HPDL_ADDRESS)HeaderCheckSum = RXbuffer[1]; // the real string next row for debug only
000F6C  208E10     MOV #0x8E1, W0
000F6E  784090     MOV.B [W0], W1
000F70  B3C900     MOV.B #0x90, W0
000F72  50CF80     SUB.B W1, W0, [W15]
000F74  3A0004     BRA NZ, 0xF7E
000F76  208E10     MOV #0x8E1, W0
000F78  784010     MOV.B [W0], W0
000F7A  B7E88A     MOV.B WREG, HeaderCheckSum
000F7C  370026     BRA 0xFCA
235:                           //if ((RXbuffer[1] == IPL_ADDRESS)||(RXbuffer[1] == 0x20))HeaderCheckSum = RXbuffer[1];//TODO for debug
236:                       else indxRXbuffer = 0;
000F7E  EF68C6     CLR.B indxRXbuffer
000F80  370024     BRA 0xFCA
237:                   } else if (indxRXbuffer == 6) {
000F82  BFC8C6     MOV.B indxRXbuffer, WREG
000F84  504FE6     SUB.B W0, #0x6, [W15]
000F86  3A0012     BRA NZ, 0xFAC
238:                       HeaderCheckSum = HeaderCheckSum + RXbuffer[2] + RXbuffer[3] + RXbuffer[4];
000F88  208E20     MOV #0x8E2, W0
000F8A  784090     MOV.B [W0], W1
000F8C  BFC88A     MOV.B HeaderCheckSum, WREG
000F8E  40C080     ADD.B W1, W0, W1
000F90  208E30     MOV #0x8E3, W0
000F92  784010     MOV.B [W0], W0
000F94  40C080     ADD.B W1, W0, W1
000F96  208E40     MOV #0x8E4, W0
000F98  784010     MOV.B [W0], W0
000F9A  40C000     ADD.B W1, W0, W0
000F9C  B7E88A     MOV.B WREG, HeaderCheckSum
239:                       if (RXbuffer[5] != HeaderCheckSum)indxRXbuffer = 0;
000F9E  208E50     MOV #0x8E5, W0
000FA0  784090     MOV.B [W0], W1
000FA2  BFC88A     MOV.B HeaderCheckSum, WREG
000FA4  50CF80     SUB.B W1, W0, [W15]
000FA6  320011     BRA Z, 0xFCA
000FA8  EF68C6     CLR.B indxRXbuffer
000FAA  37000F     BRA 0xFCA
240:                   } else if (indxRXbuffer == 7) {
000FAC  BFC8C6     MOV.B indxRXbuffer, WREG
000FAE  504FE7     SUB.B W0, #0x7, [W15]
000FB0  3A0006     BRA NZ, 0xFBE
241:                       BytesToEndOfFrame = RXbuffer[6] + 8;
000FB2  208E60     MOV #0x8E6, W0
000FB4  784010     MOV.B [W0], W0
000FB6  FB8000     ZE W0, W0
000FB8  400068     ADD W0, #0x8, W0
000FBA  884460     MOV W0, BytesToEndOfFrame
000FBC  370006     BRA 0xFCA
242:                   } else if (indxRXbuffer == BytesToEndOfFrame) {
000FBE  BFC8C6     MOV.B indxRXbuffer, WREG
000FC0  FB8080     ZE W0, W1
000FC2  804460     MOV BytesToEndOfFrame, W0
000FC4  508F80     SUB W1, W0, [W15]
000FC6  3A0001     BRA NZ, 0xFCA
243:                       CommFlags.FrameReceivedFlag = 1;
000FC8  A808B6     BSET 0x8B6, #0
244:                   }
245:               }
000FCA  FA8000     ULNK
000FCC  BE014F     MOV.D [--W15], W2
000FCE  BE004F     MOV.D [--W15], W0
000FD0  064000     RETFIE
246:               
247:               void __attribute__((interrupt, no_auto_psv)) _U1TXInterrupt(void) {
000FD2  BE9F80     MOV.D W0, [W15++]
000FD4  FA0000     LNK #0x0
248:                   IFS0bits.U1TXIF = CLEAR;
000FD6  A98085     BCLR 0x85, #4
249:                   indxTXbuff++;
000FD8  BFC8C7     MOV.B indxTXbuff, WREG
000FDA  E84000     INC.B W0, W0
000FDC  B7E8C7     MOV.B WREG, indxTXbuff
250:                   while (!U1STAbits.TRMT); //check if all TX buffer was sent
000FDE  000000     NOP
000FE0  801111     MOV U1STA, W1
000FE2  201000     MOV #0x100, W0
000FE4  608000     AND W1, W0, W0
000FE6  E00000     CP0 W0
000FE8  32FFFB     BRA Z, 0xFE0
251:                   if (indxTXbuff == FrameLen) {
000FEA  BFC8C7     MOV.B indxTXbuff, WREG
000FEC  FB8080     ZE W0, W1
000FEE  804640     MOV FrameLen, W0
000FF0  508F80     SUB W1, W0, [W15]
000FF2  3A0008     BRA NZ, 0x1004
252:                       while (!U1STAbits.TRMT); //check if all TX buffer was sent
000FF4  000000     NOP
000FF6  801111     MOV U1STA, W1
000FF8  201000     MOV #0x100, W0
000FFA  608000     AND W1, W0, W0
000FFC  E00000     CP0 W0
000FFE  32FFFB     BRA Z, 0xFF6
253:                       //U1STAbits.UTXEN = DISABLE;
254:                       DIR = RX_MODE;
001000  A9A2C4     BCLR LATA, #5
001002  37000C     BRA 0x101C
255:                   } else {
256:                       while (!U1STAbits.TRMT); //check if all TX buffer was sent
001004  000000     NOP
001006  801111     MOV U1STA, W1
001008  201000     MOV #0x100, W0
00100A  608000     AND W1, W0, W0
00100C  E00000     CP0 W0
00100E  32FFFB     BRA Z, 0x1006
257:                       U1TXREG = TXbuffer[indxTXbuff]; //send byte
001010  BFC8C7     MOV.B indxTXbuff, WREG
001012  FB8000     ZE W0, W0
001014  209E01     MOV #0x9E0, W1
001016  784061     MOV.B [W1+W0], W0
001018  FB8000     ZE W0, W0
00101A  881120     MOV W0, U1TXREG
258:                   }
259:               }
00101C  FA8000     ULNK
00101E  BE004F     MOV.D [--W15], W0
001020  064000     RETFIE
260:               //
261:               //void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt(void) {
262:               //    IFS1bits.U2RXIF = CLEAR;
263:               //    BtRx_Buffer[btIndxRx++] = U2RXREG;
264:               //    if (btIndxRx > 7)btIndxRx = 0;
265:               //
266:               //}
267:               //
268:               //void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
269:               //
270:               //    IFS1bits.U2TXIF = CLEAR;
271:               //    btIndxTx++;
272:               //    while (!U2STAbits.TRMT); //check if all TX buffer was sent
273:               //    if (btIndxTx < CharsToSend) {
274:               //        U2TXREG = bttx_buffer[btIndxTx]; //send byte
275:               //    }
276:               //}
277:               
278:               void __attribute__((interrupt, no_auto_psv)) _DMA0Interrupt(void) {
001022  FA0000     LNK #0x0
279:                   IFS0bits.DMA0IF = 0; // Clear the DMA0 Interrupt Flag;
001024  A98084     BCLR IFS0, #4
280:               }
001026  FA8000     ULNK
001028  064000     RETFIE
281:               
282:               void __attribute__((interrupt, no_auto_psv)) _DMA1Interrupt(void) {
00102A  FA0000     LNK #0x0
283:                   IFS0bits.DMA1IF = 0; // Clear the DMA0 Interrupt Flag
00102C  A9C085     BCLR 0x85, #6
284:                   IEC0bits.SPI1IE = 0;
00102E  A94095     BCLR 0x95, #2
285:                   CommFlags.SPI1RxDone = 1;
001030  A848B6     BSET 0x8B6, #2
286:                   CS_ADC_LD = HIGH;
001032  A802F5     BSET 0x2F5, #0
287:                   LD_SPI_ENABLE = LOW;
001034  A942F4     BCLR LATG, #2
288:               }
001036  FA8000     ULNK
001038  064000     RETFIE
289:               
290:               void __attribute__((interrupt, no_auto_psv)) _SPI1Interrupt(void) {
00103A  781F80     MOV W0, [W15++]
00103C  FA0000     LNK #0x0
291:                   IFS0bits.SPI1IF = 0;
00103E  A94085     BCLR 0x85, #2
292:                   switch (SPIMeasure) {
001040  8042A0     MOV SPIMeasure, W0
001042  500FE1     SUB W0, #0x1, [W15]
001044  320003     BRA Z, 0x104C
001046  500FE2     SUB W0, #0x2, [W15]
001048  320007     BRA Z, 0x1058
00104A  37000C     BRA 0x1064
293:                       case DIODE_VOLTAGE:
294:                           CS_ADC_LD = HIGH;
00104C  A802F5     BSET 0x2F5, #0
295:                           Nop();
00104E  000000     NOP
296:                           Nop();
001050  000000     NOP
297:                           Nop();
001052  000000     NOP
298:                           CS_ADC_LD = LOW;
001054  A902F5     BCLR 0x2F5, #0
299:                           break;
001056  370006     BRA 0x1064
300:               
301:                       case CAP_MONITOR:
302:                           CS_ADC_LD = HIGH;
001058  A802F5     BSET 0x2F5, #0
303:                           Nop();
00105A  000000     NOP
304:                           Nop();
00105C  000000     NOP
305:                           Nop();
00105E  000000     NOP
306:                           CS_ADC_LD = LOW;
001060  A902F5     BCLR 0x2F5, #0
307:                           break;
001062  000000     NOP
308:                   }
309:               
310:               }
001064  FA8000     ULNK
001066  78004F     MOV [--W15], W0
001068  064000     RETFIE
311:               
312:               void __attribute__((interrupt, no_auto_psv)) _ADCP0Interrupt(void) {
00106A  BE9F80     MOV.D W0, [W15++]
00106C  BE9F82     MOV.D W2, [W15++]
00106E  FA0000     LNK #0x0
313:                   WaterTemperature[indxWaterTemperature++] = ADCBUF0; // Read AN0 conversion result    
001070  804610     MOV indxWaterTemperature, W0
001072  801A02     MOV ADCBUF0, W2
001074  400180     ADD W0, W0, W3
001076  20BA61     MOV #0xBA6, W1
001078  418081     ADD W3, W1, W1
00107A  780882     MOV W2, [W1]
00107C  E80000     INC W0, W0
00107E  884610     MOV W0, indxWaterTemperature
314:                   TecTemperature[indxTecTemperature++] = ADCBUF1;
001080  804000     MOV indxTecTemperature, W0
001082  801A12     MOV ADCBUF1, W2
001084  400180     ADD W0, W0, W3
001086  20B9C1     MOV #0xB9C, W1
001088  418081     ADD W3, W1, W1
00108A  780882     MOV W2, [W1]
00108C  E80000     INC W0, W0
00108E  884000     MOV W0, indxTecTemperature
315:                   IFS6bits.ADCP0IF = 0; // Clear ADC Pair 0 Interrupt Flag
001090  A9C091     BCLR 0x91, #6
316:               }
001092  FA8000     ULNK
001094  BE014F     MOV.D [--W15], W2
001096  BE004F     MOV.D [--W15], W0
001098  064000     RETFIE
317:               
318:               void __attribute__((interrupt, no_auto_psv)) _ADCP1Interrupt(void) {
00109A  BE9F80     MOV.D W0, [W15++]
00109C  BE9F82     MOV.D W2, [W15++]
00109E  FA0000     LNK #0x0
319:                   DiodeCurrent1[IndxDiodeCurrent] = ADCBUF2; // Read AN0 conversion result
0010A0  8044D0     MOV IndxDiodeCurrent, W0
0010A2  801A21     MOV ADCBUF2, W1
0010A4  400100     ADD W0, W0, W2
0010A6  20B880     MOV #0xB88, W0
0010A8  410000     ADD W2, W0, W0
0010AA  780801     MOV W1, [W0]
320:                   DiodeCurrent2[IndxDiodeCurrent++] = ADCBUF3; // Read AN1 conversion result
0010AC  8044D0     MOV IndxDiodeCurrent, W0
0010AE  801A32     MOV ADCBUF3, W2
0010B0  400180     ADD W0, W0, W3
0010B2  20B921     MOV #0xB92, W1
0010B4  418081     ADD W3, W1, W1
0010B6  780882     MOV W2, [W1]
0010B8  E80000     INC W0, W0
0010BA  8844D0     MOV W0, IndxDiodeCurrent
321:                   IFS6bits.ADCP1IF = 0; // Clear ADC Pair 0 Interrupt Flag
0010BC  A9E091     BCLR 0x91, #7
322:                   if (IndxDiodeCurrent < 5)ADCPC0bits.SWTRG1 = 1;
0010BE  8044D0     MOV IndxDiodeCurrent, W0
0010C0  500FE4     SUB W0, #0x4, [W15]
0010C2  3E0002     BRA GTU, 0x10C8
0010C4  A8A30B     BSET 0x30B, #5
0010C6  370001     BRA 0x10CA
323:                   else Devices2.DiodeCurrentMeasurementDone = 1;
0010C8  A8E8B8     BSET 0x8B8, #7
324:               }
0010CA  FA8000     ULNK
0010CC  BE014F     MOV.D [--W15], W2
0010CE  BE004F     MOV.D [--W15], W0
0010D0  064000     RETFIE
325:               
326:               //void __attribute__((interrupt, no_auto_psv)) _ADCP2Interrupt(void) {
327:               //    CapacitorMonitor[indxADCBuffer] = ADCBUF4; // Read AN1 conversion result
328:               //    SimmerMonitor[indxADCBuffer] = ADCBUF5; // Read AN0 conversion result
329:               //    IFS7bits.ADCP2IF = 0; // Clear ADC Pair 0 Interrupt Flag
330:               //}
331:               //
332:               //void __attribute__((interrupt, no_auto_psv)) _ADCP4Interrupt(void) {
333:               //    TECTemperature[indxADCBuffer] = ADCBUF9; // Read AN0 conversion result
334:               //    indxADCBuffer++;
335:               //    if (indxADCBuffer > 4) {
336:               //        indxADCBuffer = 0;
337:               //        ADMeasurementsDone = 1;
338:               //    }
339:               //    IFS7bits.ADCP4IF = 0; // Clear ADC Pair 0 Interrupt Flag
340:               //}
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/fan.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define FAN_INIT_TASK               0
20:                #define FAN_WAIT_FOR_SPEED_UPDATE   1
21:                #define FAN_SPEED_UPDATE            2
22:                #define FAN_OVERTEMPERATURE         3
23:                #define FAN_SYSTEM_FAULT            4
24:                /*================================================*/
25:                
26:                /*================= Variables ===============================*/
27:                u16 current_fan_task = 0;
28:                u16 WaterTemperature[5] = {250, 250, 250, 250, 250};
29:                u16 indxWaterTemperature = 0;
30:                u16 TemperatureAdSamplingCounter = 0;
31:                float ActualWaterTemperature = 25.0;
32:                
33:                extern u16 SystemStateToUpdate;
34:                /*================================================*/
35:                
36:                /*================= Functions ===============================*/
37:                void fan_tasks(void);
38:                
39:                /*================================================*/
40:                
41:                void fan_tasks(void) {
003050  FA0006     LNK #0x6
003052  781F88     MOV W8, [W15++]
42:                    u16 i;
43:                    float tVal;
44:                
45:                    if (TemperatureAdSamplingCounter > 1000) {
003054  804621     MOV TemperatureAdSamplingCounter, W1
003056  203E80     MOV #0x3E8, W0
003058  508F80     SUB W1, W0, [W15]
00305A  360002     BRA LEU, 0x3060
46:                        TemperatureAdSamplingCounter = 0;
00305C  EF28C4     CLR TemperatureAdSamplingCounter
47:                        ADCPC0bits.SWTRG0 = 1;
00305E  A8A30A     BSET ADCPC0, #5
48:                    }
49:                
50:                    if (indxWaterTemperature == 5) {
003060  804610     MOV indxWaterTemperature, W0
003062  500FE5     SUB W0, #0x5, [W15]
003064  3A002C     BRA NZ, 0x30BE
51:                        indxWaterTemperature = 0;
003066  EF28C2     CLR indxWaterTemperature
52:                        ActualWaterTemperature = 0;
003068  B80060     MUL.UU W0, #0, W0
00306A  8846C0     MOV W0, 0x8D8
00306C  8846D1     MOV W1, 0x8DA
53:                        for (i = 0; i < 5; i++) {
00306E  EB0000     CLR W0
003070  780F00     MOV W0, [W14]
003072  370010     BRA 0x3094
003092  E80F1E     INC [W14], [W14]
003094  78001E     MOV [W14], W0
003096  500FE4     SUB W0, #0x4, [W15]
003098  36FFED     BRA LEU, 0x3074
54:                            ActualWaterTemperature = (float) ActualWaterTemperature + WaterTemperature[i];
003074  78001E     MOV [W14], W0
003076  400080     ADD W0, W0, W1
003078  20BA60     MOV #0xBA6, W0
00307A  408000     ADD W1, W0, W0
00307C  780010     MOV [W0], W0
00307E  EB0080     CLR W1
003080  07F108     RCALL 0x1292
003082  BE0200     MOV.D W0, W4
003084  8046C0     MOV 0x8D8, W0
003086  8046D1     MOV 0x8DA, W1
003088  BE0100     MOV.D W0, W2
00308A  BE0004     MOV.D W4, W0
00308C  07F023     RCALL 0x10D4
00308E  8846C0     MOV W0, 0x8D8
003090  8846D1     MOV W1, 0x8DA
55:                        }
56:                        tVal = (float) ActualWaterTemperature / 5.0;
00309A  8046C0     MOV 0x8D8, W0
00309C  8046D1     MOV 0x8DA, W1
00309E  200002     MOV #0x0, W2
0030A0  240A03     MOV #0x40A0, W3
0030A2  07F075     RCALL 0x118E
0030A4  980710     MOV W0, [W14+2]
0030A6  980721     MOV W1, [W14+4]
57:                        ActualWaterTemperature = (float) tVal * 3.2 / 10.0;
0030A8  2CCCD2     MOV #0xCCCD, W2
0030AA  2404C3     MOV #0x404C, W3
0030AC  90001E     MOV [W14+2], W0
0030AE  9000AE     MOV [W14+4], W1
0030B0  07F145     RCALL 0x133C
0030B2  200002     MOV #0x0, W2
0030B4  241203     MOV #0x4120, W3
0030B6  07F06B     RCALL 0x118E
0030B8  8846C0     MOV W0, 0x8D8
0030BA  8846D1     MOV W1, 0x8DA
58:                        Devices.WaterTemperatureValueIsReady = 1;
0030BC  A8A876     BSET Devices, #5
59:                    }
60:                
61:                    switch (current_fan_task) {
0030BE  804600     MOV current_fan_task, W0
0030C0  500FE2     SUB W0, #0x2, [W15]
0030C2  320017     BRA Z, 0x30F2
0030C4  500FE2     SUB W0, #0x2, [W15]
0030C6  3E0005     BRA GTU, 0x30D2
0030C8  E00000     CP0 W0
0030CA  320006     BRA Z, 0x30D8
0030CC  500FE1     SUB W0, #0x1, [W15]
0030CE  320009     BRA Z, 0x30E2
0030D0  370109     BRA 0x32E4
0030D2  500FE3     SUB W0, #0x3, [W15]
0030D4  3200DD     BRA Z, 0x3290
62:                        case FAN_INIT_TASK:
63:                            PDC2 = FAN_PWM_FREQ * 1;
0030D8  279180     MOV #0x7918, W0
0030DA  882230     MOV W0, PDC2
64:                            current_fan_task = FAN_WAIT_FOR_SPEED_UPDATE;
0030DC  200010     MOV #0x1, W0
0030DE  884600     MOV W0, current_fan_task
65:                            break;
0030E0  370101     BRA 0x32E4
66:                
67:                        case FAN_WAIT_FOR_SPEED_UPDATE:
68:                            if (Devices.WaterTemperatureValueIsReady)current_fan_task = FAN_SPEED_UPDATE;
0030E2  8043B1     MOV Devices, W1
0030E4  200200     MOV #0x20, W0
0030E6  608000     AND W1, W0, W0
0030E8  E00000     CP0 W0
0030EA  3200F7     BRA Z, 0x32DA
0030EC  200020     MOV #0x2, W0
0030EE  884600     MOV W0, current_fan_task
69:                            break;
0030F0  3700F9     BRA 0x32E4
0032DA  000000     NOP
0032DC  370003     BRA 0x32E4
70:                
71:                        case FAN_SPEED_UPDATE:
72:                            Devices.WaterTemperatureValueIsReady = 0;
0030F2  A9A876     BCLR Devices, #5
73:                            current_fan_task = FAN_WAIT_FOR_SPEED_UPDATE;
0030F4  200010     MOV #0x1, W0
0030F6  884600     MOV W0, current_fan_task
74:                            if ((ActualWaterTemperature >= 0) && (ActualWaterTemperature <= 10)) {
0030F8  8046C0     MOV 0x8D8, W0
0030FA  8046D1     MOV 0x8DA, W1
0030FC  B3C018     MOV.B #0x1, W8
0030FE  B81160     MUL.UU W2, #0, W2
003100  07F08A     RCALL 0x1216
003102  E00000     CP0 W0
003104  3D0001     BRA GE, 0x3108
003106  EB4400     CLR.B W8
003108  E00408     CP0.B W8
00310A  320013     BRA Z, 0x3132
00310C  8046C0     MOV 0x8D8, W0
00310E  8046D1     MOV 0x8DA, W1
003110  B3C018     MOV.B #0x1, W8
003112  200002     MOV #0x0, W2
003114  241203     MOV #0x4120, W3
003116  07F07D     RCALL 0x1212
003118  E00000     CP0 W0
00311A  340001     BRA LE, 0x311E
00311C  EB4400     CLR.B W8
00311E  E00408     CP0.B W8
003120  320008     BRA Z, 0x3132
75:                                FaultNumber = FAULT_COOL_SYS_TEMP_SENSOR;
003122  2001B0     MOV #0x1B, W0
003124  8843C0     MOV W0, FaultNumber
76:                                Devices.SystemStatedUpdate = TRUE;
003126  A80877     BSET 0x877, #0
77:                                SystemStateToUpdate = SYS_STATE_FAULT;
003128  2000F0     MOV #0xF, W0
00312A  8846E0     MOV W0, 0x8DC
78:                                current_fan_task = FAN_SYSTEM_FAULT;
00312C  200040     MOV #0x4, W0
00312E  884600     MOV W0, current_fan_task
003130  3700AE     BRA 0x328E
79:                            } else if ((ActualWaterTemperature >= 11) && (ActualWaterTemperature <= 33))PDC2 = FAN_PWM_FREQ * 0.8;//* 0.6;
003132  8046C0     MOV 0x8D8, W0
003134  8046D1     MOV 0x8DA, W1
003136  B3C018     MOV.B #0x1, W8
003138  200002     MOV #0x0, W2
00313A  241303     MOV #0x4130, W3
00313C  07F06C     RCALL 0x1216
00313E  E00000     CP0 W0
003140  3D0001     BRA GE, 0x3144
003142  EB4400     CLR.B W8
003144  E00408     CP0.B W8
003146  32000E     BRA Z, 0x3164
003148  8046C0     MOV 0x8D8, W0
00314A  8046D1     MOV 0x8DA, W1
00314C  B3C018     MOV.B #0x1, W8
00314E  200002     MOV #0x0, W2
003150  242043     MOV #0x4204, W3
003152  07F05F     RCALL 0x1212
003154  E00000     CP0 W0
003156  340001     BRA LE, 0x315A
003158  EB4400     CLR.B W8
00315A  E00408     CP0.B W8
00315C  320003     BRA Z, 0x3164
00315E  260E00     MOV #0x60E0, W0
003160  882230     MOV W0, PDC2
003162  370095     BRA 0x328E
80:                            else if ((ActualWaterTemperature >= 34) && (ActualWaterTemperature <= 38))PDC2 = FAN_PWM_FREQ * 0.8;//* 0.7;
003164  8046C0     MOV 0x8D8, W0
003166  8046D1     MOV 0x8DA, W1
003168  B3C018     MOV.B #0x1, W8
00316A  200002     MOV #0x0, W2
00316C  242083     MOV #0x4208, W3
00316E  07F053     RCALL 0x1216
003170  E00000     CP0 W0
003172  3D0001     BRA GE, 0x3176
003174  EB4400     CLR.B W8
003176  E00408     CP0.B W8
003178  32000E     BRA Z, 0x3196
00317A  8046C0     MOV 0x8D8, W0
00317C  8046D1     MOV 0x8DA, W1
00317E  B3C018     MOV.B #0x1, W8
003180  200002     MOV #0x0, W2
003182  242183     MOV #0x4218, W3
003184  07F046     RCALL 0x1212
003186  E00000     CP0 W0
003188  340001     BRA LE, 0x318C
00318A  EB4400     CLR.B W8
00318C  E00408     CP0.B W8
00318E  320003     BRA Z, 0x3196
003190  260E00     MOV #0x60E0, W0
003192  882230     MOV W0, PDC2
003194  37007C     BRA 0x328E
81:                            else if ((ActualWaterTemperature >= 39) && (ActualWaterTemperature <= 43))PDC2 = FAN_PWM_FREQ * 0.8;//* 0.8;
003196  8046C0     MOV 0x8D8, W0
003198  8046D1     MOV 0x8DA, W1
00319A  B3C018     MOV.B #0x1, W8
00319C  200002     MOV #0x0, W2
00319E  2421C3     MOV #0x421C, W3
0031A0  07F03A     RCALL 0x1216
0031A2  E00000     CP0 W0
0031A4  3D0001     BRA GE, 0x31A8
0031A6  EB4400     CLR.B W8
0031A8  E00408     CP0.B W8
0031AA  32000E     BRA Z, 0x31C8
0031AC  8046C0     MOV 0x8D8, W0
0031AE  8046D1     MOV 0x8DA, W1
0031B0  B3C018     MOV.B #0x1, W8
0031B2  200002     MOV #0x0, W2
0031B4  2422C3     MOV #0x422C, W3
0031B6  07F02D     RCALL 0x1212
0031B8  E00000     CP0 W0
0031BA  340001     BRA LE, 0x31BE
0031BC  EB4400     CLR.B W8
0031BE  E00408     CP0.B W8
0031C0  320003     BRA Z, 0x31C8
0031C2  260E00     MOV #0x60E0, W0
0031C4  882230     MOV W0, PDC2
0031C6  370063     BRA 0x328E
82:                            else if ((ActualWaterTemperature >= 44) && (ActualWaterTemperature <= 48))PDC2 = FAN_PWM_FREQ * 0.8;//* 0.9;
0031C8  8046C0     MOV 0x8D8, W0
0031CA  8046D1     MOV 0x8DA, W1
0031CC  B3C018     MOV.B #0x1, W8
0031CE  200002     MOV #0x0, W2
0031D0  242303     MOV #0x4230, W3
0031D2  07F021     RCALL 0x1216
0031D4  E00000     CP0 W0
0031D6  3D0001     BRA GE, 0x31DA
0031D8  EB4400     CLR.B W8
0031DA  E00408     CP0.B W8
0031DC  32000E     BRA Z, 0x31FA
0031DE  8046C0     MOV 0x8D8, W0
0031E0  8046D1     MOV 0x8DA, W1
0031E2  B3C018     MOV.B #0x1, W8
0031E4  200002     MOV #0x0, W2
0031E6  242403     MOV #0x4240, W3
0031E8  07F014     RCALL 0x1212
0031EA  E00000     CP0 W0
0031EC  340001     BRA LE, 0x31F0
0031EE  EB4400     CLR.B W8
0031F0  E00408     CP0.B W8
0031F2  320003     BRA Z, 0x31FA
0031F4  260E00     MOV #0x60E0, W0
0031F6  882230     MOV W0, PDC2
0031F8  37004A     BRA 0x328E
83:                            else if ((ActualWaterTemperature >= 49) && (ActualWaterTemperature <= 53))PDC2 = FAN_PWM_FREQ;
0031FA  8046C0     MOV 0x8D8, W0
0031FC  8046D1     MOV 0x8DA, W1
0031FE  B3C018     MOV.B #0x1, W8
003200  200002     MOV #0x0, W2
003202  242443     MOV #0x4244, W3
003204  07F008     RCALL 0x1216
003206  E00000     CP0 W0
003208  3D0001     BRA GE, 0x320C
00320A  EB4400     CLR.B W8
00320C  E00408     CP0.B W8
00320E  32000E     BRA Z, 0x322C
003210  8046C0     MOV 0x8D8, W0
003212  8046D1     MOV 0x8DA, W1
003214  B3C018     MOV.B #0x1, W8
003216  200002     MOV #0x0, W2
003218  242543     MOV #0x4254, W3
00321A  07EFFB     RCALL 0x1212
00321C  E00000     CP0 W0
00321E  340001     BRA LE, 0x3222
003220  EB4400     CLR.B W8
003222  E00408     CP0.B W8
003224  320003     BRA Z, 0x322C
003226  279180     MOV #0x7918, W0
003228  882230     MOV W0, PDC2
00322A  370031     BRA 0x328E
84:                            else if ((ActualWaterTemperature >= 54) && (ActualWaterTemperature <= 65)) {
00322C  8046C0     MOV 0x8D8, W0
00322E  8046D1     MOV 0x8DA, W1
003230  B3C018     MOV.B #0x1, W8
003232  200002     MOV #0x0, W2
003234  242583     MOV #0x4258, W3
003236  07EFEF     RCALL 0x1216
003238  E00000     CP0 W0
00323A  3D0001     BRA GE, 0x323E
00323C  EB4400     CLR.B W8
00323E  E00408     CP0.B W8
003240  320013     BRA Z, 0x3268
003242  8046C0     MOV 0x8D8, W0
003244  8046D1     MOV 0x8DA, W1
003246  B3C018     MOV.B #0x1, W8
003248  200002     MOV #0x0, W2
00324A  242823     MOV #0x4282, W3
00324C  07EFE2     RCALL 0x1212
00324E  E00000     CP0 W0
003250  340001     BRA LE, 0x3254
003252  EB4400     CLR.B W8
003254  E00408     CP0.B W8
003256  320008     BRA Z, 0x3268
85:                                FaultNumber = FAULT_COOLING_SYSTEM_OVERTEMPERATURE;
003258  2001E0     MOV #0x1E, W0
00325A  8843C0     MOV W0, FaultNumber
86:                                Devices.SystemStatedUpdate = TRUE;
00325C  A80877     BSET 0x877, #0
87:                                SystemStateToUpdate = SYS_STATE_FAULT;
00325E  2000F0     MOV #0xF, W0
003260  8846E0     MOV W0, 0x8DC
88:                                current_fan_task = FAN_OVERTEMPERATURE;
003262  200030     MOV #0x3, W0
003264  884600     MOV W0, current_fan_task
003266  370013     BRA 0x328E
89:                            } else if (ActualWaterTemperature >= 66) {
003268  8046C0     MOV 0x8D8, W0
00326A  8046D1     MOV 0x8DA, W1
00326C  B3C018     MOV.B #0x1, W8
00326E  200002     MOV #0x0, W2
003270  242843     MOV #0x4284, W3
003272  07EFD1     RCALL 0x1216
003274  E00000     CP0 W0
003276  3D0001     BRA GE, 0x327A
003278  EB4400     CLR.B W8
00327A  E00408     CP0.B W8
00327C  320030     BRA Z, 0x32DE
90:                                FaultNumber = FAULT_COOL_SYS_TEMP_SENSOR;
00327E  2001B0     MOV #0x1B, W0
003280  8843C0     MOV W0, FaultNumber
91:                                Devices.SystemStatedUpdate = TRUE;
003282  A80877     BSET 0x877, #0
92:                                SystemStateToUpdate = SYS_STATE_FAULT;
003284  2000F0     MOV #0xF, W0
003286  8846E0     MOV W0, 0x8DC
93:                                current_fan_task = FAN_SYSTEM_FAULT;
003288  200040     MOV #0x4, W0
00328A  884600     MOV W0, current_fan_task
94:                            }
95:                            break;
00328C  37002B     BRA 0x32E4
00328E  37002A     BRA 0x32E4
0032DE  000000     NOP
0032E0  370001     BRA 0x32E4
96:                            //
97:                        case FAN_OVERTEMPERATURE:
98:                            if (ActualWaterTemperature <= 44){
003290  8046C0     MOV 0x8D8, W0
003292  8046D1     MOV 0x8DA, W1
003294  B3C018     MOV.B #0x1, W8
003296  200002     MOV #0x0, W2
003298  242303     MOV #0x4230, W3
00329A  07EFBB     RCALL 0x1212
00329C  E00000     CP0 W0
00329E  340001     BRA LE, 0x32A2
0032A0  EB4400     CLR.B W8
0032A2  E00408     CP0.B W8
0032A4  320007     BRA Z, 0x32B4
99:                                Devices.SystemStatedUpdate = TRUE;
0032A6  A80877     BSET 0x877, #0
100:                               SystemStateToUpdate = SYS_STATE_STANDBY;
0032A8  200100     MOV #0x10, W0
0032AA  8846E0     MOV W0, 0x8DC
101:                               FaultNumber = CLEAR;
0032AC  EF2878     CLR FaultNumber
102:                               current_fan_task = FAN_SPEED_UPDATE ;
0032AE  200020     MOV #0x2, W0
0032B0  884600     MOV W0, current_fan_task
103:                           }else if (ActualWaterTemperature >= 66) {
0032B4  8046C0     MOV 0x8D8, W0
0032B6  8046D1     MOV 0x8DA, W1
0032B8  B3C018     MOV.B #0x1, W8
0032BA  200002     MOV #0x0, W2
0032BC  242843     MOV #0x4284, W3
0032BE  07EFAB     RCALL 0x1216
0032C0  E00000     CP0 W0
0032C2  3D0001     BRA GE, 0x32C6
0032C4  EB4400     CLR.B W8
0032C6  E00408     CP0.B W8
0032C8  32000C     BRA Z, 0x32E2
104:                               FaultNumber = FAULT_COOL_SYS_TEMP_SENSOR;
0032CA  2001B0     MOV #0x1B, W0
0032CC  8843C0     MOV W0, FaultNumber
105:                               Devices.SystemStatedUpdate = TRUE;
0032CE  A80877     BSET 0x877, #0
106:                               SystemStateToUpdate = SYS_STATE_FAULT;
0032D0  2000F0     MOV #0xF, W0
0032D2  8846E0     MOV W0, 0x8DC
107:                               current_fan_task = FAN_SYSTEM_FAULT;
0032D4  200040     MOV #0x4, W0
0032D6  884600     MOV W0, current_fan_task
108:                           }
109:                           break;
0032B2  370018     BRA 0x32E4
0032D8  370005     BRA 0x32E4
0032E2  000000     NOP
110:                           //
111:                       case FAN_SYSTEM_FAULT:
112:                           //shut down system here
113:                           break;
0030D6  370106     BRA 0x32E4
114:                   }
115:               }
0032E4  78044F     MOV [--W15], W8
0032E6  FA8000     ULNK
0032E8  060000     RETURN
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/control.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"          /* User funct/params, such as InitApp              */
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define DIODE_MODE_TASK_WAIT        0
20:                #define DIODE_MODE_TASK_SELECTED    1
21:                #define DIODE_MODE_TASK_ACTIVATED   2
22:                #define DIODE_MODE_TASK_READY       3
23:                #define DIODE_MODE_TASK_STANDBY     4
24:                
25:                #define PULSE_TASK_WAIT_FOR_START_PULSE    7
26:                #define PULSE_TASK_WAIT_FOR_END_PULSE      1
27:                #define PULSE_TASK_TEST_IGBT_AFTER_PULSE   2
28:                #define PULSE_TASK_WAIT_OFF_TIME           3
29:                #define PULSE_TASK_WAIT_TRIGGER_RELEASE    4
30:                #define PULSE_TASK_WAIT_FOR_READY          5
31:                #define PULSE_TASK_FAULT                   6 
32:                /*================================================*/
33:                
34:                /*================= Variables ===============================*/
35:                u16 current_pulse_fire_task = 0;
36:                u16 current_diode_mode_task = 0;
37:                u16 offTimeCntr = 0;
38:                u16 SystemStateToUpdate = SYS_STATE_INIT;
39:                u16 MeasurePeriod = 1000;
40:                u16 SPIMeasure = 0;
41:                u16 DiodeCurrent1[5];
42:                u16 DiodeCurrent2[5];
43:                u16 ActualDiodeCurrent1 = 0;
44:                u16 ActualDiodeCurrent2 = 0;
45:                u16 ActualLddriverCurrent = 0;
46:                u16 MaxAllowedCurrent = 0;
47:                u16 MinAllowedCurrent = 0;
48:                u16 CapacitorAvarageRawValue = 0;
49:                
50:                extern u16 PumpVoltage;
51:                extern u16 cntSPIMeasure;
52:                extern u16 Trigger;
53:                extern u16 Pulse_Off_Time;
54:                extern float TecTreatmentTemperature;
55:                extern tPID fooPID;
56:                extern double Setpoint;
57:                extern u16 LddriverCurrent;
58:                extern u16 IndxDiodeCurrent;
59:                extern u16 CoolingLevel;
60:                /*================================================*/
61:                
62:                /*================= Functions ===============================*/
63:                void system_state_tasks(void);
64:                void SystemCheck(void);
65:                void pulse_fire_tasks(void);
66:                void diode_mode_tasks(void);
67:                void ShutDownIpl(void);
68:                void SystemToStndby(void);
69:                void IGBTDriverDown();
70:                void PowerDeliverySystemOff(void);
71:                void measurments_tasks(void);
72:                
73:                extern void pump_tasks(void);
74:                extern void simmer_tasks(void);
75:                extern void capacitors_bank_tasks(void);
76:                extern void app_short_tasks(void);
77:                extern void lihgtguide_short_task(void);
78:                extern void trigger_tasks(void);
79:                extern void fan_tasks(void);
80:                extern void interlock_tasks(void);
81:                extern void fan_tasks(void);
82:                extern void tip_tasks(void);
83:                extern void tec_tasks(void);
84:                extern void discharge_tasks(void);
85:                extern void LDDriver_tasks(void);
86:                extern void SetDriverCurrent(u16 val);
87:                extern unsigned int Spi1RxBuff[8] __attribute__((space(dma)));
88:                extern unsigned int Spi1TxBuff[8] __attribute__((space(dma)));
89:                
90:                /*================================================*/
91:                
92:                void SystemCheck(void) {
001B2A  FA0000     LNK #0x0
93:                    fan_tasks();
001B2C  070A91     RCALL fan_tasks
94:                    pump_tasks();
001B2E  070BF7     RCALL pump_tasks
95:                    system_state_tasks();
001B30  07000E     RCALL system_state_tasks
96:                    trigger_tasks();
001B32  0709D9     RCALL trigger_tasks
97:                    diode_mode_tasks();
001B34  0700C2     RCALL diode_mode_tasks
98:                    pulse_fire_tasks();
001B36  070103     RCALL pulse_fire_tasks
99:                    tec_tasks();
001B38  070738     RCALL tec_tasks
100:                   capacitors_bank_tasks();
001B3A  070CDD     RCALL capacitors_bank_tasks
101:                   LDDriver_tasks();
001B3C  070D6F     RCALL LDDriver_tasks
102:                   app_short_tasks();
001B3E  07097E     RCALL app_short_tasks
103:                   lihgtguide_short_task();
001B40  070921     RCALL lihgtguide_short_task
104:                   tip_tasks();
001B42  07FD56     RCALL tip_tasks
105:                   interlock_tasks();
001B44  070DBB     RCALL interlock_tasks
106:                   discharge_tasks();
001B46  070D9C     RCALL discharge_tasks
107:                   measurments_tasks();
001B48  07015B     RCALL measurments_tasks
108:               }
001B4A  FA8000     ULNK
001B4C  060000     RETURN
109:               
110:               void system_state_tasks(void) {
001B4E  FA0000     LNK #0x0
111:               
112:                   if (Devices.SystemStatedUpdate) {
001B50  8043B1     MOV Devices, W1
001B52  201000     MOV #0x100, W0
001B54  608000     AND W1, W0, W0
001B56  E00000     CP0 W0
001B58  3200A0     BRA Z, 0x1C9A
113:                       switch (SystemStateToUpdate) {
001B5A  8046E0     MOV 0x8DC, W0
001B5C  500FF0     SUB W0, #0x10, [W15]
001B5E  320016     BRA Z, 0x1B8C
001B60  500FF0     SUB W0, #0x10, [W15]
001B62  3E0005     BRA GTU, 0x1B6E
001B64  500FE1     SUB W0, #0x1, [W15]
001B66  320047     BRA Z, 0x1BF6
001B68  500FEF     SUB W0, #0xF, [W15]
001B6A  320049     BRA Z, 0x1BFE
001B6C  370093     BRA 0x1C94
001B6E  200201     MOV #0x20, W1
001B70  500F81     SUB W0, W1, [W15]
001B72  320006     BRA Z, 0x1B80
001B74  200551     MOV #0x55, W1
001B76  500F81     SUB W0, W1, [W15]
001B78  320086     BRA Z, 0x1C86
001B7A  500FF5     SUB W0, #0x15, [W15]
001B7C  320014     BRA Z, 0x1BA6
001B7E  37008A     BRA 0x1C94
114:                           case SYS_STATE_READY:
115:                               if (SystemState == SYS_STATE_INIT)SystemStateToUpdate = SystemState; //prevent from system to enter in ready from init
001B80  8045D0     MOV 0x8BA, W0
001B82  500FE1     SUB W0, #0x1, [W15]
001B84  3A0082     BRA NZ, 0x1C8A
001B86  8045D0     MOV 0x8BA, W0
001B88  8846E0     MOV W0, 0x8DC
116:                               break;
001B8A  370084     BRA 0x1C94
001C8A  000000     NOP
001C8C  370003     BRA 0x1C94
117:               
118:                           case SYS_STATE_STANDBY:
119:                               //LD_INHIBIT1 = HIGH;
120:                               Devices.PumpIsEnabled = TRUE;
001B8C  A84876     BSET Devices, #2
121:                               Setpoint = 15.0;
001B8E  200000     MOV #0x0, W0
001B90  241701     MOV #0x4170, W1
001B92  8840F0     MOV W0, Setpoint
001B94  884101     MOV W1, 0x820
122:                               TEC_ENABLE = TRUE;
001B96  A8E2C5     BSET 0x2C5, #7
123:                               Devices.TecIsEnabled = TRUE;
001B98  A80876     BSET Devices, #0
124:                               Devices.PumpVoltageUpdate = TRUE;
001B9A  A88876     BSET Devices, #4
125:                               PumpVoltage = 500;
001B9C  201F40     MOV #0x1F4, W0
001B9E  884680     MOV W0, PumpVoltage
126:                               Devices.LddriverIsEnable = FALSE;
001BA0  A9C877     BCLR 0x877, #6
127:                               Devices.ChargerIsEnabled = FALSE; // enable charger
001BA2  A96877     BCLR 0x877, #3
128:                               break;
001BA4  370077     BRA 0x1C94
129:               
130:                           case SYS_STATE_PENDING:
131:                               Devices.PumpVoltageUpdate = TRUE;
001BA6  A88876     BSET Devices, #4
132:                               PumpVoltage = 920;
001BA8  203980     MOV #0x398, W0
001BAA  884680     MOV W0, PumpVoltage
133:                               if (CoolingLevel == 25)Setpoint = 7;
001BAC  804670     MOV 0x8CE, W0
001BAE  500FF9     SUB W0, #0x19, [W15]
001BB0  3A0005     BRA NZ, 0x1BBC
001BB2  200000     MOV #0x0, W0
001BB4  240E01     MOV #0x40E0, W1
001BB6  8840F0     MOV W0, Setpoint
001BB8  884101     MOV W1, 0x820
001BBA  37001A     BRA 0x1BF0
134:                               else if (CoolingLevel == 50)Setpoint = 5;
001BBC  804671     MOV 0x8CE, W1
001BBE  200320     MOV #0x32, W0
001BC0  508F80     SUB W1, W0, [W15]
001BC2  3A0005     BRA NZ, 0x1BCE
001BC4  200000     MOV #0x0, W0
001BC6  240A01     MOV #0x40A0, W1
001BC8  8840F0     MOV W0, Setpoint
001BCA  884101     MOV W1, 0x820
001BCC  370011     BRA 0x1BF0
135:                               else if (CoolingLevel == 75)Setpoint = 3;
001BCE  804671     MOV 0x8CE, W1
001BD0  2004B0     MOV #0x4B, W0
001BD2  508F80     SUB W1, W0, [W15]
001BD4  3A0005     BRA NZ, 0x1BE0
001BD6  200000     MOV #0x0, W0
001BD8  240401     MOV #0x4040, W1
001BDA  8840F0     MOV W0, Setpoint
001BDC  884101     MOV W1, 0x820
001BDE  370008     BRA 0x1BF0
136:                               else if (CoolingLevel == 100)Setpoint = 1; //set tec temperature
001BE0  804671     MOV 0x8CE, W1
001BE2  200640     MOV #0x64, W0
001BE4  508F80     SUB W1, W0, [W15]
001BE6  3A0004     BRA NZ, 0x1BF0
001BE8  200000     MOV #0x0, W0
001BEA  23F801     MOV #0x3F80, W1
001BEC  8840F0     MOV W0, Setpoint
001BEE  884101     MOV W1, 0x820
137:                               Devices.ChargerIsEnabled = TRUE; // enable charger
001BF0  A86877     BSET 0x877, #3
138:                               Devices.LddriverIsEnable = TRUE; //enable driver
001BF2  A8C877     BSET 0x877, #6
139:                               //LD_INHIBIT1 = LOW;
140:                               break;
001BF4  37004F     BRA 0x1C94
141:               
142:                           case SYS_STATE_INIT:
143:                               PowerDeliverySystemOff();
001BF6  070053     RCALL PowerDeliverySystemOff
144:                               Devices.PumpIsEnabled = FALSE;
001BF8  A94876     BCLR Devices, #2
145:                               Devices.PumpIsReady = FALSE;
001BFA  A96876     BCLR Devices, #3
146:                               break;
001BFC  37004B     BRA 0x1C94
147:               
148:                           case SYS_STATE_TECHMODE:
149:               
150:                               break;
001C86  000000     NOP
001C88  370005     BRA 0x1C94
151:               
152:                           case SYS_STATE_FAULT:
153:                               PowerDeliverySystemOff();
001BFE  07004F     RCALL PowerDeliverySystemOff
154:                               switch (FaultNumber) {
001C00  8043C0     MOV FaultNumber, W0
001C02  B80161     MUL.UU W0, #1, W2
001C04  2FFE80     MOV #0xFFE8, W0
001C06  2FFFF1     MOV #0xFFFF, W1
001C08  400002     ADD W0, W2, W0
001C0A  488083     ADDC W1, W3, W1
001C0C  200132     MOV #0x13, W2
001C0E  200003     MOV #0x0, W3
001C10  500F82     SUB W0, W2, [W15]
001C12  588F83     SUBB W1, W3, [W15]
001C14  3E003C     BRA GTU, 0x1C8E
001C16  016000     BRA W0
001C18  37002C     BRA 0x1C72
001C1A  37003B     BRA 0x1C92
001C1C  370017     BRA 0x1C4C
001C1E  370019     BRA 0x1C52
001C20  37000F     BRA 0x1C40
001C22  370037     BRA 0x1C92
001C24  370019     BRA 0x1C58
001C26  370035     BRA 0x1C92
001C28  37000E     BRA 0x1C46
001C2A  370033     BRA 0x1C92
001C2C  370032     BRA 0x1C92
001C2E  370031     BRA 0x1C92
001C30  370030     BRA 0x1C92
001C32  370013     BRA 0x1C5A
001C34  37002E     BRA 0x1C92
001C36  370014     BRA 0x1C60
001C38  37002C     BRA 0x1C92
001C3A  370015     BRA 0x1C66
001C3C  370017     BRA 0x1C6C
001C3E  370021     BRA 0x1C82
155:                                   case FAULT_COOLING_SYSTEM:
156:                                       Devices.PumpIsEnabled = FALSE;
001C40  A94876     BCLR Devices, #2
157:                                       Devices.PumpIsReady = FALSE;
001C42  A96876     BCLR Devices, #3
158:                                       break;
001C44  37001F     BRA 0x1C84
159:               
160:                                   case FAULT_DIODE_CURRENT:
161:                                       Devices.PumpIsEnabled = FALSE;
001C46  A94876     BCLR Devices, #2
162:                                       Devices.PumpIsReady = FALSE;
001C48  A96876     BCLR Devices, #3
163:                                       break;
001C4A  37001C     BRA 0x1C84
164:               
165:                                   case FAULT_APPLICATOR_DISCONNECTED:
166:                                       Devices.PumpIsEnabled = FALSE;
001C4C  A94876     BCLR Devices, #2
167:                                       Devices.PumpIsReady = FALSE;
001C4E  A96876     BCLR Devices, #3
168:                                       break;
001C50  370019     BRA 0x1C84
169:               
170:                                   case FAULT_COOL_SYS_TEMP_SENSOR:
171:                                       Devices.PumpIsEnabled = FALSE;
001C52  A94876     BCLR Devices, #2
172:                                       Devices.PumpIsReady = FALSE;
001C54  A96876     BCLR Devices, #3
173:                                       break;
001C56  370016     BRA 0x1C84
174:               
175:                                   case FAULT_COOLING_SYSTEM_OVERTEMPERATURE:
176:               
177:                                       break;
001C58  370015     BRA 0x1C84
178:               
179:                                   case FAULT_LIGHTGUIDE_DISCONNECTED:
180:                                       Devices.PumpIsEnabled = FALSE;
001C5A  A94876     BCLR Devices, #2
181:                                       Devices.PumpIsReady = FALSE;
001C5C  A96876     BCLR Devices, #3
182:                                       break;
001C5E  370012     BRA 0x1C84
183:               
184:                                   case FAULT_NO_ID:
185:                                       Devices.PumpIsEnabled = FALSE;
001C60  A94876     BCLR Devices, #2
186:                                       Devices.PumpIsReady = FALSE;
001C62  A96876     BCLR Devices, #3
187:                                       break;
001C64  37000F     BRA 0x1C84
188:               
189:                                   case FAULT_CAPACITOR_CHARGER:
190:                                       Devices.PumpIsEnabled = FALSE;
001C66  A94876     BCLR Devices, #2
191:                                       Devices.PumpIsReady = FALSE;
001C68  A96876     BCLR Devices, #3
192:                                       break;
001C6A  37000C     BRA 0x1C84
193:               
194:                                   case FAULT_PUMP_DRIVER:
195:                                       Devices.PumpIsEnabled = FALSE;
001C6C  A94876     BCLR Devices, #2
196:                                       Devices.PumpIsReady = FALSE;
001C6E  A96876     BCLR Devices, #3
197:                                       break;
001C70  370009     BRA 0x1C84
198:               
199:                                   case FAULT_INTERLOCK:
200:                                       Setpoint = 15.0;
001C72  200000     MOV #0x0, W0
001C74  241701     MOV #0x4170, W1
001C76  8840F0     MOV W0, Setpoint
001C78  884101     MOV W1, 0x820
201:                                       Devices.PumpVoltageUpdate = TRUE;
001C7A  A88876     BSET Devices, #4
202:                                       PumpVoltage = 500;
001C7C  201F40     MOV #0x1F4, W0
001C7E  884680     MOV W0, PumpVoltage
203:                                       break;
001C80  370001     BRA 0x1C84
204:               
205:                                   case FAULT_UNKNOWN_LIGHTGUIDE_TYPE:
206:               
207:                                       break;
001C82  000000     NOP
208:                               }
209:                               break;
001C84  370007     BRA 0x1C94
001C8E  000000     NOP
001C90  370001     BRA 0x1C94
001C92  000000     NOP
210:                       }
211:               
212:                       SystemState = SystemStateToUpdate;
001C94  8046E0     MOV 0x8DC, W0
001C96  8845D0     MOV W0, 0x8BA
213:                       Devices.SystemStatedUpdate = FALSE;
001C98  A90877     BCLR 0x877, #0
214:                   }
215:               }
001C9A  FA8000     ULNK
001C9C  060000     RETURN
216:               
217:               /**********************************************************************
218:                * Function:        void PowerDeliverySystemOff(void) 
219:                * PreCondition:    None
220:                * Input:	    None
221:                * Output:	    None
222:                * Overview:	    This function cut off all power delivery system
223:                *
224:                ***********************************************************************/
225:               void PowerDeliverySystemOff(void) {
001C9E  FA0000     LNK #0x0
226:                   SAFE_IGBT_EN = LOW;
001CA0  A9E2F5     BCLR 0x2F5, #7
227:                   LD_INHIBIT1 = 1;
001CA2  A882DC     BSET LATD, #4
228:                   LD_EN_PWM = 0;
001CA4  A9E423     BCLR 0x423, #7
229:                   T2CONbits.TON = 0;
001CA6  A9E111     BCLR 0x111, #7
230:                   T4CONbits.TON = 0;
001CA8  A9E11F     BCLR 0x11F, #7
231:                   CHARGER_ENABLE = HIGH; //disable charger 
001CAA  A822F5     BSET 0x2F5, #1
232:                   //DISCHARGE = LOW; //start discharge
233:                   Devices.ChargerIsReady = FALSE;
001CAC  A98877     BCLR 0x877, #4
234:                   Devices.ChargerIsEnabled = FALSE;
001CAE  A96877     BCLR 0x877, #3
235:                   Devices.LddriverIsEnable = FALSE;
001CB0  A9C877     BCLR 0x877, #6
236:                   TEC_ENABLE = CLEAR;
001CB2  A9E2C5     BCLR 0x2C5, #7
237:                   Devices.TecIsEnabled = FALSE;
001CB4  A90876     BCLR Devices, #0
238:               }
001CB6  FA8000     ULNK
001CB8  060000     RETURN
239:               
240:               /**********************************************************************
241:                * Function:        void diode_mode_tasks(void)
242:                * PreCondition:    None
243:                * Input:	    None
244:                * Output:	    None
245:                * Overview:	    This manage the system after diode is selescted
246:                *
247:                ***********************************************************************/
248:               void diode_mode_tasks(void) {
001CBA  FA0000     LNK #0x0
249:                   switch (current_diode_mode_task) {
001CBC  804280     MOV current_diode_mode_task, W0
001CBE  500FE2     SUB W0, #0x2, [W15]
001CC0  320018     BRA Z, 0x1CF2
001CC2  500FE2     SUB W0, #0x2, [W15]
001CC4  3E0005     BRA GTU, 0x1CD0
001CC6  E00000     CP0 W0
001CC8  320008     BRA Z, 0x1CDA
001CCA  500FE1     SUB W0, #0x1, [W15]
001CCC  32000C     BRA Z, 0x1CE6
001CCE  370035     BRA 0x1D3A
001CD0  500FE3     SUB W0, #0x3, [W15]
001CD2  320020     BRA Z, 0x1D14
001CD4  500FE4     SUB W0, #0x4, [W15]
001CD6  320024     BRA Z, 0x1D20
001CD8  370030     BRA 0x1D3A
250:                       case DIODE_MODE_TASK_WAIT:
251:                           if (SystemState == SYS_STATE_STANDBY) {
001CDA  8045D0     MOV 0x8BA, W0
001CDC  500FF0     SUB W0, #0x10, [W15]
001CDE  3A0026     BRA NZ, 0x1D2C
252:                               current_diode_mode_task = DIODE_MODE_TASK_SELECTED;
001CE0  200010     MOV #0x1, W0
001CE2  884280     MOV W0, current_diode_mode_task
253:                           }
254:                           break;
001CE4  37002A     BRA 0x1D3A
001D2C  000000     NOP
001D2E  370005     BRA 0x1D3A
255:               
256:                       case DIODE_MODE_TASK_SELECTED:
257:                           if (SystemState == SYS_STATE_PENDING) {
001CE6  8045D0     MOV 0x8BA, W0
001CE8  500FF5     SUB W0, #0x15, [W15]
001CEA  3A0022     BRA NZ, 0x1D30
258:                               current_diode_mode_task = DIODE_MODE_TASK_ACTIVATED;
001CEC  200020     MOV #0x2, W0
001CEE  884280     MOV W0, current_diode_mode_task
259:                           }
260:                           break;
001CF0  370024     BRA 0x1D3A
001D30  000000     NOP
001D32  370003     BRA 0x1D3A
261:               
262:                       case DIODE_MODE_TASK_ACTIVATED:
263:                           if ((Devices.PumpIsReady == TRUE)&&(Devices.ChargerIsReady == TRUE)) {
001CF2  8043B0     MOV Devices, W0
001CF4  600068     AND W0, #0x8, W0
001CF6  E00000     CP0 W0
001CF8  320008     BRA Z, 0x1D0A
001CFA  8043B1     MOV Devices, W1
001CFC  210000     MOV #0x1000, W0
001CFE  608000     AND W1, W0, W0
001D00  E00000     CP0 W0
001D02  320003     BRA Z, 0x1D0A
264:                               current_diode_mode_task = DIODE_MODE_TASK_READY;
001D04  200030     MOV #0x3, W0
001D06  884280     MOV W0, current_diode_mode_task
265:                           } else if (SystemState != SYS_STATE_PENDING) {
001D0A  8045D0     MOV 0x8BA, W0
001D0C  500FF5     SUB W0, #0x15, [W15]
001D0E  320012     BRA Z, 0x1D34
266:                               current_diode_mode_task = DIODE_MODE_TASK_WAIT;
001D10  EF2850     CLR current_diode_mode_task
267:                           }
268:                           break;
001D08  370018     BRA 0x1D3A
001D12  370013     BRA 0x1D3A
001D34  000000     NOP
001D36  370001     BRA 0x1D3A
269:               
270:                       case DIODE_MODE_TASK_READY:
271:                           SystemStateToUpdate = SYS_STATE_READY;
001D14  200200     MOV #0x20, W0
001D16  8846E0     MOV W0, 0x8DC
272:                           Devices.SystemStatedUpdate = TRUE;
001D18  A80877     BSET 0x877, #0
273:                           current_diode_mode_task = DIODE_MODE_TASK_STANDBY;
001D1A  200040     MOV #0x4, W0
001D1C  884280     MOV W0, current_diode_mode_task
274:                           break;
001D1E  37000D     BRA 0x1D3A
275:               
276:                       case DIODE_MODE_TASK_STANDBY:
277:                           if (SystemState != SYS_STATE_READY) {
001D20  8045D1     MOV 0x8BA, W1
001D22  200200     MOV #0x20, W0
001D24  508F80     SUB W1, W0, [W15]
001D26  320008     BRA Z, 0x1D38
278:                               current_diode_mode_task = DIODE_MODE_TASK_WAIT;
001D28  EF2850     CLR current_diode_mode_task
279:                           }
280:                           break;
001D2A  370007     BRA 0x1D3A
001D38  000000     NOP
281:                   }
282:               }
001D3A  FA8000     ULNK
001D3C  060000     RETURN
283:               
284:               /**********************************************************************
285:                * Function:        void pulse_fire_tasks(void)
286:                * PreCondition:    None
287:                * Input:	    None
288:                * Output:	    None
289:                * Overview:	    This manage the pulse fire
290:                *
291:                ***********************************************************************/
292:               void pulse_fire_tasks(void) {
001D3E  FA0000     LNK #0x0
293:                   if (SystemState == SYS_STATE_READY) {//check if system ready
001D40  8045D1     MOV 0x8BA, W1
001D42  200200     MOV #0x20, W0
001D44  508F80     SUB W1, W0, [W15]
001D46  3A004F     BRA NZ, 0x1DE6
294:                       switch (current_pulse_fire_task) {
001D48  804270     MOV current_pulse_fire_task, W0
001D4A  500FE3     SUB W0, #0x3, [W15]
001D4C  320038     BRA Z, 0x1DBE
001D4E  500FE3     SUB W0, #0x3, [W15]
001D50  3E0003     BRA GTU, 0x1D58
001D52  500FE1     SUB W0, #0x1, [W15]
001D54  32001F     BRA Z, 0x1D94
001D58  500FE4     SUB W0, #0x4, [W15]
001D5A  32003F     BRA Z, 0x1DDA
001D5C  500FE7     SUB W0, #0x7, [W15]
001D5E  3A0047     BRA NZ, 0x1DEE
295:                           case PULSE_TASK_WAIT_FOR_START_PULSE:
296:                               if (Trigger) {//check if triger pushed and pulse enableed
001D60  804530     MOV Trigger, W0
001D62  E00000     CP0 W0
001D64  320014     BRA Z, 0x1D8E
297:                                   Devices.PulseInProgress = 1; //                              
001D66  A8E876     BSET Devices, #7
298:                                   //LD_INHIBIT1 = LOW;
299:                                   TRISEbits.TRISE1 = OUTPUT;
001D68  A922E0     BCLR TRISE, #1
300:                                   PULSE_PWM = LOW;
001D6A  A922E4     BCLR LATE, #1
301:                                   PDC1 = 50;
001D6C  200320     MOV #0x32, W0
001D6E  882130     MOV W0, PDC1
302:                                   SDC1 = 50;
001D70  200320     MOV #0x32, W0
001D72  882170     MOV W0, SDC1
303:                                   LD_EN_PWM = ENABLE;
001D74  A8E423     BSET 0x423, #7
304:                                   LED0 = HIGH;
001D76  A8C2DD     BSET 0x2DD, #6
305:                                   PR2 = Pulse_On_Time; // set pulse time
001D78  8045E0     MOV 0x8BC, W0
001D7A  880860     MOV W0, PR2
306:                                   TMR2 = 0; //reset timer
001D7C  EF2106     CLR TMR2
307:                                   IFS0bits.T2IF = CLEAR; /* reset Timer2 interrupt flag */
001D7E  A9E084     BCLR IFS0, #7
308:                                   T2CONbits.TON = 1; // Enable Timer2 and start the counter
001D80  A8E111     BSET 0x111, #7
309:                                   TMR4 = 0; //reset timer
001D82  EF2114     CLR TMR4
310:                                   IFS1bits.T4IF = CLEAR; /* reset Timer4 interrupt flag */
001D84  A96087     BCLR 0x87, #3
311:                                   T4CONbits.TON = 1; // Enable Timer4 and start the counter
001D86  A8E11F     BSET 0x11F, #7
312:                                   current_pulse_fire_task = PULSE_TASK_WAIT_FOR_END_PULSE;
001D88  200010     MOV #0x1, W0
001D8A  884270     MOV W0, current_pulse_fire_task
313:                               } else {
314:                                   //LD_INHIBIT1 = HIGH;
315:                                   LD_EN_PWM = 0;
001D8E  A9E423     BCLR 0x423, #7
316:                                   PULSE_PWM = 0;
001D90  A922E4     BCLR LATE, #1
317:                               }
318:                               break;
001D8C  370037     BRA 0x1DFC
001D92  370034     BRA 0x1DFC
319:               
320:                           case PULSE_TASK_WAIT_FOR_END_PULSE:
321:                               if (!Devices.PulseInProgress) {
001D94  8043B1     MOV Devices, W1
001D96  200800     MOV #0x80, W0
001D98  608000     AND W1, W0, W0
001D9A  E00000     CP0 W0
001D9C  3A0003     BRA NZ, 0x1DA4
322:                                   current_pulse_fire_task = PULSE_TASK_WAIT_OFF_TIME;
001D9E  200030     MOV #0x3, W0
001DA0  884270     MOV W0, current_pulse_fire_task
323:                                   //LD_INHIBIT1 = LOW;
324:                               } else {
325:                                   if (Devices2.WrongCurrentDetected) {
001DA4  8045C1     MOV 0x8B8, W1
001DA6  201000     MOV #0x100, W0
001DA8  608000     AND W1, W0, W0
001DAA  E00000     CP0 W0
001DAC  320022     BRA Z, 0x1DF2
326:                                       FaultNumber = FAULT_DIODE_CURRENT; //time out occured 
001DAE  200200     MOV #0x20, W0
001DB0  8843C0     MOV W0, FaultNumber
327:                                       Devices.SystemStatedUpdate = TRUE;
001DB2  A80877     BSET 0x877, #0
328:                                       SystemStateToUpdate = SYS_STATE_FAULT;
001DB4  2000F0     MOV #0xF, W0
001DB6  8846E0     MOV W0, 0x8DC
329:                                       current_pulse_fire_task = PULSE_TASK_FAULT;
001DB8  200060     MOV #0x6, W0
001DBA  884270     MOV W0, current_pulse_fire_task
330:                                   }
331:                               }
332:                               break;
001DA2  37002C     BRA 0x1DFC
001DBC  37001F     BRA 0x1DFC
001DF2  000000     NOP
001DF4  370003     BRA 0x1DFC
333:               
334:                           case PULSE_TASK_WAIT_OFF_TIME:
335:                               if (offTimeCntr >= Pulse_Off_Time) {
001DBE  804291     MOV offTimeCntr, W1
001DC0  8045F0     MOV 0x8BE, W0
001DC2  508F80     SUB W1, W0, [W15]
001DC4  390018     BRA NC, 0x1DF6
336:                                   if (Devices2.AutoRepeat)current_pulse_fire_task = PULSE_TASK_WAIT_FOR_START_PULSE;
001DC6  8045C0     MOV 0x8B8, W0
001DC8  600064     AND W0, #0x4, W0
001DCA  E00000     CP0 W0
001DCC  320003     BRA Z, 0x1DD4
001DCE  200070     MOV #0x7, W0
001DD0  884270     MOV W0, current_pulse_fire_task
337:                                   else current_pulse_fire_task = PULSE_TASK_WAIT_TRIGGER_RELEASE;
001DD4  200040     MOV #0x4, W0
001DD6  884270     MOV W0, current_pulse_fire_task
338:                               }
339:                               break;
001DD2  370014     BRA 0x1DFC
001DD8  370011     BRA 0x1DFC
001DF6  000000     NOP
001DF8  370001     BRA 0x1DFC
340:               
341:                           case PULSE_TASK_WAIT_TRIGGER_RELEASE:
342:                               if (!Trigger)current_pulse_fire_task = PULSE_TASK_WAIT_FOR_START_PULSE;
001DDA  804530     MOV Trigger, W0
001DDC  E00000     CP0 W0
001DDE  3A000D     BRA NZ, 0x1DFA
001DE0  200070     MOV #0x7, W0
001DE2  884270     MOV W0, current_pulse_fire_task
343:                               break;
001D56  370052     BRA 0x1DFC
001DE4  37000B     BRA 0x1DFC
001DEE  000000     NOP
001DF0  370005     BRA 0x1DFC
001DFA  000000     NOP
344:                       }
345:                   } else {
346:                       Devices.PulseInProgress = 0;
001DE6  A9E876     BCLR Devices, #7
347:                       current_pulse_fire_task = PULSE_TASK_WAIT_FOR_START_PULSE;
001DE8  200070     MOV #0x7, W0
001DEA  884270     MOV W0, current_pulse_fire_task
001DEC  370007     BRA 0x1DFC
348:                   }
349:               }
001DFC  FA8000     ULNK
001DFE  060000     RETURN
350:               
351:               /**********************************************************************
352:                * Function:        void measurments_tasks(void)
353:                * PreCondition:    None
354:                * Input:	    None
355:                * Output:	    None
356:                * Overview:	    This function used to measure all spi a/d sensors
357:                *
358:                ***********************************************************************/
359:               void measurments_tasks(void) {
001E00  FA0004     LNK #0x4
360:                   u16 i;
361:                   u16 Val = 0;
001E02  EB0000     CLR W0
001E04  980710     MOV W0, [W14+2]
362:               
363:                   if (CommFlags.SPI1RxDone) {
001E06  8045B0     MOV 0x8B6, W0
001E08  600064     AND W0, #0x4, W0
001E0A  E00000     CP0 W0
001E0C  3200B3     BRA Z, 0x1F74
364:                       switch (SPIMeasure) {
001E0E  8042A0     MOV SPIMeasure, W0
001E10  500FE1     SUB W0, #0x1, [W15]
001E12  32000D     BRA Z, 0x1E2E
001E14  500FE1     SUB W0, #0x1, [W15]
001E16  390003     BRA NC, 0x1E1E
001E18  500FE2     SUB W0, #0x2, [W15]
001E1A  320040     BRA Z, 0x1E9C
001E1C  37009E     BRA 0x1F5A
365:                           case 0:
366:                               DMA0CONbits.CHEN = 1; // Enable DMA Channel
001E1E  A8E381     BSET 0x381, #7
367:                               DMA1CONbits.CHEN = 1; // Enable DMA Channel
001E20  A8E38D     BSET 0x38D, #7
368:                               LD_SPI_ENABLE = HIGH;
001E22  A842F4     BSET LATG, #2
369:                               CS_ADC_LD = LOW;
001E24  A902F5     BCLR 0x2F5, #0
370:                               DMA0REQbits.FORCE = 1;
001E26  A8E383     BSET 0x383, #7
371:                               CommFlags.SPI1RxDone = 0;
001E28  A948B6     BCLR 0x8B6, #2
372:                               IEC0bits.SPI1IE = 1;
001E2A  A84095     BSET 0x95, #2
373:                               break;
001E2C  3700A0     BRA 0x1F6E
374:               
375:                           case DIODE_VOLTAGE:
376:                               if (Devices.PulseInProgress) {
001E2E  8043B1     MOV Devices, W1
001E30  200800     MOV #0x80, W0
001E32  608000     AND W1, W0, W0
001E34  E00000     CP0 W0
001E36  32001D     BRA Z, 0x1E72
377:                                   for (i = 0; i < 8; i++) {
001E38  EB0000     CLR W0
001E3A  780F00     MOV W0, [W14]
001E3C  370014     BRA 0x1E66
001E64  E80F1E     INC [W14], [W14]
001E66  78001E     MOV [W14], W0
001E68  500FE7     SUB W0, #0x7, [W15]
001E6A  36FFE9     BRA LEU, 0x1E3E
378:                                       Spi1RxBuff[i] >>= 1;
001E3E  78001E     MOV [W14], W0
001E40  400080     ADD W0, W0, W1
001E42  22BF00     MOV #0x2BF0, W0
001E44  408000     ADD W1, W0, W0
001E46  780010     MOV [W0], W0
001E48  D10080     LSR W0, W1
001E4A  78001E     MOV [W14], W0
001E4C  400100     ADD W0, W0, W2
001E4E  22BF00     MOV #0x2BF0, W0
001E50  410000     ADD W2, W0, W0
001E52  780801     MOV W1, [W0]
379:                                       Val = Val + Spi1RxBuff[i];
001E54  78001E     MOV [W14], W0
001E56  400080     ADD W0, W0, W1
001E58  22BF00     MOV #0x2BF0, W0
001E5A  408000     ADD W1, W0, W0
001E5C  780010     MOV [W0], W0
001E5E  90009E     MOV [W14+2], W1
001E60  408000     ADD W1, W0, W0
001E62  980710     MOV W0, [W14+2]
380:                                   }
381:                                   DiodeVoltage = Val / 8;
001E6C  90001E     MOV [W14+2], W0
001E6E  DE0043     LSR W0, #3, W0
001E70  884420     MOV W0, DiodeVoltage
382:                                   //DiodeVoltage = (u32) Val * 49 * 798 / 1000; //voltage in mV
383:                               }
384:               
385:                               for (i = 0; i < 8; i++)Spi1TxBuff[i] = MCP3002_CH1;
001E72  EB0000     CLR W0
001E74  780F00     MOV W0, [W14]
001E76  370007     BRA 0x1E86
001E78  78001E     MOV [W14], W0
001E7A  400080     ADD W0, W0, W1
001E7C  22BE00     MOV #0x2BE0, W0
001E7E  408000     ADD W1, W0, W0
001E80  2E0001     MOV #0xE000, W1
001E82  780801     MOV W1, [W0]
001E84  E80F1E     INC [W14], [W14]
001E86  78001E     MOV [W14], W0
001E88  500FE7     SUB W0, #0x7, [W15]
001E8A  36FFF6     BRA LEU, 0x1E78
386:                               IEC0bits.SPI1IE = 1;
001E8C  A84095     BSET 0x95, #2
387:                               DMA0CONbits.CHEN = 1; // Enable DMA Channel
001E8E  A8E381     BSET 0x381, #7
388:                               DMA1CONbits.CHEN = 1; // Enable DMA Channel
001E90  A8E38D     BSET 0x38D, #7
389:                               LD_SPI_ENABLE = HIGH;
001E92  A842F4     BSET LATG, #2
390:                               CS_ADC_LD = LOW;
001E94  A902F5     BCLR 0x2F5, #0
391:                               DMA0REQbits.FORCE = 1;
001E96  A8E383     BSET 0x383, #7
392:                               CommFlags.SPI1RxDone = 0;
001E98  A948B6     BCLR 0x8B6, #2
393:                               break;
001E9A  370069     BRA 0x1F6E
394:               
395:                           case CAP_MONITOR:
396:                               if (!Devices.PulseInProgress) {
001E9C  8043B1     MOV Devices, W1
001E9E  200800     MOV #0x80, W0
001EA0  608000     AND W1, W0, W0
001EA2  E00000     CP0 W0
001EA4  3A004B     BRA NZ, 0x1F3C
397:                                   for (i = 0; i < 8; i++) {
001EA6  EB0000     CLR W0
001EA8  780F00     MOV W0, [W14]
001EAA  370028     BRA 0x1EFC
001EFA  E80F1E     INC [W14], [W14]
001EFC  78001E     MOV [W14], W0
001EFE  500FE7     SUB W0, #0x7, [W15]
001F00  36FFD5     BRA LEU, 0x1EAC
398:                                       Spi1RxBuff[i] >>= 1;
001EAC  78001E     MOV [W14], W0
001EAE  400080     ADD W0, W0, W1
001EB0  22BF00     MOV #0x2BF0, W0
001EB2  408000     ADD W1, W0, W0
001EB4  780010     MOV [W0], W0
001EB6  D10080     LSR W0, W1
001EB8  78001E     MOV [W14], W0
001EBA  400100     ADD W0, W0, W2
001EBC  22BF00     MOV #0x2BF0, W0
001EBE  410000     ADD W2, W0, W0
001EC0  780801     MOV W1, [W0]
399:                                       if ((Spi1RxBuff[i] > 1000) || (Spi1RxBuff[i] == 0)) {
001EC2  78001E     MOV [W14], W0
001EC4  400080     ADD W0, W0, W1
001EC6  22BF00     MOV #0x2BF0, W0
001EC8  408000     ADD W1, W0, W0
001ECA  780090     MOV [W0], W1
001ECC  203E80     MOV #0x3E8, W0
001ECE  508F80     SUB W1, W0, [W15]
001ED0  3E0007     BRA GTU, 0x1EE0
001ED2  78001E     MOV [W14], W0
001ED4  400080     ADD W0, W0, W1
001ED6  22BF00     MOV #0x2BF0, W0
001ED8  408000     ADD W1, W0, W0
001EDA  780010     MOV [W0], W0
001EDC  E00000     CP0 W0
001EDE  3A0005     BRA NZ, 0x1EEA
400:                                           Val = Val + CapacitorAvarageRawValue;
001EE0  804300     MOV CapacitorAvarageRawValue, W0
001EE2  90009E     MOV [W14+2], W1
001EE4  408000     ADD W1, W0, W0
001EE6  980710     MOV W0, [W14+2]
001EE8  370008     BRA 0x1EFA
401:                                       } else Val = Val + Spi1RxBuff[i];
001EEA  78001E     MOV [W14], W0
001EEC  400080     ADD W0, W0, W1
001EEE  22BF00     MOV #0x2BF0, W0
001EF0  408000     ADD W1, W0, W0
001EF2  780010     MOV [W0], W0
001EF4  90009E     MOV [W14+2], W1
001EF6  408000     ADD W1, W0, W0
001EF8  980710     MOV W0, [W14+2]
402:                                   }
403:                                   Val = Val / 8;
001F02  90001E     MOV [W14+2], W0
001F04  DE0043     LSR W0, #3, W0
001F06  980710     MOV W0, [W14+2]
404:                                   CapacitorAvarageRawValue = Val;
001F08  90009E     MOV [W14+2], W1
001F0A  884301     MOV W1, CapacitorAvarageRawValue
405:                                   CapVoltage = Val * 48; //48mV = 5V / 1024bit
001F0C  90009E     MOV [W14+2], W1
001F0E  200300     MOV #0x30, W0
001F10  B98800     MUL.SS W1, W0, W0
001F12  780000     MOV W0, W0
001F14  EB0080     CLR W1
001F16  884430     MOV W0, CapVoltage
001F18  884441     MOV W1, 0x888
406:                                   //CapVoltage = CapVoltage * 1515/150000;// Vcap = (val * 151.5k)/1.5k
407:                                   CapVoltage = CapVoltage * 1515 / 150000; //for debug without capacitor bank
001F1A  804430     MOV CapVoltage, W0
001F1C  804441     MOV 0x888, W1
001F1E  205EB2     MOV #0x5EB, W2
001F20  B98902     MUL.SS W1, W2, W2
001F22  780102     MOV W2, W2
001F24  B90260     MUL.SU W0, #0, W4
001F26  780184     MOV W4, W3
001F28  410103     ADD W2, W3, W2
001F2A  205EB3     MOV #0x5EB, W3
001F2C  B80003     MUL.UU W0, W3, W0
001F2E  410101     ADD W2, W1, W2
001F30  780082     MOV W2, W1
001F32  249F02     MOV #0x49F0, W2
001F34  200023     MOV #0x2, W3
001F36  07FA36     RCALL 0x13A4
001F38  884430     MOV W0, CapVoltage
001F3A  884441     MOV W1, 0x888
408:                               }
409:                               for (i = 0; i < 8; i++)Spi1TxBuff[i] = MCP3002_CH0;
001F3C  EB0000     CLR W0
001F3E  780F00     MOV W0, [W14]
001F40  370007     BRA 0x1F50
001F42  78001E     MOV [W14], W0
001F44  400080     ADD W0, W0, W1
001F46  22BE00     MOV #0x2BE0, W0
001F48  408000     ADD W1, W0, W0
001F4A  2C0001     MOV #0xC000, W1
001F4C  780801     MOV W1, [W0]
001F4E  E80F1E     INC [W14], [W14]
001F50  78001E     MOV [W14], W0
001F52  500FE7     SUB W0, #0x7, [W15]
001F54  36FFF6     BRA LEU, 0x1F42
410:                               cntSPIMeasure = 0;
001F56  EF2892     CLR cntSPIMeasure
411:                               break;
001F58  37000A     BRA 0x1F6E
412:               
413:                           default:
414:                               if (cntSPIMeasure > MeasurePeriod)SPIMeasure = 0xFFFF;
001F5A  804491     MOV cntSPIMeasure, W1
001F5C  8046F0     MOV 0x8DE, W0
001F5E  508F80     SUB W1, W0, [W15]
001F60  360003     BRA LEU, 0x1F68
001F62  EB8000     SETM W0
001F64  8842A0     MOV W0, SPIMeasure
415:                               else SPIMeasure = 7;
001F68  200070     MOV #0x7, W0
001F6A  8842A0     MOV W0, SPIMeasure
416:                               break;
001F66  370003     BRA 0x1F6E
001F6C  000000     NOP
417:                       }
418:                       SPIMeasure++;
001F6E  8042A0     MOV SPIMeasure, W0
001F70  E80000     INC W0, W0
001F72  8842A0     MOV W0, SPIMeasure
419:                       //if (SPIMeasure > 6)SPIMeasure = 0;
420:                   }
421:               
422:                   if (Devices2.DiodeCurrentMeasurementDone) {
001F74  8045C1     MOV 0x8B8, W1
001F76  200800     MOV #0x80, W0
001F78  608000     AND W1, W0, W0
001F7A  E00000     CP0 W0
001F7C  320066     BRA Z, 0x204A
423:                       Devices2.DiodeCurrentMeasurementDone = 0; //reset until next measurements
001F7E  A9E8B8     BCLR 0x8B8, #7
424:                       IndxDiodeCurrent = 0;
001F80  EF289A     CLR IndxDiodeCurrent
425:                       ActualDiodeCurrent1 = 0;
001F82  EF2856     CLR ActualDiodeCurrent1
426:                       for (i = 0; i < 5; i++) {
001F84  EB0000     CLR W0
001F86  780F00     MOV W0, [W14]
001F88  370009     BRA 0x1F9C
001F9A  E80F1E     INC [W14], [W14]
001F9C  78001E     MOV [W14], W0
001F9E  500FE4     SUB W0, #0x4, [W15]
001FA0  36FFF4     BRA LEU, 0x1F8A
427:                           ActualDiodeCurrent1 = ActualDiodeCurrent1 + DiodeCurrent1[i];
001F8A  78001E     MOV [W14], W0
001F8C  400080     ADD W0, W0, W1
001F8E  20B880     MOV #0xB88, W0
001F90  408000     ADD W1, W0, W0
001F92  780090     MOV [W0], W1
001F94  8042B0     MOV ActualDiodeCurrent1, W0
001F96  408000     ADD W1, W0, W0
001F98  8842B0     MOV W0, ActualDiodeCurrent1
428:                       }
429:                       ActualDiodeCurrent1 = ActualDiodeCurrent1 / 5;
001FA2  8042B1     MOV ActualDiodeCurrent1, W1
001FA4  200050     MOV #0x5, W0
001FA6  780100     MOV W0, W2
001FA8  090011     REPEAT #0x11
001FAA  D88082     DIV.UW W1, W2
001FAC  8842B0     MOV W0, ActualDiodeCurrent1
430:                       ActualDiodeCurrent1 = 512 - ActualDiodeCurrent1;
001FAE  8042B0     MOV ActualDiodeCurrent1, W0
001FB0  202001     MOV #0x200, W1
001FB2  508000     SUB W1, W0, W0
001FB4  8842B0     MOV W0, ActualDiodeCurrent1
431:                       ActualDiodeCurrent1 = ActualDiodeCurrent1 * 322 / 660;
001FB6  8042B1     MOV ActualDiodeCurrent1, W1
001FB8  201420     MOV #0x142, W0
001FBA  B98800     MUL.SS W1, W0, W0
001FBC  780080     MOV W0, W1
001FBE  202940     MOV #0x294, W0
001FC0  780100     MOV W0, W2
001FC2  090011     REPEAT #0x11
001FC4  D88082     DIV.UW W1, W2
001FC6  8842B0     MOV W0, ActualDiodeCurrent1
432:               
433:                       ActualDiodeCurrent2 = 0;
001FC8  EF2858     CLR ActualDiodeCurrent2
434:                       for (i = 0; i < 5; i++) {
001FCA  EB0000     CLR W0
001FCC  780F00     MOV W0, [W14]
001FCE  370009     BRA 0x1FE2
001FE0  E80F1E     INC [W14], [W14]
001FE2  78001E     MOV [W14], W0
001FE4  500FE4     SUB W0, #0x4, [W15]
001FE6  36FFF4     BRA LEU, 0x1FD0
435:                           ActualDiodeCurrent2 = ActualDiodeCurrent2 + DiodeCurrent2[i];
001FD0  78001E     MOV [W14], W0
001FD2  400080     ADD W0, W0, W1
001FD4  20B920     MOV #0xB92, W0
001FD6  408000     ADD W1, W0, W0
001FD8  780090     MOV [W0], W1
001FDA  8042C0     MOV ActualDiodeCurrent2, W0
001FDC  408000     ADD W1, W0, W0
001FDE  8842C0     MOV W0, ActualDiodeCurrent2
436:                       }
437:                       ActualDiodeCurrent2 = ActualDiodeCurrent2 / 5;
001FE8  8042C1     MOV ActualDiodeCurrent2, W1
001FEA  200050     MOV #0x5, W0
001FEC  780100     MOV W0, W2
001FEE  090011     REPEAT #0x11
001FF0  D88082     DIV.UW W1, W2
001FF2  8842C0     MOV W0, ActualDiodeCurrent2
438:                       ActualDiodeCurrent2 = ActualDiodeCurrent2 - 512;
001FF4  8042C0     MOV ActualDiodeCurrent2, W0
001FF6  B12000     SUB #0x200, W0
001FF8  8842C0     MOV W0, ActualDiodeCurrent2
439:                       ActualDiodeCurrent2 = ActualDiodeCurrent2 * 322 / 660;
001FFA  8042C1     MOV ActualDiodeCurrent2, W1
001FFC  201420     MOV #0x142, W0
001FFE  B98800     MUL.SS W1, W0, W0
002000  780080     MOV W0, W1
002002  202940     MOV #0x294, W0
002004  780100     MOV W0, W2
002006  090011     REPEAT #0x11
002008  D88082     DIV.UW W1, W2
00200A  8842C0     MOV W0, ActualDiodeCurrent2
440:               
441:                       ActualLddriverCurrent = ActualDiodeCurrent1 + ActualDiodeCurrent2;
00200C  8042B1     MOV ActualDiodeCurrent1, W1
00200E  8042C0     MOV ActualDiodeCurrent2, W0
002010  408000     ADD W1, W0, W0
002012  8842D0     MOV W0, ActualLddriverCurrent
442:                       if ((ActualLddriverCurrent > MaxAllowedCurrent) || (ActualLddriverCurrent < MinAllowedCurrent)) {
002014  8042D1     MOV ActualLddriverCurrent, W1
002016  8042E0     MOV MaxAllowedCurrent, W0
002018  508F80     SUB W1, W0, [W15]
00201A  3E0004     BRA GTU, 0x2024
00201C  8042D1     MOV ActualLddriverCurrent, W1
00201E  8042F0     MOV MinAllowedCurrent, W0
002020  508F80     SUB W1, W0, [W15]
002022  31000E     BRA C, 0x2040
443:                           if ((ActualLddriverCurrent < 160)&&(Trigger == TRUE)&&(Devices.PulseInProgress == 1)) Devices2.WrongCurrentDetected = TRUE;
002024  8042D1     MOV ActualLddriverCurrent, W1
002026  2009F0     MOV #0x9F, W0
002028  508F80     SUB W1, W0, [W15]
00202A  3E000F     BRA GTU, 0x204A
00202C  804530     MOV Trigger, W0
00202E  500FE1     SUB W0, #0x1, [W15]
002030  3A0009     BRA NZ, 0x2044
002032  8043B1     MOV Devices, W1
002034  200800     MOV #0x80, W0
002036  608000     AND W1, W0, W0
002038  E00000     CP0 W0
00203A  320006     BRA Z, 0x2048
00203C  A808B9     BSET 0x8B9, #0
00203E  370005     BRA 0x204A
002044  000000     NOP
002046  370001     BRA 0x204A
002048  000000     NOP
444:                       } else Devices2.WrongCurrentDetected = FALSE;
002040  A908B9     BCLR 0x8B9, #0
002042  370003     BRA 0x204A
445:               
446:                   }
447:               }
00204A  FA8000     ULNK
00204C  060000     RETURN
448:               
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/consol.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"          /* User funct/params, such as InitApp              */
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define WAIT_INTERLOCK          0
20:                #define WAIT_INTERLOCK_BOUNCING 1
21:                #define INTERLOCK_FAULT         2
22:                
23:                #define DISCHARGE_WAIT_ENABLE   0
24:                #define DISCHARGE_WAIT_DISABLE  1
25:                /*================================================*/
26:                
27:                /*================= Variables ===============================*/
28:                u16 current_interlock_task = 0;
29:                u16 InterlockTimeOut = 0;
30:                u16 current_discharge_task = 0;
31:                u16 LddriverCurrent = 0;
32:                u16 current_lddriver_task = 0;
33:                
34:                extern u16 SystemStateToUpdate;
35:                /*================================================*/
36:                
37:                /*================= Functions ===============================*/
38:                void interlock_tasks(void);
39:                void discharge_tasks(void);
40:                void LDDriver_tasks(void);
41:                void SetDriverCurrent(u16 val);
42:                
43:                /*================================================*/
44:                
45:                void LDDriver_tasks(void) {
00361C  FA0000     LNK #0x0
46:                    if (Devices.DriverCurrentUpdate) {
00361E  8043B1     MOV Devices, W1
003620  220000     MOV #0x2000, W0
003622  608000     AND W1, W0, W0
003624  E00000     CP0 W0
003626  320003     BRA Z, 0x362E
47:                        SetDriverCurrent(LddriverCurrent);
003628  804590     MOV LddriverCurrent, W0
00362A  07000D     RCALL SetDriverCurrent
48:                        Devices.DriverCurrentUpdate = FALSE;
00362C  A9A877     BCLR 0x877, #5
49:                    }
50:                
51:                    if (Devices.LddriverIsEnable) {
00362E  8043B1     MOV Devices, W1
003630  240000     MOV #0x4000, W0
003632  608000     AND W1, W0, W0
003634  E00000     CP0 W0
003636  320003     BRA Z, 0x363E
52:                        LD_INHIBIT1=LOW;
003638  A982DC     BCLR LATD, #4
53:                        SAFE_IGBT_EN = HIGH;
00363A  A8E2F5     BSET 0x2F5, #7
00363C  370002     BRA 0x3642
54:                    } else {
55:                        LD_INHIBIT1 = HIGH;
00363E  A882DC     BSET LATD, #4
56:                        SAFE_IGBT_EN = LOW;
003640  A9E2F5     BCLR 0x2F5, #7
57:                    }
58:                
59:                    switch (current_lddriver_task) {
60:                
61:                    }
62:                }
003642  FA8000     ULNK
003644  060000     RETURN
63:                
64:                void SetDriverCurrent(u16 val) {
003646  FA0002     LNK #0x2
003648  780F00     MOV W0, [W14]
65:                    val = val * 334 / 49;
00364A  78009E     MOV [W14], W1
00364C  2014E0     MOV #0x14E, W0
00364E  B98800     MUL.SS W1, W0, W0
003650  780080     MOV W0, W1
003652  200310     MOV #0x31, W0
003654  780100     MOV W0, W2
003656  090011     REPEAT #0x11
003658  D88082     DIV.UW W1, W2
00365A  780F00     MOV W0, [W14]
66:                    val <<= 2;
00365C  78001E     MOV [W14], W0
00365E  DD0042     SL W0, #2, W0
003660  780F00     MOV W0, [W14]
67:                    val = 0x1000 + val;
003662  210000     MOV #0x1000, W0
003664  400F1E     ADD W0, [W14], [W14]
68:                    while (!CommFlags.SPI1RxDone);
003666  000000     NOP
003668  8045B0     MOV 0x8B6, W0
00366A  600064     AND W0, #0x4, W0
00366C  E00000     CP0 W0
00366E  32FFFC     BRA Z, 0x3668
69:                    LD_SPI_ENABLE = HIGH;
003670  A842F4     BSET LATG, #2
70:                    CS_LD_DAC = LOW;
003672  A9A2DD     BCLR 0x2DD, #5
71:                    SPIReadWriteWord(val);
003674  78001E     MOV [W14], W0
003676  07F741     RCALL SPIReadWriteWord
72:                    CS_LD_DAC = HIGH;
003678  A8A2DD     BSET 0x2DD, #5
73:                    LD_SPI_ENABLE = LOW;
00367A  A942F4     BCLR LATG, #2
74:                }
00367C  FA8000     ULNK
00367E  060000     RETURN
75:                
76:                void discharge_tasks(void) {
003680  FA0000     LNK #0x0
77:                    switch (current_discharge_task) {
003682  804580     MOV current_discharge_task, W0
003684  E00000     CP0 W0
003686  320003     BRA Z, 0x368E
003688  500FE1     SUB W0, #0x1, [W15]
00368A  32000B     BRA Z, 0x36A2
00368C  370015     BRA 0x36B8
78:                        case DISCHARGE_WAIT_ENABLE:
79:                            if (Devices.DischargeIsEnabled) {
00368E  8043B1     MOV Devices, W1
003690  280000     MOV #0x8000, W0
003692  608000     AND W1, W0, W0
003694  E00000     CP0 W0
003696  32000D     BRA Z, 0x36B2
80:                                CHARGER_ENABLE = HIGH; //inhibit charger before discharge
003698  A822F5     BSET 0x2F5, #1
81:                                DISCHARGE = LOW;
00369A  A9E2C4     BCLR LATA, #7
82:                                current_discharge_task = DISCHARGE_WAIT_DISABLE;
00369C  200010     MOV #0x1, W0
00369E  884580     MOV W0, current_discharge_task
83:                            }
84:                            break;
0036A0  37000B     BRA 0x36B8
0036B2  000000     NOP
0036B4  370001     BRA 0x36B8
85:                
86:                        case DISCHARGE_WAIT_DISABLE:
87:                            if (!Devices.DischargeIsEnabled) {
0036A2  8043B1     MOV Devices, W1
0036A4  280000     MOV #0x8000, W0
0036A6  608000     AND W1, W0, W0
0036A8  E00000     CP0 W0
0036AA  3A0005     BRA NZ, 0x36B6
88:                                DISCHARGE = HIGH;
0036AC  A8E2C4     BSET LATA, #7
89:                                current_discharge_task = DISCHARGE_WAIT_ENABLE;
0036AE  EF28B0     CLR current_discharge_task
90:                            }
91:                            break;
0036B0  370003     BRA 0x36B8
0036B6  000000     NOP
92:                    }
93:                }
0036B8  FA8000     ULNK
0036BA  060000     RETURN
94:                
95:                void interlock_tasks(void) {
0036BC  FA0000     LNK #0x0
96:                    switch (current_interlock_task) {
0036BE  804560     MOV current_interlock_task, W0
0036C0  500FE1     SUB W0, #0x1, [W15]
0036C2  32000F     BRA Z, 0x36E2
0036C4  500FE1     SUB W0, #0x1, [W15]
0036C6  390003     BRA NC, 0x36CE
0036C8  500FE2     SUB W0, #0x2, [W15]
0036CA  32001E     BRA Z, 0x3708
0036CC  37002C     BRA 0x3726
97:                        case WAIT_INTERLOCK:
98:                            if (INTERLOCK) {
0036CE  801610     MOV PORTA, W0
0036D0  600062     AND W0, #0x2, W0
0036D2  E00000     CP0 W0
0036D4  320004     BRA Z, 0x36DE
99:                                InterlockTimeOut = 0; //reset timer
0036D6  EF28AE     CLR InterlockTimeOut
100:                               current_interlock_task = WAIT_INTERLOCK_BOUNCING;
0036D8  200010     MOV #0x1, W0
0036DA  884560     MOV W0, current_interlock_task
101:                           } else {
102:                               Devices.InterlockIsConnected = TRUE;
0036DE  A84877     BSET 0x877, #2
103:                           }
104:                           break;
0036DC  370024     BRA 0x3726
0036E0  370022     BRA 0x3726
105:               
106:                       case WAIT_INTERLOCK_BOUNCING:
107:                           if (InterlockTimeOut > 250) { //delay 15ms for bouncing
0036E2  804571     MOV InterlockTimeOut, W1
0036E4  200FA0     MOV #0xFA, W0
0036E6  508F80     SUB W1, W0, [W15]
0036E8  36001B     BRA LEU, 0x3720
108:                               if (INTERLOCK) {//if ipl applicator disconnected or not connected shut off ipl module
0036EA  801610     MOV PORTA, W0
0036EC  600062     AND W0, #0x2, W0
0036EE  E00000     CP0 W0
0036F0  320009     BRA Z, 0x3704
109:                                   Devices.SystemStatedUpdate = TRUE;
0036F2  A80877     BSET 0x877, #0
110:                                   SystemStateToUpdate = SYS_STATE_FAULT;
0036F4  2000F0     MOV #0xF, W0
0036F6  8846E0     MOV W0, 0x8DC
111:                                   FaultNumber = FAULT_INTERLOCK;
0036F8  200180     MOV #0x18, W0
0036FA  8843C0     MOV W0, FaultNumber
112:                                   Devices.InterlockIsConnected = FALSE;
0036FC  A94877     BCLR 0x877, #2
113:                                   current_interlock_task = INTERLOCK_FAULT;
0036FE  200020     MOV #0x2, W0
003700  884560     MOV W0, current_interlock_task
114:                               } else {
115:                                   current_interlock_task = WAIT_INTERLOCK;
003704  EF28AC     CLR current_interlock_task
116:                               }
117:                           }
118:                           break;
003702  370011     BRA 0x3726
003706  37000F     BRA 0x3726
003720  000000     NOP
003722  370001     BRA 0x3726
119:               
120:                       case INTERLOCK_FAULT:
121:                           if (!INTERLOCK) {
003708  801610     MOV PORTA, W0
00370A  600062     AND W0, #0x2, W0
00370C  E00000     CP0 W0
00370E  3A000A     BRA NZ, 0x3724
122:                               Devices.SystemStatedUpdate = TRUE;
003710  A80877     BSET 0x877, #0
123:                               SystemStateToUpdate = SYS_STATE_STANDBY;
003712  200100     MOV #0x10, W0
003714  8846E0     MOV W0, 0x8DC
124:                               FaultNumber = CLEAR;
003716  EF2878     CLR FaultNumber
125:                               InterlockTimeOut = 0; //reset timer
003718  EF28AE     CLR InterlockTimeOut
126:                               current_interlock_task = WAIT_INTERLOCK_BOUNCING;
00371A  200010     MOV #0x1, W0
00371C  884560     MOV W0, current_interlock_task
127:                           }
128:                           break;
00371E  370003     BRA 0x3726
003724  000000     NOP
129:                   }
130:               }
003726  FA8000     ULNK
003728  060000     RETURN
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/comm.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define CMD_ACK                     0x41
20:                #define CMD_NACK                    0x14
21:                #define CMD_STATUS_REQUEST          0x01
22:                #define CMD_STATUS_RESPONCE         0x33
23:                #define CMD_SET_SYSTEM_STATE        0x04
24:                #define CMD_FAN_CONTROL             0x45
25:                #define CMD_PUMP_CONTROL            0x44
26:                #define CMD_SIMMER_CONTROL          0x46
27:                #define CMD_TEC_CONTROL             0x47
28:                #define CMD_CAP_DISCHARGE           0x48
29:                #define CMD_WORK_PARAMETERS         0x49
30:                #define CMD_SW_VERSION_REQUEST      0x05
31:                #define CMD_SW_VERSION              0x50
32:                #define CMD_BOOT_MODE               0x55
33:                #define CMD_CHARGER_CONTROL         0x20
34:                #define CMD_SYS_MODE                0x09
35:                #define CMD_PULSE_PARAMETERS        0x51 //from ipl not used in hpdl
36:                #define CMD_REQUEST_MEASURMENTS     0x70
37:                #define CMD_SEND_MEASURMENTS        0x75
38:                #define CMD_APP_STATUS_REQUEST      0xA1
39:                #define CMD_APP_STATUS_RESPONCE     0x1A
40:                #define CMD_LASER_PULSE_PARAMETERS  0x61
41:                #define CMD_TECHMODE_STATUS_REQUEST 0x1B
42:                #define CMD_TECHMODE_STATUS_ANSWER  0xB1
43:                #define CMD_LDDRIVER_CONTROL        0x31
44:                #define CMD_HPDL_PULSE_PARAMETER    0x32
45:                #define CMD_INFO_DATA               0xFF
46:                #define CMD_LIGHTGUIDE_PARAMETER_REQUEST    0x25
47:                #define CMD_LIGHTGUIDE_PARAMETER_RESPONCE   0x52
48:                /*========================================================*/
49:                
50:                /*================= Variables ===============================*/
51:                u8 RXbuffer[256]; //rx bufer
52:                u8 indxRXbuffer = 0; //index of rx buffer
53:                u8 TXbuffer[256]; //tx bufer
54:                u8 indxTXbuff; //index of tx buffer
55:                u16 FrameLen = 0; // farme data len to transmite
56:                u16 tx100uS;
57:                
58:                extern u16 PumpVoltage;
59:                extern u16 LddriverCurrent;
60:                extern u16 TECVoltage;
61:                extern u32 PulseCounter;
62:                extern u16 SystemMode;
63:                extern u16 Trigger;
64:                extern u16 SystemStateToUpdate;
65:                extern u16 CoolingLevel;
66:                extern u16 MaxAllowedCurrent;
67:                extern u16 MinAllowedCurrent;
68:                extern float ActualTecTemperature;
69:                extern float tVal;
70:                /*==========================================================*/
71:                
72:                /*================= Functions ===============================*/
73:                u8 TxHeadCheckSum(void);
74:                u8 TxFrameCheckSum(u8 tFrameLen);
75:                u8 RxHeadCheckSum(void);
76:                u8 RxFrameCheckSum(u8 tFrameLen);
77:                void SendFrame(u8 tFrameLen, u8 tCommand);
78:                void ExecuteReceivedCommand(u16 valCMD);
79:                
80:                /*========================================================*/
81:                
82:                /**********************************************************************
83:                 * Function:        void comm_tasks(void)
84:                 * PreCondition:    None
85:                 * Input:           None
86:                 * Output:          None
87:                 * Overview:	    communication managment.
88:                 *
89:                 ***********************************************************************/
90:                void comm_tasks(void) {
00251A  FA0000     LNK #0x0
91:                    if (U1STAbits.OERR) {//if error clear flag
00251C  801110     MOV U1STA, W0
00251E  600062     AND W0, #0x2, W0
002520  E00000     CP0 W0
002522  320002     BRA Z, 0x2528
92:                        U1STAbits.OERR = CLEAR;
002524  A92222     BCLR U1STA, #1
93:                        indxRXbuffer = 0;
002526  EF68C6     CLR.B indxRXbuffer
94:                    }
95:                   
96:                    if (CommFlags.FrameReceivedFlag) {//check if frame received
002528  8045B0     MOV 0x8B6, W0
00252A  600061     AND W0, #0x1, W0
00252C  E00000     CP0 W0
00252E  320016     BRA Z, 0x255C
97:                        indxRXbuffer = 0; //frame received, preapare rx buffer to receive
002530  EF68C6     CLR.B indxRXbuffer
98:                        CommFlags.FrameReceivedFlag = 0; //reset frame receive flag
002532  A908B6     BCLR 0x8B6, #0
99:                        if (RxFrameCheckSum(RXbuffer[6] + 6) == RXbuffer[RXbuffer[6] + 7]) {//check tfarme check sum
002534  208E60     MOV #0x8E6, W0
002536  784010     MOV.B [W0], W0
002538  404066     ADD.B W0, #0x6, W0
00253A  070061     RCALL RxFrameCheckSum
00253C  208E61     MOV #0x8E6, W1
00253E  784091     MOV.B [W1], W1
002540  FB8081     ZE W1, W1
002542  4080E7     ADD W1, #0x7, W1
002544  208E02     MOV #0x8E0, W2
002546  78C0E2     MOV.B [W2+W1], W1
002548  504F81     SUB.B W0, W1, [W15]
00254A  3A0005     BRA NZ, 0x2556
100:                           ExecuteReceivedCommand(RXbuffer[7]); //check sum correct, execute received command
00254C  208E70     MOV #0x8E7, W0
00254E  784010     MOV.B [W0], W0
002550  FB8000     ZE W0, W0
002552  07006E     RCALL ExecuteReceivedCommand
002554  370021     BRA 0x2598
101:                       } else {
102:                           ExecuteReceivedCommand(CMD_NACK); //the check sum incorrect send NAck to master
002556  200140     MOV #0x14, W0
002558  07006B     RCALL ExecuteReceivedCommand
00255A  37001E     BRA 0x2598
103:                       }
104:                   } else if (CommFlags.ReadyToSendFlag) {//check if transmition frame ready to be transmitted
00255C  8045B0     MOV 0x8B6, W0
00255E  600062     AND W0, #0x2, W0
002560  E00000     CP0 W0
002562  32001A     BRA Z, 0x2598
105:                       if (tx100uS > 6) {//wait 6mS at least before send a respponce
002564  804650     MOV tx100uS, W0
002566  500FE6     SUB W0, #0x6, [W15]
002568  360017     BRA LEU, 0x2598
106:                           CommFlags.ReadyToSendFlag = 0; //reset transmite flag
00256A  A928B6     BCLR 0x8B6, #1
107:                           indxTXbuff = 0; //reset index of txbuffer
00256C  EF68C7     CLR.B indxTXbuff
108:                           while (indxRXbuffer); //here to prevent collision i have to check if i receive
00256E  000000     NOP
002570  BFC8C6     MOV.B indxRXbuffer, WREG
002572  E00400     CP0.B W0
002574  3AFFFD     BRA NZ, 0x2570
109:                           while (DIR); //or transmite something
002576  000000     NOP
002578  801621     MOV LATA, W1
00257A  200200     MOV #0x20, W0
00257C  608000     AND W1, W0, W0
00257E  E00000     CP0 W0
002580  3AFFFB     BRA NZ, 0x2578
110:                           DIR = TX_MODE; // put rs485 transceiver to tx mode
002582  A8A2C4     BSET LATA, #5
111:                           while (!U1STAbits.TRMT); //check if all TX buffer was sent
002584  000000     NOP
002586  801111     MOV U1STA, W1
002588  201000     MOV #0x100, W0
00258A  608000     AND W1, W0, W0
00258C  E00000     CP0 W0
00258E  32FFFB     BRA Z, 0x2586
112:                           U1TXREG = TXbuffer[0]; // move firs byte to uart
002590  209E00     MOV #0x9E0, W0
002592  784010     MOV.B [W0], W0
002594  FB8000     ZE W0, W0
002596  881120     MOV W0, U1TXREG
113:                       }
114:                   }
115:               #ifdef __BLACKBOX
116:                   if ((Devices2.InfoDataReadyToSend)&&(!indxRXbuffer)) {
117:                       Devices2.InfoDataReadyToSend = 0;
118:                       TXbuffer[8] = HIBYTE(HIWORD(ActualTecTemperature));
119:                       TXbuffer[9] = LOBYTE(HIWORD(ActualTecTemperature));
120:                       TXbuffer[10] = HIBYTE(LOWORD(ActualTecTemperature));
121:                       TXbuffer[11] = LOBYTE(LOWORD(ActualTecTemperature));
122:                       TXbuffer[12] = HIBYTE(HIWORD(tVal));
123:                       TXbuffer[13] = LOBYTE(HIWORD(tVal));
124:                       TXbuffer[14] = HIBYTE(LOWORD(tVal));
125:                       TXbuffer[15] = LOBYTE(LOWORD(tVal));
126:                       SendFrame(9, CMD_INFO_DATA); //send ack
127:                   }
128:               #endif
129:               }
002598  FA8000     ULNK
00259A  060000     RETURN
130:               
131:               /**********************************************************************
132:                * Function:        void SendFrame(u8 tFrameLen, u8 tCommand)
133:                * PreCondition:    None
134:                * Input:	    tFrameLen - frame lentdh
135:                *                  tCommand - frame command
136:                * Output:	    None
137:                * Overview:	    This function used to initiate frame sending
138:                *
139:                ***********************************************************************/
140:               void SendFrame(u8 tFrameLen, u8 tCommand) {
00259C  FA0002     LNK #0x2
00259E  781F88     MOV W8, [W15++]
0025A0  784F00     MOV.B W0, [W14]
0025A2  984711     MOV.B W1, [W14+1]
141:                   tx100uS = 0; //clear timer
0025A4  EF28CA     CLR tx100uS
142:                   FrameLen = tFrameLen + 8; //calculate frame len
0025A6  FB801E     ZE [W14], W0
0025A8  400068     ADD W0, #0x8, W0
0025AA  884640     MOV W0, FrameLen
143:                   //indxTXbuff = 0; //reset index of txbuffer
144:                   TXbuffer[6] = tFrameLen; //frame lenght
0025AC  209E60     MOV #0x9E6, W0
0025AE  78481E     MOV.B [W14], [W0]
145:                   TXbuffer[7] = tCommand; //CMD 
0025B0  209E70     MOV #0x9E7, W0
0025B2  90409E     MOV.B [W14+1], W1
0025B4  784801     MOV.B W1, [W0]
146:                   TXbuffer[tFrameLen + 7] = TxFrameCheckSum(tFrameLen + 6); //calculate frame check sum
0025B6  FB801E     ZE [W14], W0
0025B8  400467     ADD W0, #0x7, W8
0025BA  78409E     MOV.B [W14], W1
0025BC  40C066     ADD.B W1, #0x6, W0
0025BE  070006     RCALL TxFrameCheckSum
0025C0  209E01     MOV #0x9E0, W1
0025C2  7C7080     MOV.B W0, [W1+W8]
147:                   CommFlags.ReadyToSendFlag = 1; //set transit flag
0025C4  A828B6     BSET 0x8B6, #1
148:               }
0025C6  78044F     MOV [--W15], W8
0025C8  FA8000     ULNK
0025CA  060000     RETURN
149:               
150:               /**********************************************************************
151:                * Function:        u8 TxFrameCheckSum(u8 tFrameLen)
152:                * PreCondition:    None
153:                * Input:	    tFrameLen - frame lentdh
154:                * Output:	    CheckSum - check sum
155:                * Overview:	    This function used to calculate check sum of frame to send.
156:                *
157:                ***********************************************************************/
158:               u8 TxFrameCheckSum(u8 tFrameLen) {
0025CC  FA0006     LNK #0x6
0025CE  984740     MOV.B W0, [W14+4]
159:                   u8 CheckSum = 0;
0025D0  EB4000     CLR.B W0
0025D2  784F00     MOV.B W0, [W14]
160:                   u16 i;
161:                   for (i = 6; i < (tFrameLen + 1); ++i) {
0025D4  200060     MOV #0x6, W0
0025D6  980710     MOV W0, [W14+2]
0025D8  370008     BRA 0x25EA
0025E4  90001E     MOV [W14+2], W0
0025E6  E80000     INC W0, W0
0025E8  980710     MOV W0, [W14+2]
0025EA  90404E     MOV.B [W14+4], W0
0025EC  FB8000     ZE W0, W0
0025EE  E80000     INC W0, W0
0025F0  780080     MOV W0, W1
0025F2  90001E     MOV [W14+2], W0
0025F4  508F80     SUB W1, W0, [W15]
0025F6  3EFFF1     BRA GTU, 0x25DA
162:                       CheckSum = CheckSum + TXbuffer[i];
0025DA  209E01     MOV #0x9E0, W1
0025DC  90001E     MOV [W14+2], W0
0025DE  408000     ADD W1, W0, W0
0025E0  784010     MOV.B [W0], W0
0025E2  404F1E     ADD.B W0, [W14], [W14]
163:                   }
164:                   return CheckSum;
0025F8  78401E     MOV.B [W14], W0
165:               }
0025FA  FA8000     ULNK
0025FC  060000     RETURN
166:               
167:               /**********************************************************************
168:                * Function:        u8 RxFrameCheckSum(u8 tFrameLen)
169:                * PreCondition:    None
170:                * Input:	    tFrameLen - frame lentdh
171:                * Output:	    CheckSum - check sum
172:                * Overview:	    This function used to calculate check sum of received frame.
173:                *
174:                ***********************************************************************/
175:               u8 RxFrameCheckSum(u8 tFrameLen) {
0025FE  FA0006     LNK #0x6
002600  984740     MOV.B W0, [W14+4]
176:                   u8 CheckSum = 0;
002602  EB4000     CLR.B W0
002604  784F00     MOV.B W0, [W14]
177:                   u16 i;
178:                   for (i = 6; i < (tFrameLen + 1); ++i) {
002606  200060     MOV #0x6, W0
002608  980710     MOV W0, [W14+2]
00260A  370008     BRA 0x261C
002616  90001E     MOV [W14+2], W0
002618  E80000     INC W0, W0
00261A  980710     MOV W0, [W14+2]
00261C  90404E     MOV.B [W14+4], W0
00261E  FB8000     ZE W0, W0
002620  E80000     INC W0, W0
002622  780080     MOV W0, W1
002624  90001E     MOV [W14+2], W0
002626  508F80     SUB W1, W0, [W15]
002628  3EFFF1     BRA GTU, 0x260C
179:                       CheckSum = CheckSum + RXbuffer[i];
00260C  208E01     MOV #0x8E0, W1
00260E  90001E     MOV [W14+2], W0
002610  408000     ADD W1, W0, W0
002612  784010     MOV.B [W0], W0
002614  404F1E     ADD.B W0, [W14], [W14]
180:                   }
181:                   return CheckSum;
00262A  78401E     MOV.B [W14], W0
182:               }
00262C  FA8000     ULNK
00262E  060000     RETURN
183:               
184:               /**********************************************************************
185:                * Function:        void ExecuteReceivedCommand(u16 valCMD)
186:                * PreCondition:    None
187:                * Input:	    valCMD - command code
188:                * Output:	    None
189:                * Overview:	    This function used to execute received command.
190:                *
191:                ***********************************************************************/
192:               void ExecuteReceivedCommand(u16 valCMD) {
002630  FA0002     LNK #0x2
002632  BE9F88     MOV.D W8, [W15++]
002634  780F00     MOV W0, [W14]
193:                   switch (valCMD) {
002636  78001E     MOV [W14], W0
002638  B80161     MUL.UU W0, #1, W2
00263A  EB8000     SETM W0
00263C  EB8080     SETM W1
00263E  400002     ADD W0, W2, W0
002640  488083     ADDC W1, W3, W1
002642  200542     MOV #0x54, W2
002644  200003     MOV #0x0, W3
002646  500F82     SUB W0, W2, [W15]
002648  588F83     SUBB W1, W3, [W15]
00264A  3E01A9     BRA GTU, 0x299E
00264C  016000     BRA W0
00264E  370054     BRA 0x26F8
002650  3701A6     BRA 0x299E
002652  3701A5     BRA 0x299E
002654  3700C8     BRA 0x27E6
002656  3700BA     BRA 0x27CC
002658  3701A2     BRA 0x299E
00265A  3701A1     BRA 0x299E
00265C  3701A0     BRA 0x299E
00265E  37019F     BRA 0x299E
002660  37019E     BRA 0x299E
002662  37019D     BRA 0x299E
002664  37019C     BRA 0x299E
002666  37019B     BRA 0x299E
002668  37019A     BRA 0x299E
00266A  370199     BRA 0x299E
00266C  370198     BRA 0x299E
00266E  370197     BRA 0x299E
002670  370196     BRA 0x299E
002672  370195     BRA 0x299E
002674  370194     BRA 0x299E
002676  370193     BRA 0x299E
002678  370192     BRA 0x299E
00267A  370191     BRA 0x299E
00267C  370190     BRA 0x299E
00267E  37018F     BRA 0x299E
002680  37018E     BRA 0x299E
002682  37018D     BRA 0x299E
002684  37018C     BRA 0x299E
002686  37018B     BRA 0x299E
002688  37018A     BRA 0x299E
00268A  370189     BRA 0x299E
00268C  3700E6     BRA 0x285A
00268E  370187     BRA 0x299E
002690  370186     BRA 0x299E
002692  370185     BRA 0x299E
002694  370184     BRA 0x299E
002696  37015B     BRA 0x294E
002698  370182     BRA 0x299E
00269A  370181     BRA 0x299E
00269C  370180     BRA 0x299E
00269E  37017F     BRA 0x299E
0026A0  37017E     BRA 0x299E
0026A2  37017D     BRA 0x299E
0026A4  37017C     BRA 0x299E
0026A6  37017B     BRA 0x299E
0026A8  37017A     BRA 0x299E
0026AA  370179     BRA 0x299E
0026AC  370178     BRA 0x299E
0026AE  370177     BRA 0x299E
0026B0  3700DF     BRA 0x2870
0026B2  370175     BRA 0x299E
0026B4  370174     BRA 0x299E
0026B6  370173     BRA 0x299E
0026B8  370172     BRA 0x299E
0026BA  370171     BRA 0x299E
0026BC  370170     BRA 0x299E
0026BE  37016F     BRA 0x299E
0026C0  37016E     BRA 0x299E
0026C2  37016D     BRA 0x299E
0026C4  37016C     BRA 0x299E
0026C6  37016B     BRA 0x299E
0026C8  37016A     BRA 0x299E
0026CA  370169     BRA 0x299E
0026CC  370168     BRA 0x299E
0026CE  370167     BRA 0x299E
0026D0  370166     BRA 0x299E
0026D2  370165     BRA 0x299E
0026D4  370041     BRA 0x2758
0026D6  370163     BRA 0x299E
0026D8  370162     BRA 0x299E
0026DA  370095     BRA 0x2806
0026DC  3700B3     BRA 0x2844
0026DE  37015F     BRA 0x299E
0026E0  37015E     BRA 0x299E
0026E2  37015D     BRA 0x299E
0026E4  37015C     BRA 0x299E
0026E6  37015B     BRA 0x299E
0026E8  37015A     BRA 0x299E
0026EA  370159     BRA 0x299E
0026EC  370158     BRA 0x299E
0026EE  370157     BRA 0x299E
0026F0  370156     BRA 0x299E
0026F2  370155     BRA 0x299E
0026F4  370154     BRA 0x299E
0026F6  37004A     BRA 0x278C
194:                       case CMD_STATUS_REQUEST:
195:                           TXbuffer[8] = LgTypeId;
0026F8  804410     MOV LgTypeId, W0
0026FA  784080     MOV.B W0, W1
0026FC  209E80     MOV #0x9E8, W0
0026FE  784801     MOV.B W1, [W0]
196:                           TXbuffer[9] = HIBYTE(HIWORD(PulseCounter));
002700  8043D0     MOV PulseCounter, W0
002702  8043E1     MOV 0x87C, W1
002704  DE8840     ASR W1, #0, W0
002706  DE80CF     ASR W0, #15, W1
002708  780000     MOV W0, W0
00270A  DE8048     ASR W0, #8, W0
00270C  784080     MOV.B W0, W1
00270E  209E90     MOV #0x9E9, W0
002710  784801     MOV.B W1, [W0]
197:                           TXbuffer[10] = LOBYTE(HIWORD(PulseCounter));
002712  8043D0     MOV PulseCounter, W0
002714  8043E1     MOV 0x87C, W1
002716  DE8840     ASR W1, #0, W0
002718  DE80CF     ASR W0, #15, W1
00271A  784080     MOV.B W0, W1
00271C  209EA0     MOV #0x9EA, W0
00271E  784801     MOV.B W1, [W0]
198:                           TXbuffer[11] = HIBYTE(LOWORD(PulseCounter));
002720  8043D0     MOV PulseCounter, W0
002722  8043E1     MOV 0x87C, W1
002724  780000     MOV W0, W0
002726  DE8048     ASR W0, #8, W0
002728  784080     MOV.B W0, W1
00272A  209EB0     MOV #0x9EB, W0
00272C  784801     MOV.B W1, [W0]
199:                           TXbuffer[12] = LOBYTE(LOWORD(PulseCounter));
00272E  8043D0     MOV PulseCounter, W0
002730  8043E1     MOV 0x87C, W1
002732  784080     MOV.B W0, W1
002734  209EC0     MOV #0x9EC, W0
002736  784801     MOV.B W1, [W0]
200:                           TXbuffer[13] = Trigger;
002738  804530     MOV Trigger, W0
00273A  784080     MOV.B W0, W1
00273C  209ED0     MOV #0x9ED, W0
00273E  784801     MOV.B W1, [W0]
201:                           TXbuffer[14] = SystemState;
002740  8045D0     MOV 0x8BA, W0
002742  784080     MOV.B W0, W1
002744  209EE0     MOV #0x9EE, W0
002746  784801     MOV.B W1, [W0]
202:                           TXbuffer[15] = FaultNumber;
002748  8043C0     MOV FaultNumber, W0
00274A  784080     MOV.B W0, W1
00274C  209EF0     MOV #0x9EF, W0
00274E  784801     MOV.B W1, [W0]
203:                           SendFrame(9, CMD_STATUS_RESPONCE); //send ack
002750  B3C331     MOV.B #0x33, W1
002752  B3C090     MOV.B #0x9, W0
002754  07FF23     RCALL SendFrame
204:                           break;
002756  370126     BRA 0x29A4
205:               
206:                       case CMD_PUMP_CONTROL:
207:                           PumpVoltage = RXbuffer[9];
002758  208E90     MOV #0x8E9, W0
00275A  784010     MOV.B [W0], W0
00275C  FB8000     ZE W0, W0
00275E  884680     MOV W0, PumpVoltage
208:                           PumpVoltage <<= 8;
002760  804680     MOV PumpVoltage, W0
002762  DD0048     SL W0, #8, W0
002764  884680     MOV W0, PumpVoltage
209:                           PumpVoltage += RXbuffer[10];
002766  208EA0     MOV #0x8EA, W0
002768  784010     MOV.B [W0], W0
00276A  FB8080     ZE W0, W1
00276C  804680     MOV PumpVoltage, W0
00276E  408000     ADD W1, W0, W0
002770  884680     MOV W0, PumpVoltage
210:                           Devices.PumpVoltageUpdate = TRUE;
002772  A88876     BSET Devices, #4
211:                           if (RXbuffer[8]) {
002774  208E80     MOV #0x8E8, W0
002776  784010     MOV.B [W0], W0
002778  E00400     CP0.B W0
00277A  320002     BRA Z, 0x2780
212:                               Devices.PumpIsEnabled = TRUE;
00277C  A84876     BSET Devices, #2
00277E  370002     BRA 0x2784
213:                           } else {
214:                               Devices.PumpIsEnabled = FALSE;
002780  A94876     BCLR Devices, #2
215:                               PumpVoltage = 0;
002782  EF28D0     CLR PumpVoltage
216:                           }
217:                           SendFrame(1, CMD_ACK); //send ack
002784  B3C411     MOV.B #0x41, W1
002786  B3C010     MOV.B #0x1, W0
002788  07FF09     RCALL SendFrame
218:                           break;
00278A  37010C     BRA 0x29A4
219:               
220:                       case CMD_BOOT_MODE:
221:                           SendFrame(1, CMD_ACK); //send ack
00278C  B3C411     MOV.B #0x41, W1
00278E  B3C010     MOV.B #0x1, W0
002790  07FF05     RCALL SendFrame
222:                           while (tx100uS < 4);
002792  000000     NOP
002794  804650     MOV tx100uS, W0
002796  500FE3     SUB W0, #0x3, [W15]
002798  36FFFD     BRA LEU, 0x2794
223:                           CommFlags.ReadyToSendFlag = 0;
00279A  A928B6     BCLR 0x8B6, #1
224:                           while (indxRXbuffer); //here to prevent collision i have to check if i receive
00279C  000000     NOP
00279E  BFC8C6     MOV.B indxRXbuffer, WREG
0027A0  E00400     CP0.B W0
0027A2  3AFFFD     BRA NZ, 0x279E
225:                           while (DIR); //or transmite something
0027A4  000000     NOP
0027A6  801621     MOV LATA, W1
0027A8  200200     MOV #0x20, W0
0027AA  608000     AND W1, W0, W0
0027AC  E00000     CP0 W0
0027AE  3AFFFB     BRA NZ, 0x27A6
226:                           DIR = TX_MODE;
0027B0  A8A2C4     BSET LATA, #5
227:                           U1STAbits.UTXEN = ENABLE;
0027B2  A84223     BSET 0x223, #2
228:                           U1TXREG = TXbuffer[0];
0027B4  209E00     MOV #0x9E0, W0
0027B6  784010     MOV.B [W0], W0
0027B8  FB8000     ZE W0, W0
0027BA  881120     MOV W0, U1TXREG
229:                           while (DIR == HIGH);
0027BC  000000     NOP
0027BE  801621     MOV LATA, W1
0027C0  200200     MOV #0x20, W0
0027C2  608000     AND W1, W0, W0
0027C4  E00000     CP0 W0
0027C6  3AFFFB     BRA NZ, 0x27BE
230:                           Reset();
0027C8  FE0000     RESET
231:                           break;
0027CA  3700EC     BRA 0x29A4
232:               
233:                       case CMD_SW_VERSION_REQUEST:
234:                           TXbuffer[8] = SW_VERSION_MAJOR;
0027CC  209E80     MOV #0x9E8, W0
0027CE  B3C011     MOV.B #0x1, W1
0027D0  784801     MOV.B W1, [W0]
235:                           TXbuffer[9] = SW_VERSION_MINOR;
0027D2  209E90     MOV #0x9E9, W0
0027D4  EB4080     CLR.B W1
0027D6  784801     MOV.B W1, [W0]
236:                           TXbuffer[10] = SW_VERSION_BUILD;
0027D8  209EA0     MOV #0x9EA, W0
0027DA  B3C051     MOV.B #0x5, W1
0027DC  784801     MOV.B W1, [W0]
237:                           SendFrame(4, CMD_SW_VERSION);
0027DE  B3C501     MOV.B #0x50, W1
0027E0  B3C040     MOV.B #0x4, W0
0027E2  07FEDC     RCALL SendFrame
238:                           break;
0027E4  3700DF     BRA 0x29A4
239:               
240:                       case CMD_SET_SYSTEM_STATE:
241:                           if (SystemState != SYS_STATE_FAULT) {
0027E6  8045D0     MOV 0x8BA, W0
0027E8  500FEF     SUB W0, #0xF, [W15]
0027EA  320009     BRA Z, 0x27FE
242:                               SystemStateToUpdate = RXbuffer[8];
0027EC  208E80     MOV #0x8E8, W0
0027EE  784010     MOV.B [W0], W0
0027F0  FB8000     ZE W0, W0
0027F2  8846E0     MOV W0, 0x8DC
243:                               Devices.SystemStatedUpdate = TRUE;
0027F4  A80877     BSET 0x877, #0
244:                               SendFrame(1, CMD_ACK); //send ack
0027F6  B3C411     MOV.B #0x41, W1
0027F8  B3C010     MOV.B #0x1, W0
0027FA  07FED0     RCALL SendFrame
245:                           } else SendFrame(1, CMD_NACK); //send ack
0027FE  B3C141     MOV.B #0x14, W1
002800  B3C010     MOV.B #0x1, W0
002802  07FECC     RCALL SendFrame
246:                           break;
0027FC  3700D3     BRA 0x29A4
002804  3700CF     BRA 0x29A4
247:               
248:                       case CMD_TEC_CONTROL:
249:                           TECVoltage = RXbuffer[9];
002806  208E90     MOV #0x8E9, W0
002808  784010     MOV.B [W0], W0
00280A  FB8000     ZE W0, W0
00280C  884010     MOV W0, TECVoltage
250:                           TECVoltage <<= 8;
00280E  804010     MOV TECVoltage, W0
002810  DD0048     SL W0, #8, W0
002812  884010     MOV W0, TECVoltage
251:                           TECVoltage += RXbuffer[10];
002814  208EA0     MOV #0x8EA, W0
002816  784010     MOV.B [W0], W0
002818  FB8080     ZE W0, W1
00281A  804010     MOV TECVoltage, W0
00281C  408000     ADD W1, W0, W0
00281E  884010     MOV W0, TECVoltage
252:                           if (TECVoltage > 15600)TECVoltage = 15600;
002820  804011     MOV TECVoltage, W1
002822  23CF00     MOV #0x3CF0, W0
002824  508F80     SUB W1, W0, [W15]
002826  360002     BRA LEU, 0x282C
002828  23CF00     MOV #0x3CF0, W0
00282A  884010     MOV W0, TECVoltage
253:                           Devices2.TecVoltageUpdateByVoltage = TRUE;
00282C  A828B8     BSET 0x8B8, #1
254:                           if (RXbuffer[8]) {
00282E  208E80     MOV #0x8E8, W0
002830  784010     MOV.B [W0], W0
002832  E00400     CP0.B W0
002834  320002     BRA Z, 0x283A
255:                               Devices.TecIsEnabled = TRUE;
002836  A80876     BSET Devices, #0
002838  370001     BRA 0x283C
256:                           } else {
257:                               Devices.TecIsEnabled = FALSE;
00283A  A90876     BCLR Devices, #0
258:                           }
259:                           SendFrame(1, CMD_ACK); //send ack
00283C  B3C411     MOV.B #0x41, W1
00283E  B3C010     MOV.B #0x1, W0
002840  07FEAD     RCALL SendFrame
260:                           break;
002842  3700B0     BRA 0x29A4
261:               
262:                       case CMD_CAP_DISCHARGE:
263:                           if (RXbuffer[8]) {
002844  208E80     MOV #0x8E8, W0
002846  784010     MOV.B [W0], W0
002848  E00400     CP0.B W0
00284A  320002     BRA Z, 0x2850
264:                               Devices.DischargeIsEnabled = TRUE;
00284C  A8E877     BSET 0x877, #7
00284E  370001     BRA 0x2852
265:                           } else {
266:                               Devices.DischargeIsEnabled = FALSE;
002850  A9E877     BCLR 0x877, #7
267:                           }
268:                           SendFrame(1, CMD_ACK); //send ack
002852  B3C411     MOV.B #0x41, W1
002854  B3C010     MOV.B #0x1, W0
002856  07FEA2     RCALL SendFrame
269:                           break;
002858  3700A5     BRA 0x29A4
270:               
271:                       case CMD_CHARGER_CONTROL:
272:                           if (RXbuffer[8]) {
00285A  208E80     MOV #0x8E8, W0
00285C  784010     MOV.B [W0], W0
00285E  E00400     CP0.B W0
002860  320002     BRA Z, 0x2866
273:                               Devices.ChargerIsEnabled = TRUE;
002862  A86877     BSET 0x877, #3
002864  370001     BRA 0x2868
274:                           } else {
275:                               Devices.ChargerIsEnabled = FALSE;
002866  A96877     BCLR 0x877, #3
276:                           }
277:                           SendFrame(1, CMD_ACK); //send ack
002868  B3C411     MOV.B #0x41, W1
00286A  B3C010     MOV.B #0x1, W0
00286C  07FE97     RCALL SendFrame
278:                           break;
00286E  37009A     BRA 0x29A4
279:               #if __BLACKBOX
280:                       case CMD_PULSE_PARAMETERS:
281:                           Pulse_On_Time = ((u32) (RXbuffer[8])*10000) / 64; //= ((Xms-1) * 10000)/16
282:                           Pulse_Off_Time = RXbuffer[9];
283:                           Pulse_Off_Time <<= 8;
284:                           Pulse_Off_Time += RXbuffer[10];
285:                           if (Pulse_Off_Time) {
286:                               Pulse_Off_Time = Pulse_Off_Time - RXbuffer[8];
287:                               Pulse_Off_Time = Pulse_Off_Time * 10;
288:                               Devices2.AutoRepeat = 1;
289:                           } else {
290:                               Devices2.AutoRepeat = 0;
291:                               Pulse_Off_Time = 10000;
292:                           }
293:                           SendFrame(1, CMD_ACK); //send ack
294:                           break;
295:               
296:                       case CMD_LDDRIVER_CONTROL:
297:                           if (RXbuffer[8]) {
298:                               Devices.LddriverIsEnable = TRUE;
299:                           } else {
300:                               Devices.LddriverIsEnable = FALSE;
301:                           }
302:                           LddriverCurrent = RXbuffer[9];
303:                           LddriverCurrent <<= 8;
304:                           LddriverCurrent += RXbuffer[10];
305:                           Devices.DriverCurrentUpdate = TRUE;
306:                           SendFrame(1, CMD_ACK); //send ack
307:                           break;
308:               #endif
309:                       case CMD_HPDL_PULSE_PARAMETER:
310:                           if ((RXbuffer[8] < 200)&&(RXbuffer[11] < 150)) { //check if critical parameters in allowable limits
002870  208E80     MOV #0x8E8, W0
002872  784090     MOV.B [W0], W1
002874  B3CC70     MOV.B #0xC7, W0
002876  50CF80     SUB.B W1, W0, [W15]
002878  3E0066     BRA GTU, 0x2946
00287A  208EB0     MOV #0x8EB, W0
00287C  784090     MOV.B [W0], W1
00287E  B3C950     MOV.B #0x95, W0
002880  50CF80     SUB.B W1, W0, [W15]
002882  3E0061     BRA GTU, 0x2946
311:                               Pulse_On_Time = ((u32) (RXbuffer[8])*10000) / 64; //= ((Xms-1) * 10000)/64
002884  208E80     MOV #0x8E8, W0
002886  784010     MOV.B [W0], W0
002888  FB8000     ZE W0, W0
00288A  EB0080     CLR W1
00288C  227102     MOV #0x2710, W2
00288E  B98902     MUL.SS W1, W2, W2
002890  780102     MOV W2, W2
002892  B90260     MUL.SU W0, #0, W4
002894  780184     MOV W4, W3
002896  410103     ADD W2, W3, W2
002898  227103     MOV #0x2710, W3
00289A  B80003     MUL.UU W0, W3, W0
00289C  410101     ADD W2, W1, W2
00289E  780082     MOV W2, W1
0028A0  DD094A     SL W1, #10, W2
0028A2  DE0046     LSR W0, #6, W0
0028A4  710000     IOR W2, W0, W0
0028A6  DE08C6     LSR W1, #6, W1
0028A8  780000     MOV W0, W0
0028AA  8845E0     MOV W0, 0x8BC
312:                               Pulse_On_Time = Pulse_On_Time - 144; //offset for one shot
0028AC  8045E0     MOV 0x8BC, W0
0028AE  B10900     SUB #0x90, W0
0028B0  8845E0     MOV W0, 0x8BC
313:                               Pulse_Off_Time = RXbuffer[9];
0028B2  208E90     MOV #0x8E9, W0
0028B4  784010     MOV.B [W0], W0
0028B6  FB8000     ZE W0, W0
0028B8  8845F0     MOV W0, 0x8BE
314:                               Pulse_Off_Time <<= 8;
0028BA  8045F0     MOV 0x8BE, W0
0028BC  DD0048     SL W0, #8, W0
0028BE  8845F0     MOV W0, 0x8BE
315:                               Pulse_Off_Time += RXbuffer[10];
0028C0  208EA0     MOV #0x8EA, W0
0028C2  784010     MOV.B [W0], W0
0028C4  FB8080     ZE W0, W1
0028C6  8045F0     MOV 0x8BE, W0
0028C8  408000     ADD W1, W0, W0
0028CA  8845F0     MOV W0, 0x8BE
316:               
317:                               if (Pulse_Off_Time) {
0028CC  8045F0     MOV 0x8BE, W0
0028CE  E00000     CP0 W0
0028D0  32000A     BRA Z, 0x28E6
318:                                   Pulse_Off_Time = Pulse_Off_Time - RXbuffer[8];
0028D2  8045F1     MOV 0x8BE, W1
0028D4  208E80     MOV #0x8E8, W0
0028D6  784010     MOV.B [W0], W0
0028D8  FB8000     ZE W0, W0
0028DA  508000     SUB W1, W0, W0
0028DC  8845F0     MOV W0, 0x8BE
319:                                   Pulse_Off_Time = Pulse_Off_Time;
0028DE  8045F0     MOV 0x8BE, W0
0028E0  8845F0     MOV W0, 0x8BE
320:                                   Devices2.AutoRepeat = 1;
0028E2  A848B8     BSET 0x8B8, #2
0028E4  370003     BRA 0x28EC
321:                               } else {
322:                                   Devices2.AutoRepeat = 0;
0028E6  A948B8     BCLR 0x8B8, #2
323:                                   Pulse_Off_Time = 10000;
0028E8  227100     MOV #0x2710, W0
0028EA  8845F0     MOV W0, 0x8BE
324:                               }
325:                               LddriverCurrent = RXbuffer[11];
0028EC  208EB0     MOV #0x8EB, W0
0028EE  784010     MOV.B [W0], W0
0028F0  FB8000     ZE W0, W0
0028F2  884590     MOV W0, LddriverCurrent
326:                               Devices.DriverCurrentUpdate = TRUE;
0028F4  A8A877     BSET 0x877, #5
327:                               CoolingLevel = RXbuffer[12];
0028F6  208EC0     MOV #0x8EC, W0
0028F8  784010     MOV.B [W0], W0
0028FA  FB8000     ZE W0, W0
0028FC  884670     MOV W0, 0x8CE
328:                               SendFrame(1, CMD_ACK); //send ack
0028FE  B3C411     MOV.B #0x41, W1
002900  B3C010     MOV.B #0x1, W0
002902  07FE4C     RCALL SendFrame
329:               
330:                               MaxAllowedCurrent = LddriverCurrent + LddriverCurrent * 0.15;
002904  804590     MOV LddriverCurrent, W0
002906  EB0080     CLR W1
002908  07F4C4     RCALL 0x1292
00290A  BE0400     MOV.D W0, W8
00290C  804590     MOV LddriverCurrent, W0
00290E  EB0080     CLR W1
002910  07F4C0     RCALL 0x1292
002912  2999A2     MOV #0x999A, W2
002914  23E193     MOV #0x3E19, W3
002916  07F512     RCALL 0x133C
002918  BE0100     MOV.D W0, W2
00291A  BE0008     MOV.D W8, W0
00291C  07F3DB     RCALL 0x10D4
00291E  07F49E     RCALL 0x125C
002920  780000     MOV W0, W0
002922  8842E0     MOV W0, MaxAllowedCurrent
331:                               MinAllowedCurrent = LddriverCurrent - LddriverCurrent * 0.15;
002924  804590     MOV LddriverCurrent, W0
002926  EB0080     CLR W1
002928  07F4B4     RCALL 0x1292
00292A  BE0400     MOV.D W0, W8
00292C  804590     MOV LddriverCurrent, W0
00292E  EB0080     CLR W1
002930  07F4B0     RCALL 0x1292
002932  2999A2     MOV #0x999A, W2
002934  23E193     MOV #0x3E19, W3
002936  07F502     RCALL 0x133C
002938  BE0100     MOV.D W0, W2
00293A  BE0008     MOV.D W8, W0
00293C  07F3CA     RCALL 0x10D2
00293E  07F48E     RCALL 0x125C
002940  780000     MOV W0, W0
002942  8842F0     MOV W0, MinAllowedCurrent
332:                           } else SendFrame(1, CMD_NACK);
002946  B3C141     MOV.B #0x14, W1
002948  B3C010     MOV.B #0x1, W0
00294A  07FE28     RCALL SendFrame
333:                           break;
002944  37002F     BRA 0x29A4
00294C  37002B     BRA 0x29A4
334:               
335:                       case CMD_LIGHTGUIDE_PARAMETER_REQUEST:
336:                           TXbuffer[8] = 0;
00294E  209E80     MOV #0x9E8, W0
002950  EB4080     CLR.B W1
002952  784801     MOV.B W1, [W0]
337:                           TXbuffer[9] = 0;
002954  209E90     MOV #0x9E9, W0
002956  EB4080     CLR.B W1
002958  784801     MOV.B W1, [W0]
338:                           TXbuffer[10] = 0;
00295A  209EA0     MOV #0x9EA, W0
00295C  EB4080     CLR.B W1
00295E  784801     MOV.B W1, [W0]
339:                           TXbuffer[11] = 0;
002960  209EB0     MOV #0x9EB, W0
002962  EB4080     CLR.B W1
002964  784801     MOV.B W1, [W0]
340:                           TXbuffer[12] = 0;
002966  209EC0     MOV #0x9EC, W0
002968  EB4080     CLR.B W1
00296A  784801     MOV.B W1, [W0]
341:                           TXbuffer[13] = 0;
00296C  209ED0     MOV #0x9ED, W0
00296E  EB4080     CLR.B W1
002970  784801     MOV.B W1, [W0]
342:                           TXbuffer[14] = 0;
002972  209EE0     MOV #0x9EE, W0
002974  EB4080     CLR.B W1
002976  784801     MOV.B W1, [W0]
343:                           TXbuffer[15] = 0;
002978  209EF0     MOV #0x9EF, W0
00297A  EB4080     CLR.B W1
00297C  784801     MOV.B W1, [W0]
344:                           TXbuffer[16] = 0;
00297E  209F00     MOV #0x9F0, W0
002980  EB4080     CLR.B W1
002982  784801     MOV.B W1, [W0]
345:                           TXbuffer[17] = 0;
002984  209F10     MOV #0x9F1, W0
002986  EB4080     CLR.B W1
002988  784801     MOV.B W1, [W0]
346:                           TXbuffer[18] = 0;
00298A  209F20     MOV #0x9F2, W0
00298C  EB4080     CLR.B W1
00298E  784801     MOV.B W1, [W0]
347:                           TXbuffer[19] = 0;
002990  209F30     MOV #0x9F3, W0
002992  EB4080     CLR.B W1
002994  784801     MOV.B W1, [W0]
348:                           SendFrame(13, CMD_LIGHTGUIDE_PARAMETER_RESPONCE);
002996  B3C521     MOV.B #0x52, W1
002998  B3C0D0     MOV.B #0xD, W0
00299A  07FE00     RCALL SendFrame
349:                           break;
00299C  370003     BRA 0x29A4
350:               
351:                       default:
352:                           SendFrame(1, CMD_NACK); //send nack command is not recognised
00299E  B3C141     MOV.B #0x14, W1
0029A0  B3C010     MOV.B #0x1, W0
0029A2  07FDFC     RCALL SendFrame
353:                   }
354:               }
0029A4  BE044F     MOV.D [--W15], W8
0029A6  FA8000     ULNK
0029A8  060000     RETURN
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/capbank.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"          /* User funct/params, such as InitApp              */
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define CAPBANK_INIT_TASK       0
20:                #define CAPBANK_WAIT_TASK       1
21:                #define CAPBANK_READY_TASK      2
22:                #define CAPBANK_DISCHARGE_TASK  3
23:                #define CAPBANK_CHARGE_TASK     4
24:                #define CAPBANK_FAULT_TASK      5
25:                /*================================================*/
26:                
27:                /*================= Variables ===============================*/
28:                u16 current_capacitors_bank_task = 0;
29:                u32 ChargerTimeCntr = 0;
30:                u16 CalculatedChargeVoltage = 0;
31:                u16 ActualCapacitorVoltage = 0;
32:                u16 MaxChargeLimit = 0;
33:                u16 MinChargeLimit = 0;
34:                u16 OnTimeForChargeCalculation = 0;
35:                u16 DEBUG_MEMORY_CapVoltage = 0;
36:                u16 FlickerTimer = 0;
37:                
38:                extern u16 SystemStateToUpdate;
39:                /*================================================*/
40:                
41:                /*================= Functions ===============================*/
42:                void SetChargeVoltage(u16 val);
43:                void capacitors_bank_tasks(void);
44:                /*================================================*/
45:                
46:                /**********************************************************************
47:                 * Function:        void SetChargeVoltage(u16 val)
48:                 * PreCondition:    None
49:                 * Input:	    val - charge voltage value
50:                 * Output:	    None
51:                 * Overview:	    This function used to calculate charge voltage and send to SPI procedure
52:                 *
53:                 ***********************************************************************/
54:                void SetChargeVoltage(u16 val) {
0034C2  FA0002     LNK #0x2
0034C4  780F00     MOV W0, [W14]
55:                    val = val * 3.4;
0034C6  78001E     MOV [W14], W0
0034C8  EB0080     CLR W1
0034CA  07EEE3     RCALL 0x1292
0034CC  2999A2     MOV #0x999A, W2
0034CE  240593     MOV #0x4059, W3
0034D0  07EF35     RCALL 0x133C
0034D2  07EEC4     RCALL 0x125C
0034D4  780F00     MOV W0, [W14]
56:                    val <<= 2;
0034D6  78001E     MOV [W14], W0
0034D8  DD0042     SL W0, #2, W0
0034DA  780F00     MOV W0, [W14]
57:                    val = 0x1000 + val;
0034DC  210000     MOV #0x1000, W0
0034DE  400F1E     ADD W0, [W14], [W14]
58:                    while (!CommFlags.SPI1RxDone);
0034E0  000000     NOP
0034E2  8045B0     MOV 0x8B6, W0
0034E4  600064     AND W0, #0x4, W0
0034E6  E00000     CP0 W0
0034E8  32FFFC     BRA Z, 0x34E2
59:                    CS_DAC = LOW;
0034EA  A962F4     BCLR LATG, #3
60:                    SPIReadWriteWord(val);
0034EC  78001E     MOV [W14], W0
0034EE  07F805     RCALL SPIReadWriteWord
61:                    CS_DAC = HIGH;
0034F0  A862F4     BSET LATG, #3
62:                }
0034F2  FA8000     ULNK
0034F4  060000     RETURN
63:                
64:                /**********************************************************************
65:                 * Function:        void capacitors_bank_tasks(void)
66:                 * PreCondition:    None
67:                 * Input:	    None
68:                 * Output:	    None
69:                 * Overview:	    This function used to manage charger and capacitors bank
70:                 *
71:                 ***********************************************************************/
72:                void capacitors_bank_tasks(void) {
0034F6  FA0000     LNK #0x0
73:                
74:                #ifdef __BLACKBOX
75:                    if (Devices.DischargeIsEnabled) {
76:                        CHARGER_ENABLE = HIGH; //disable charger 
77:                        DISCHARGE = LOW; //start discharge
78:                        Devices.ChargerIsReady = FALSE;
79:                        Devices.ChargerIsEnabled = FALSE;
80:                        current_capacitors_bank_task = CAPBANK_INIT_TASK;
81:                    } else {
82:                        DISCHARGE = HIGH;
83:                    }
84:                #endif
85:                
86:                    switch (current_capacitors_bank_task) {
0034F8  804310     MOV current_capacitors_bank_task, W0
0034FA  500FE2     SUB W0, #0x2, [W15]
0034FC  32003C     BRA Z, 0x3576
0034FE  500FE2     SUB W0, #0x2, [W15]
003500  3E0003     BRA GTU, 0x3508
003502  E00000     CP0 W0
003504  320004     BRA Z, 0x350E
003506  370088     BRA 0x3618
003508  500FE4     SUB W0, #0x4, [W15]
00350A  320011     BRA Z, 0x352E
87:                        case CAPBANK_INIT_TASK:
88:                            if (Devices.ChargerIsEnabled == TRUE) {
00350E  8043B1     MOV Devices, W1
003510  208000     MOV #0x800, W0
003512  608000     AND W1, W0, W0
003514  E00000     CP0 W0
003516  320008     BRA Z, 0x3528
89:                                Devices.DischargeIsEnabled = FALSE;
003518  A9E877     BCLR 0x877, #7
90:                                DISCHARGE = HIGH; //stop discharge before charger enable
00351A  A8E2C4     BSET LATA, #7
91:                                CHARGER_ENABLE = LOW; //star charge capacitors
00351C  A922F5     BCLR 0x2F5, #1
92:                                ChargerTimeCntr = 0; //reset counter for charge time out
00351E  EF2864     CLR ChargerTimeCntr
003520  EF2866     CLR 0x866
93:                                current_capacitors_bank_task = CAPBANK_CHARGE_TASK;
003522  200040     MOV #0x4, W0
003524  884310     MOV W0, current_capacitors_bank_task
94:                            } else {
95:                                CHARGER_ENABLE = HIGH; //disable charger
003528  A822F5     BSET 0x2F5, #1
96:                                Devices.ChargerIsReady = FALSE;
00352A  A98877     BCLR 0x877, #4
97:                            }
98:                            break;
003526  370078     BRA 0x3618
00352C  370075     BRA 0x3618
99:                
100:                       case CAPBANK_CHARGE_TASK:
101:                           if (Devices.ChargerIsEnabled == TRUE) {
00352E  8043B1     MOV Devices, W1
003530  208000     MOV #0x800, W0
003532  608000     AND W1, W0, W0
003534  E00000     CP0 W0
003536  32001B     BRA Z, 0x356E
102:                               if (CapVoltage > 250) {
003538  804432     MOV CapVoltage, W2
00353A  804443     MOV 0x888, W3
00353C  200FA0     MOV #0xFA, W0
00353E  200001     MOV #0x0, W1
003540  510F80     SUB W2, W0, [W15]
003542  598F81     SUBB W3, W1, [W15]
003544  360005     BRA LEU, 0x3550
103:                                   Devices.ChargerIsReady = TRUE;
003546  A88877     BSET 0x877, #4
104:                                   current_capacitors_bank_task = CAPBANK_READY_TASK;
003548  200020     MOV #0x2, W0
00354A  884310     MOV W0, current_capacitors_bank_task
105:                                   FlickerTimer = 0;
00354C  EF2874     CLR FlickerTimer
106:                               } else if (ChargerTimeCntr > 5000) {
003550  804322     MOV ChargerTimeCntr, W2
003552  804333     MOV 0x866, W3
003554  213880     MOV #0x1388, W0
003556  200001     MOV #0x0, W1
003558  510F80     SUB W2, W0, [W15]
00355A  598F81     SUBB W3, W1, [W15]
00355C  360056     BRA LEU, 0x360A
107:                                   FaultNumber = FAULT_CAPACITOR_CHARGER; //time out occured 
00355E  200290     MOV #0x29, W0
003560  8843C0     MOV W0, FaultNumber
108:                                   Devices.SystemStatedUpdate = TRUE;
003562  A80877     BSET 0x877, #0
109:                                   SystemStateToUpdate = SYS_STATE_FAULT;
003564  2000F0     MOV #0xF, W0
003566  8846E0     MOV W0, 0x8DC
110:                                   current_capacitors_bank_task = CAPBANK_FAULT_TASK;
003568  200050     MOV #0x5, W0
00356A  884310     MOV W0, current_capacitors_bank_task
111:                               }
112:                           } else {
113:                               CHARGER_ENABLE = HIGH; //disable charger
00356E  A822F5     BSET 0x2F5, #1
114:                               Devices.ChargerIsReady = FALSE;
003570  A98877     BCLR 0x877, #4
115:                               current_capacitors_bank_task = CAPBANK_INIT_TASK;
003572  EF2862     CLR current_capacitors_bank_task
116:                           }
117:               
118:                           break;
00354E  370064     BRA 0x3618
00356C  370055     BRA 0x3618
003574  370051     BRA 0x3618
00360A  000000     NOP
00360C  370005     BRA 0x3618
119:               
120:                       case CAPBANK_READY_TASK:
121:                           if (Devices.ChargerIsEnabled == FALSE) {
003576  8043B1     MOV Devices, W1
003578  208000     MOV #0x800, W0
00357A  608000     AND W1, W0, W0
00357C  E00000     CP0 W0
00357E  3A0004     BRA NZ, 0x3588
122:                               CHARGER_ENABLE = HIGH; //disable charger
003580  A822F5     BSET 0x2F5, #1
123:                               Devices.ChargerIsReady = FALSE;
003582  A98877     BCLR 0x877, #4
124:                               current_capacitors_bank_task = CAPBANK_INIT_TASK;
003584  EF2862     CLR current_capacitors_bank_task
125:                           } else if (CapVoltage < 230) {
003588  804432     MOV CapVoltage, W2
00358A  804443     MOV 0x888, W3
00358C  200E50     MOV #0xE5, W0
00358E  200001     MOV #0x0, W1
003590  510F80     SUB W2, W0, [W15]
003592  598F81     SUBB W3, W1, [W15]
003594  3E000C     BRA GTU, 0x35AE
126:                               DEBUG_MEMORY_CapVoltage = CapVoltage;
003596  804430     MOV CapVoltage, W0
003598  804441     MOV 0x888, W1
00359A  780000     MOV W0, W0
00359C  884390     MOV W0, DEBUG_MEMORY_CapVoltage
127:                               FaultNumber = FAULT_CAPACITOR_CHARGER; //time out occured 
00359E  200290     MOV #0x29, W0
0035A0  8843C0     MOV W0, FaultNumber
128:                               Devices.SystemStatedUpdate = TRUE;
0035A2  A80877     BSET 0x877, #0
129:                               SystemStateToUpdate = SYS_STATE_FAULT;
0035A4  2000F0     MOV #0xF, W0
0035A6  8846E0     MOV W0, 0x8DC
130:                               current_capacitors_bank_task = CAPBANK_FAULT_TASK;
0035A8  200050     MOV #0x5, W0
0035AA  884310     MOV W0, current_capacitors_bank_task
131:                           } else if (CHARGER_ENABLE == LOW) {
0035AE  8017A1     MOV LATG, W1
0035B0  202000     MOV #0x200, W0
0035B2  608000     AND W1, W0, W0
0035B4  E00000     CP0 W0
0035B6  3A0012     BRA NZ, 0x35DC
132:                               if (FlickerTimer > 5) {
0035B8  8043A0     MOV FlickerTimer, W0
0035BA  500FE5     SUB W0, #0x5, [W15]
0035BC  360028     BRA LEU, 0x360E
133:                                   CHARGER_ENABLE ^= 1;
0035BE  8017A0     MOV LATG, W0
0035C0  DE0049     LSR W0, #9, W0
0035C2  604061     AND.B W0, #0x1, W0
0035C4  A20400     BTG.B W0, #0
0035C6  604061     AND.B W0, #0x1, W0
0035C8  FB8000     ZE W0, W0
0035CA  600061     AND W0, #0x1, W0
0035CC  DD0049     SL W0, #9, W0
0035CE  8017A2     MOV LATG, W2
0035D0  2FDFF1     MOV #0xFDFF, W1
0035D2  610081     AND W2, W1, W1
0035D4  700001     IOR W0, W1, W0
0035D6  8817A0     MOV W0, LATG
134:                                   FlickerTimer = 0;
0035D8  EF2874     CLR FlickerTimer
135:                               }
136:                           } else if (CHARGER_ENABLE == HIGH) {
0035DC  8017A1     MOV LATG, W1
0035DE  202000     MOV #0x200, W0
0035E0  608000     AND W1, W0, W0
0035E2  E00000     CP0 W0
0035E4  320016     BRA Z, 0x3612
137:                               if (FlickerTimer > 8) {
0035E6  8043A0     MOV FlickerTimer, W0
0035E8  500FE8     SUB W0, #0x8, [W15]
0035EA  360015     BRA LEU, 0x3616
138:                                   CHARGER_ENABLE ^= 1;
0035EC  8017A0     MOV LATG, W0
0035EE  DE0049     LSR W0, #9, W0
0035F0  604061     AND.B W0, #0x1, W0
0035F2  A20400     BTG.B W0, #0
0035F4  604061     AND.B W0, #0x1, W0
0035F6  FB8000     ZE W0, W0
0035F8  600061     AND W0, #0x1, W0
0035FA  DD0049     SL W0, #9, W0
0035FC  8017A2     MOV LATG, W2
0035FE  2FDFF1     MOV #0xFDFF, W1
003600  610081     AND W2, W1, W1
003602  700001     IOR W0, W1, W0
003604  8817A0     MOV W0, LATG
139:                                   FlickerTimer = 0;
003606  EF2874     CLR FlickerTimer
140:                               }
141:                           }
142:                           break;
003586  370048     BRA 0x3618
0035AC  370035     BRA 0x3618
0035DA  37001E     BRA 0x3618
003608  370007     BRA 0x3618
00360E  000000     NOP
003610  370003     BRA 0x3618
003612  000000     NOP
003614  370001     BRA 0x3618
003616  000000     NOP
143:               
144:                       case CAPBANK_FAULT_TASK:
145:               
146:                           break;
00350C  370085     BRA 0x3618
147:               
148:                   }
149:               }
003618  FA8000     ULNK
00361A  060000     RETURN
---  C:/Users/Oleg Perlin/Dropbox (VENUS CONCEPT R&D)/Venus/HIGH POWER DIODE/Software/HPD_CONTROLER.X/applicator.c
1:                 #if defined(__XC16__)
2:                 #include <xc.h>
3:                 #elif defined(__C30__)
4:                 #if defined(__dsPIC33E__)
5:                 #include <p33Exxxx.h>
6:                 #elif defined(__dsPIC33F__)
7:                 #include <p33Fxxxx.h>
8:                 #endif
9:                 #endif
10:                
11:                #include <stdint.h>        /* Includes uint16_t definition                    */
12:                #include <stdbool.h>       /* Includes true/false definition                  */
13:                
14:                #include "system.h"        /* System funct/params, like osc/peripheral config */
15:                #include "user.h"          /* User funct/params, such as InitApp              */
16:                #include <dsp.h>
17:                
18:                /*================= Macros ===============================*/
19:                #define WAIT_APPSHORT            0
20:                #define WAIT_APPSHORT_BOUNCING  1
21:                #define APPSHORT_FAULT          2
22:                #define APPSHORT_FAULT_QUIT 3
23:                
24:                #define LIGHTGUIDE_WAIT_SHORT            0
25:                #define LIGHTGUIDE_WAIT_SHORT_BOUNCING  1
26:                #define LIGHTGUIDE_FAULT          2
27:                #define LIGHTGUIDE_FAULT_QUIT 3
28:                
29:                #define WAIT_TRIGGER        0
30:                #define WAIT_BOUNCING       1
31:                #define WAIT_RELEASE        2
32:                #define TRIGER_NOT_RELEASED 3
33:                #define WAIT_FOR_SECOND_SWITCH 4
34:                #define TRIGGER_FAULT       5
35:                /*================================================*/
36:                
37:                /*================= Variables ===============================*/
38:                u16 current_app_short_tasks = 0;
39:                u16 appShortTimeOut = 0;
40:                u16 LightGuideShortTimeOut = 0;
41:                u16 current_trigger_task = 0;
42:                u16 Trigger = 0;
43:                u16 TriggerCounter = 0;
44:                u16 current_lihgtguide_short_tasks = 0;
45:                
46:                extern u16 SystemStateToUpdate;
47:                /*================================================*/
48:                
49:                /*================= Functions ===============================*/
50:                void lihgtguide_short_task(void);
51:                void app_short_tasks(void);
52:                void trigger_tasks(void);
53:                /*================================================*/
54:                
55:                /**********************************************************************
56:                 * Function:        void lihgtguide_short_task(void)
57:                 * PreCondition:    None
58:                 * Input:	    None
59:                 * Output:	    None
60:                 * Overview:	    This function used to manage light guide connection
61:                 *
62:                 ***********************************************************************/
63:                void lihgtguide_short_task(void) {
002D84  FA0000     LNK #0x0
64:                    if (Devices.ApplicatorIsConnected == TRUE) {
002D86  8043B1     MOV Devices, W1
002D88  202000     MOV #0x200, W0
002D8A  608000     AND W1, W0, W0
002D8C  E00000     CP0 W0
002D8E  320054     BRA Z, 0x2E38
65:                        switch (current_lihgtguide_short_tasks) {
002D90  804550     MOV current_lihgtguide_short_tasks, W0
002D92  500FE1     SUB W0, #0x1, [W15]
002D94  320012     BRA Z, 0x2DBA
002D96  500FE1     SUB W0, #0x1, [W15]
002D98  390005     BRA NC, 0x2DA4
002D9A  500FE2     SUB W0, #0x2, [W15]
002D9C  320021     BRA Z, 0x2DE0
002D9E  500FE3     SUB W0, #0x3, [W15]
002DA0  320028     BRA Z, 0x2DF2
002DA2  37004A     BRA 0x2E38
66:                            case LIGHTGUIDE_WAIT_SHORT:
67:                                if (LIGHTGUIDE_SHORT) {
002DA4  801711     MOV PORTE, W1
002DA6  200800     MOV #0x80, W0
002DA8  608000     AND W1, W0, W0
002DAA  E00000     CP0 W0
002DAC  320004     BRA Z, 0x2DB6
68:                                    LightGuideShortTimeOut = 0; //reset timer
002DAE  EF28A2     CLR LightGuideShortTimeOut
69:                                    current_lihgtguide_short_tasks = LIGHTGUIDE_WAIT_SHORT_BOUNCING;
002DB0  200010     MOV #0x1, W0
002DB2  884550     MOV W0, current_lihgtguide_short_tasks
70:                                } else {
71:                                    Devices2.LighGuideIsConnected = TRUE;
002DB6  A888B8     BSET 0x8B8, #4
72:                                }
73:                                break;
002DB4  370041     BRA 0x2E38
002DB8  37003F     BRA 0x2E38
74:                
75:                            case LIGHTGUIDE_WAIT_SHORT_BOUNCING:
76:                                if (LightGuideShortTimeOut > 15) { //delay 5ms for bouncing
002DBA  804510     MOV LightGuideShortTimeOut, W0
002DBC  500FEF     SUB W0, #0xF, [W15]
002DBE  360035     BRA LEU, 0x2E2A
77:                                    if (LIGHTGUIDE_SHORT) {//if ipl applicator disconnected or not connected shut off ipl module
002DC0  801711     MOV PORTE, W1
002DC2  200800     MOV #0x80, W0
002DC4  608000     AND W1, W0, W0
002DC6  E00000     CP0 W0
002DC8  320009     BRA Z, 0x2DDC
78:                                        Devices2.LighGuideIsConnected = FALSE; //applicator disconnected
002DCA  A988B8     BCLR 0x8B8, #4
79:                                        Devices.SystemStatedUpdate = TRUE;
002DCC  A80877     BSET 0x877, #0
80:                                        SystemStateToUpdate = SYS_STATE_FAULT;
002DCE  2000F0     MOV #0xF, W0
002DD0  8846E0     MOV W0, 0x8DC
81:                                        FaultNumber = FAULT_LIGHTGUIDE_DISCONNECTED;
002DD2  200250     MOV #0x25, W0
002DD4  8843C0     MOV W0, FaultNumber
82:                                        current_lihgtguide_short_tasks = LIGHTGUIDE_FAULT;
002DD6  200020     MOV #0x2, W0
002DD8  884550     MOV W0, current_lihgtguide_short_tasks
83:                                    } else {
84:                                        current_lihgtguide_short_tasks = LIGHTGUIDE_WAIT_SHORT;
002DDC  EF28AA     CLR current_lihgtguide_short_tasks
85:                                    }
86:                                }
87:                                break;
002DDA  37002E     BRA 0x2E38
002DDE  37002C     BRA 0x2E38
002E2A  000000     NOP
002E2C  370005     BRA 0x2E38
88:                
89:                            case LIGHTGUIDE_FAULT:
90:                                if (!LIGHTGUIDE_SHORT) {
002DE0  801711     MOV PORTE, W1
002DE2  200800     MOV #0x80, W0
002DE4  608000     AND W1, W0, W0
002DE6  E00000     CP0 W0
002DE8  3A0022     BRA NZ, 0x2E2E
91:                                    LightGuideShortTimeOut = 0; //reset timer
002DEA  EF28A2     CLR LightGuideShortTimeOut
92:                                    current_lihgtguide_short_tasks = LIGHTGUIDE_FAULT_QUIT;
002DEC  200030     MOV #0x3, W0
002DEE  884550     MOV W0, current_lihgtguide_short_tasks
93:                                }
94:                                break;
002DF0  370023     BRA 0x2E38
002E2E  000000     NOP
002E30  370003     BRA 0x2E38
95:                
96:                            case LIGHTGUIDE_FAULT_QUIT:
97:                                if (LightGuideShortTimeOut > 500) {
002DF2  804511     MOV LightGuideShortTimeOut, W1
002DF4  201F40     MOV #0x1F4, W0
002DF6  508F80     SUB W1, W0, [W15]
002DF8  36001C     BRA LEU, 0x2E32
98:                                    if (!LIGHTGUIDE_SHORT) {
002DFA  801711     MOV PORTE, W1
002DFC  200800     MOV #0x80, W0
002DFE  608000     AND W1, W0, W0
002E00  E00000     CP0 W0
002E02  3A0019     BRA NZ, 0x2E36
99:                                        if (FaultNumber == FAULT_LIGHTGUIDE_DISCONNECTED) {
002E04  8043C1     MOV FaultNumber, W1
002E06  200250     MOV #0x25, W0
002E08  508F80     SUB W1, W0, [W15]
002E0A  3A000D     BRA NZ, 0x2E26
100:                                           Devices2.LightGuideReconnected = TRUE;
002E0C  A828B9     BSET 0x8B9, #1
101:                                           Devices.SystemStatedUpdate = TRUE;
002E0E  A80877     BSET 0x877, #0
102:                                           SystemStateToUpdate = SYS_STATE_INIT;
002E10  200010     MOV #0x1, W0
002E12  8846E0     MOV W0, 0x8DC
103:                                           FaultNumber = CLEAR;
002E14  EF2878     CLR FaultNumber
104:                                           LightGuideShortTimeOut = 0; //reset timer
002E16  EF28A2     CLR LightGuideShortTimeOut
105:                                           Devices.ApplicatorIsConnected = FALSE; //applicator disconnected because we need read chip id again.
002E18  A92877     BCLR 0x877, #1
106:                                           appShortTimeOut = 0; //reset timer
002E1A  EF28A0     CLR appShortTimeOut
107:                                           current_app_short_tasks = WAIT_APPSHORT_BOUNCING;
002E1C  200010     MOV #0x1, W0
002E1E  8844F0     MOV W0, current_app_short_tasks
108:                                           current_lihgtguide_short_tasks = WAIT_APPSHORT_BOUNCING;
002E20  200010     MOV #0x1, W0
002E22  884550     MOV W0, current_lihgtguide_short_tasks
109:                                       } else current_lihgtguide_short_tasks = LIGHTGUIDE_WAIT_SHORT;
002E26  EF28AA     CLR current_lihgtguide_short_tasks
110:                                   }
111:                               }
112:                               break;
002E24  370009     BRA 0x2E38
002E28  370007     BRA 0x2E38
002E32  000000     NOP
002E34  370001     BRA 0x2E38
002E36  000000     NOP
113:                       }
114:                   }
115:               }
002E38  FA8000     ULNK
002E3A  060000     RETURN
116:               
117:               /**********************************************************************
118:                * Function:        void app_short_tasks(void)
119:                * PreCondition:    None
120:                * Input:	    None
121:                * Output:	    None
122:                * Overview:	    This function used to manage applicator connection 
123:                *
124:                ***********************************************************************/
125:               void app_short_tasks(void) {
002E3C  FA0000     LNK #0x0
126:                   if (SystemState != SYS_STATE_TECHMODE) {
002E3E  8045D1     MOV 0x8BA, W1
002E40  200550     MOV #0x55, W0
002E42  508F80     SUB W1, W0, [W15]
002E44  32004E     BRA Z, 0x2EE2
127:                       switch (current_app_short_tasks) {
002E46  8044F0     MOV current_app_short_tasks, W0
002E48  500FE1     SUB W0, #0x1, [W15]
002E4A  320012     BRA Z, 0x2E70
002E4C  500FE1     SUB W0, #0x1, [W15]
002E4E  390005     BRA NC, 0x2E5A
002E50  500FE2     SUB W0, #0x2, [W15]
002E52  320021     BRA Z, 0x2E96
002E54  500FE3     SUB W0, #0x3, [W15]
002E56  320028     BRA Z, 0x2EA8
002E58  370044     BRA 0x2EE2
128:                           case WAIT_APPSHORT:
129:                               if (APP_SHORT) {
002E5A  801791     MOV PORTG, W1
002E5C  200400     MOV #0x40, W0
002E5E  608000     AND W1, W0, W0
002E60  E00000     CP0 W0
002E62  320004     BRA Z, 0x2E6C
130:                                   appShortTimeOut = 0; //reset timer
002E64  EF28A0     CLR appShortTimeOut
131:                                   current_app_short_tasks = WAIT_APPSHORT_BOUNCING;
002E66  200010     MOV #0x1, W0
002E68  8844F0     MOV W0, current_app_short_tasks
132:                               } else {
133:                                   Devices.ApplicatorIsConnected = TRUE;
002E6C  A82877     BSET 0x877, #1
134:                               }
135:                               break;
002E6A  37003B     BRA 0x2EE2
002E6E  370039     BRA 0x2EE2
136:               
137:                           case WAIT_APPSHORT_BOUNCING:
138:                               if (appShortTimeOut > 15) { //delay 5ms for bouncing
002E70  804500     MOV appShortTimeOut, W0
002E72  500FEF     SUB W0, #0xF, [W15]
002E74  36002D     BRA LEU, 0x2ED0
139:                                   if (APP_SHORT) {//if applicator disconnected or not connected shut off ipl module
002E76  801791     MOV PORTG, W1
002E78  200400     MOV #0x40, W0
002E7A  608000     AND W1, W0, W0
002E7C  E00000     CP0 W0
002E7E  320009     BRA Z, 0x2E92
140:                                       Devices.ApplicatorIsConnected = FALSE; //applicator disconnected
002E80  A92877     BCLR 0x877, #1
141:                                       Devices.SystemStatedUpdate = TRUE;
002E82  A80877     BSET 0x877, #0
142:                                       SystemStateToUpdate = SYS_STATE_FAULT;
002E84  2000F0     MOV #0xF, W0
002E86  8846E0     MOV W0, 0x8DC
143:                                       FaultNumber = FAULT_APPLICATOR_DISCONNECTED;
002E88  2001A0     MOV #0x1A, W0
002E8A  8843C0     MOV W0, FaultNumber
144:                                       current_app_short_tasks = APPSHORT_FAULT;
002E8C  200020     MOV #0x2, W0
002E8E  8844F0     MOV W0, current_app_short_tasks
145:                                   } else {
146:                                       current_app_short_tasks = WAIT_APPSHORT;
002E92  EF289E     CLR current_app_short_tasks
147:                                   }
148:                               }
149:                               break;
002E90  370028     BRA 0x2EE2
002E94  370026     BRA 0x2EE2
002ED0  000000     NOP
002ED2  370007     BRA 0x2EE2
150:               
151:                           case APPSHORT_FAULT:
152:                               if (!APP_SHORT) {
002E96  801791     MOV PORTG, W1
002E98  200400     MOV #0x40, W0
002E9A  608000     AND W1, W0, W0
002E9C  E00000     CP0 W0
002E9E  3A001A     BRA NZ, 0x2ED4
153:                                   appShortTimeOut = 0; //reset timer
002EA0  EF28A0     CLR appShortTimeOut
154:                                   current_app_short_tasks = APPSHORT_FAULT_QUIT;
002EA2  200030     MOV #0x3, W0
002EA4  8844F0     MOV W0, current_app_short_tasks
155:                               }
156:                               break;
002EA6  37001D     BRA 0x2EE2
002ED4  000000     NOP
002ED6  370005     BRA 0x2EE2
157:               
158:                           case APPSHORT_FAULT_QUIT:
159:                               if (appShortTimeOut > 500) {
002EA8  804501     MOV appShortTimeOut, W1
002EAA  201F40     MOV #0x1F4, W0
002EAC  508F80     SUB W1, W0, [W15]
002EAE  360014     BRA LEU, 0x2ED8
160:                                   if (!APP_SHORT) {
002EB0  801791     MOV PORTG, W1
002EB2  200400     MOV #0x40, W0
002EB4  608000     AND W1, W0, W0
002EB6  E00000     CP0 W0
002EB8  3A0011     BRA NZ, 0x2EDC
161:                                       if (FaultNumber == FAULT_APPLICATOR_DISCONNECTED) {
002EBA  8043C0     MOV FaultNumber, W0
002EBC  500FFA     SUB W0, #0x1A, [W15]
002EBE  3A0010     BRA NZ, 0x2EE0
162:                                           Devices.SystemStatedUpdate = TRUE;
002EC0  A80877     BSET 0x877, #0
163:                                           SystemStateToUpdate = SYS_STATE_INIT;
002EC2  200010     MOV #0x1, W0
002EC4  8846E0     MOV W0, 0x8DC
164:                                           FaultNumber = CLEAR;
002EC6  EF2878     CLR FaultNumber
165:                                           appShortTimeOut = 0; //reset timer
002EC8  EF28A0     CLR appShortTimeOut
166:                                           current_app_short_tasks = WAIT_APPSHORT_BOUNCING;
002ECA  200010     MOV #0x1, W0
002ECC  8844F0     MOV W0, current_app_short_tasks
167:                                       }
168:                                   }
169:                               }
170:                               break;
002ECE  370009     BRA 0x2EE2
002ED8  000000     NOP
002EDA  370003     BRA 0x2EE2
002EDC  000000     NOP
002EDE  370001     BRA 0x2EE2
002EE0  000000     NOP
171:                       }
172:                   }
173:               }
002EE2  FA8000     ULNK
002EE4  060000     RETURN
174:               
175:               /**********************************************************************
176:                * Function:        void trigger_tasks(void)
177:                * PreCondition:    None
178:                * Input:	    None
179:                * Output:	    None
180:                * Overview:	    This function used to manage applicator trigger
181:                *
182:                ***********************************************************************/
183:               void trigger_tasks(void) {
002EE6  FA0000     LNK #0x0
184:                   if ((Trigger == TRUE)&&(SystemState == SYS_STATE_STANDBY)) {
002EE8  804530     MOV Trigger, W0
002EEA  500FE1     SUB W0, #0x1, [W15]
002EEC  3A0005     BRA NZ, 0x2EF8
002EEE  8045D0     MOV 0x8BA, W0
002EF0  500FF0     SUB W0, #0x10, [W15]
002EF2  3A0002     BRA NZ, 0x2EF8
185:                       current_trigger_task = TRIGER_NOT_RELEASED;
002EF4  200030     MOV #0x3, W0
002EF6  884520     MOV W0, current_trigger_task
186:                   }
187:               
188:                   switch (current_trigger_task) {
002EF8  804520     MOV current_trigger_task, W0
002EFA  500FE2     SUB W0, #0x2, [W15]
002EFC  320066     BRA Z, 0x2FCA
002EFE  500FE2     SUB W0, #0x2, [W15]
002F00  3E0005     BRA GTU, 0x2F0C
002F02  E00000     CP0 W0
002F04  32000A     BRA Z, 0x2F1A
002F06  500FE1     SUB W0, #0x1, [W15]
002F08  32004D     BRA Z, 0x2FA4
002F0A  3700A0     BRA 0x304C
002F0C  500FE4     SUB W0, #0x4, [W15]
002F0E  320026     BRA Z, 0x2F5C
002F10  500FE4     SUB W0, #0x4, [W15]
002F12  390066     BRA NC, 0x2FE0
002F14  500FE5     SUB W0, #0x5, [W15]
002F16  32007B     BRA Z, 0x300E
002F18  370099     BRA 0x304C
189:                       case WAIT_TRIGGER:
190:                           if ((!TRIGGER1) && (!TRIGGER2)) {
002F1A  8016D0     MOV PORTD, W0
002F1C  600064     AND W0, #0x4, W0
002F1E  E00000     CP0 W0
002F20  3A0008     BRA NZ, 0x2F32
002F22  8016D0     MOV PORTD, W0
002F24  600062     AND W0, #0x2, W0
002F26  E00000     CP0 W0
002F28  3A0004     BRA NZ, 0x2F32
191:                               TriggerCounter = 0; //reset timer
002F2A  EF28A8     CLR TriggerCounter
192:                               current_trigger_task = WAIT_BOUNCING;
002F2C  200010     MOV #0x1, W0
002F2E  884520     MOV W0, current_trigger_task
193:                           } else {
194:                               Trigger = 0; //trigger not pushed
002F32  EF28A6     CLR Trigger
195:                               if (((TRIGGER1) && (!TRIGGER2)) || ((!TRIGGER1) && (TRIGGER2))) {
002F34  8016D0     MOV PORTD, W0
002F36  600064     AND W0, #0x4, W0
002F38  E00000     CP0 W0
002F3A  320004     BRA Z, 0x2F44
002F3C  8016D0     MOV PORTD, W0
002F3E  600062     AND W0, #0x2, W0
002F40  E00000     CP0 W0
002F42  320008     BRA Z, 0x2F54
002F44  8016D0     MOV PORTD, W0
002F46  600064     AND W0, #0x4, W0
002F48  E00000     CP0 W0
002F4A  3A0071     BRA NZ, 0x302E
002F4C  8016D0     MOV PORTD, W0
002F4E  600062     AND W0, #0x2, W0
002F50  E00000     CP0 W0
002F52  32006F     BRA Z, 0x3032
196:                                   TriggerCounter = 0;
002F54  EF28A8     CLR TriggerCounter
197:                                   current_trigger_task = WAIT_FOR_SECOND_SWITCH;
002F56  200040     MOV #0x4, W0
002F58  884520     MOV W0, current_trigger_task
198:                               }
199:                           }
200:                           break;
002F30  37008D     BRA 0x304C
002F5A  370078     BRA 0x304C
00302E  000000     NOP
003030  37000D     BRA 0x304C
003032  000000     NOP
003034  37000B     BRA 0x304C
201:               
202:                       case WAIT_FOR_SECOND_SWITCH:
203:                           if ((!TRIGGER1) && (!TRIGGER2)) {
002F5C  8016D0     MOV PORTD, W0
002F5E  600064     AND W0, #0x4, W0
002F60  E00000     CP0 W0
002F62  3A0008     BRA NZ, 0x2F74
002F64  8016D0     MOV PORTD, W0
002F66  600062     AND W0, #0x2, W0
002F68  E00000     CP0 W0
002F6A  3A0004     BRA NZ, 0x2F74
204:                               TriggerCounter = 0; //reset timer
002F6C  EF28A8     CLR TriggerCounter
205:                               current_trigger_task = WAIT_BOUNCING;
002F6E  200010     MOV #0x1, W0
002F70  884520     MOV W0, current_trigger_task
002F72  370017     BRA 0x2FA2
206:                               //Devices.SystemStatedUpdate = TRUE;
207:                               //SystemStateToUpdate = SYS_STATE_STANDBY;
208:                               //FaultNumber = CLEAR;
209:                           } else if ((TRIGGER1) && (TRIGGER2)) {
002F74  8016D0     MOV PORTD, W0
002F76  600064     AND W0, #0x4, W0
002F78  E00000     CP0 W0
002F7A  320007     BRA Z, 0x2F8A
002F7C  8016D0     MOV PORTD, W0
002F7E  600062     AND W0, #0x2, W0
002F80  E00000     CP0 W0
002F82  320003     BRA Z, 0x2F8A
210:                               current_trigger_task = WAIT_TRIGGER;
002F84  EF28A4     CLR current_trigger_task
211:                               Trigger = 0; //trigger not pushed{
002F86  EF28A6     CLR Trigger
002F88  37000C     BRA 0x2FA2
212:                               //                Devices.SystemStatedUpdate = TRUE;
213:                               //                SystemStateToUpdate = SYS_STATE_STANDBY;
214:                               //                FaultNumber = CLEAR;
215:                           } else {
216:                               if (TriggerCounter > 3500) {
002F8A  804541     MOV TriggerCounter, W1
002F8C  20DAC0     MOV #0xDAC, W0
002F8E  508F80     SUB W1, W0, [W15]
002F90  360052     BRA LEU, 0x3036
217:                                   Devices.SystemStatedUpdate = TRUE;
002F92  A80877     BSET 0x877, #0
218:                                   SystemStateToUpdate = SYS_STATE_FAULT;
002F94  2000F0     MOV #0xF, W0
002F96  8846E0     MOV W0, 0x8DC
219:                                   FaultNumber = FAULT_TRIGGER_MALFUNCTION;
002F98  200220     MOV #0x22, W0
002F9A  8843C0     MOV W0, FaultNumber
220:                                   current_trigger_task = TRIGGER_FAULT;
002F9C  200050     MOV #0x5, W0
002F9E  884520     MOV W0, current_trigger_task
221:                               }
222:                           }
223:               
224:                           break;
002FA0  370055     BRA 0x304C
002FA2  370054     BRA 0x304C
003036  000000     NOP
003038  370009     BRA 0x304C
225:               
226:                       case WAIT_BOUNCING:
227:                           if (TriggerCounter > 15) { //delay 15ms for bouncing
002FA4  804540     MOV TriggerCounter, W0
002FA6  500FEF     SUB W0, #0xF, [W15]
002FA8  360048     BRA LEU, 0x303A
228:                               if ((!TRIGGER1) && (!TRIGGER2)) {
002FAA  8016D0     MOV PORTD, W0
002FAC  600064     AND W0, #0x4, W0
002FAE  E00000     CP0 W0
002FB0  3A0009     BRA NZ, 0x2FC4
002FB2  8016D0     MOV PORTD, W0
002FB4  600062     AND W0, #0x2, W0
002FB6  E00000     CP0 W0
002FB8  3A0005     BRA NZ, 0x2FC4
229:                                   Trigger = 1; // trigger pushed
002FBA  200010     MOV #0x1, W0
002FBC  884530     MOV W0, Trigger
230:                                   current_trigger_task = WAIT_RELEASE;
002FBE  200020     MOV #0x2, W0
002FC0  884520     MOV W0, current_trigger_task
231:                               } else {
232:                                   Trigger = 0; //trigger not pushed
002FC4  EF28A6     CLR Trigger
233:                                   current_trigger_task = WAIT_TRIGGER;
002FC6  EF28A4     CLR current_trigger_task
234:                               }
235:                           }
236:                           break;
002FC2  370044     BRA 0x304C
002FC8  370041     BRA 0x304C
00303A  000000     NOP
00303C  370007     BRA 0x304C
237:               
238:                       case WAIT_RELEASE:
239:                           if ((TRIGGER1) || (TRIGGER2)) {
002FCA  8016D0     MOV PORTD, W0
002FCC  600064     AND W0, #0x4, W0
002FCE  E00000     CP0 W0
002FD0  3A0004     BRA NZ, 0x2FDA
002FD2  8016D0     MOV PORTD, W0
002FD4  600062     AND W0, #0x2, W0
002FD6  E00000     CP0 W0
002FD8  320032     BRA Z, 0x303E
240:                               current_trigger_task = WAIT_TRIGGER;
002FDA  EF28A4     CLR current_trigger_task
241:                               Trigger = 0; //trigger not pushed
002FDC  EF28A6     CLR Trigger
242:                           }
243:                           break;
002FDE  370036     BRA 0x304C
00303E  000000     NOP
003040  370005     BRA 0x304C
244:               
245:                       case TRIGER_NOT_RELEASED:
246:                           if (SystemState == SYS_STATE_PENDING) {
002FE0  8045D0     MOV 0x8BA, W0
002FE2  500FF5     SUB W0, #0x15, [W15]
002FE4  3A0005     BRA NZ, 0x2FF0
247:                               Devices.SystemStatedUpdate = TRUE;
002FE6  A80877     BSET 0x877, #0
248:                               SystemStateToUpdate = SYS_STATE_FAULT;
002FE8  2000F0     MOV #0xF, W0
002FEA  8846E0     MOV W0, 0x8DC
249:                               FaultNumber = FAULT_TRIGGER_NOT_RELEASED;
002FEC  200280     MOV #0x28, W0
002FEE  8843C0     MOV W0, FaultNumber
250:                           }
251:               
252:                           if ((TRIGGER1) || (TRIGGER2)) {
002FF0  8016D0     MOV PORTD, W0
002FF2  600064     AND W0, #0x4, W0
002FF4  E00000     CP0 W0
002FF6  3A0004     BRA NZ, 0x3000
002FF8  8016D0     MOV PORTD, W0
002FFA  600062     AND W0, #0x2, W0
002FFC  E00000     CP0 W0
002FFE  320021     BRA Z, 0x3042
253:                               current_trigger_task = WAIT_TRIGGER;
003000  EF28A4     CLR current_trigger_task
254:                               Trigger = 0; //trigger not pushed
003002  EF28A6     CLR Trigger
255:                               Devices.SystemStatedUpdate = TRUE;
003004  A80877     BSET 0x877, #0
256:                               SystemStateToUpdate = SYS_STATE_STANDBY;
003006  200100     MOV #0x10, W0
003008  8846E0     MOV W0, 0x8DC
257:                               FaultNumber = CLEAR;
00300A  EF2878     CLR FaultNumber
258:                           }
259:                           break;
00300C  37001F     BRA 0x304C
003042  000000     NOP
003044  370003     BRA 0x304C
260:               
261:                       case TRIGGER_FAULT:
262:                           if ((TRIGGER1) && (TRIGGER2)) {
00300E  8016D0     MOV PORTD, W0
003010  600064     AND W0, #0x4, W0
003012  E00000     CP0 W0
003014  320018     BRA Z, 0x3046
003016  8016D0     MOV PORTD, W0
003018  600062     AND W0, #0x2, W0
00301A  E00000     CP0 W0
00301C  320016     BRA Z, 0x304A
263:                               current_trigger_task = WAIT_TRIGGER;
00301E  EF28A4     CLR current_trigger_task
264:                               current_trigger_task = WAIT_TRIGGER;
003020  EF28A4     CLR current_trigger_task
265:                               Trigger = 0; //trigger not pushed
003022  EF28A6     CLR Trigger
266:                               Devices.SystemStatedUpdate = TRUE;
003024  A80877     BSET 0x877, #0
267:                               SystemStateToUpdate = SYS_STATE_STANDBY;
003026  200100     MOV #0x10, W0
003028  8846E0     MOV W0, 0x8DC
268:                               FaultNumber = CLEAR;
00302A  EF2878     CLR FaultNumber
269:                           }
270:                           break;
00302C  37000F     BRA 0x304C
003046  000000     NOP
003048  370001     BRA 0x304C
00304A  000000     NOP
271:                   }
272:               }
00304C  FA8000     ULNK
00304E  060000     RETURN
